<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DNS.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.net</a> &gt; <span class="el_source">DNS.java</span></div><h1>DNS.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// This code has been copied from hadoop-common 2.0.4-alpha
package org.apache.bookkeeper.net;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.Collections;
import java.util.Enumeration;
import java.util.LinkedHashSet;
import java.util.Vector;

import javax.naming.NamingException;
import javax.naming.directory.Attributes;
import javax.naming.directory.DirContext;
import javax.naming.directory.InitialDirContext;

/**
 * A class that provides direct and reverse lookup functionalities, allowing
 * the querying of specific network interfaces or nameservers.
 */
<span class="nc" id="L42">public class DNS {</span>

<span class="fc" id="L44">    private static final Logger LOG = LoggerFactory.getLogger(DNS.class);</span>

    /**
     * The cached hostname -initially null.
     */

<span class="fc" id="L50">    private static final String cachedHostname = resolveLocalHostname();</span>
<span class="fc" id="L51">    private static final String cachedHostAddress = resolveLocalHostIPAddress();</span>
    private static final String LOCALHOST = &quot;localhost&quot;;

    /**
     * Returns the hostname associated with the specified IP address by the
     * provided nameserver.
     * &lt;p/&gt;
     * Loopback addresses
     *
     * @param hostIp The address to reverse lookup
     * @param ns     The host name of a reachable DNS server
     * @return The host name associated with the provided IP
     * @throws NamingException If a NamingException is encountered
     */
    public static String reverseDns(InetAddress hostIp, String ns)
            throws NamingException {
        //
        // Builds the reverse IP lookup form
        // This is formed by reversing the IP numbers and appending in-addr.arpa
        //
<span class="nc" id="L71">        String[] parts = hostIp.getHostAddress().split(&quot;\\.&quot;);</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">        if(parts.length !=4) {</span>
            //Not proper address. May be IPv6
<span class="nc" id="L74">            throw new NamingException(&quot;IPV6&quot;);</span>
        }
<span class="nc" id="L76">        String reverseIP = parts[3] + &quot;.&quot; + parts[2] + &quot;.&quot; + parts[1] + &quot;.&quot;</span>
                + parts[0] + &quot;.in-addr.arpa&quot;;

<span class="nc" id="L79">        DirContext ictx = new InitialDirContext();</span>
        Attributes attribute;
        try {
<span class="nc bnc" id="L82" title="All 2 branches missed.">            attribute = ictx.getAttributes(&quot;dns://&quot;               // Use &quot;dns:///&quot; if the default</span>
                    + ((ns == null) ? &quot;&quot; : ns) +
                    // nameserver is to be used
                    &quot;/&quot; + reverseIP, new String[]{&quot;PTR&quot;});
        } finally {
<span class="nc" id="L87">            ictx.close();</span>
        }

<span class="nc" id="L90">        return attribute.get(&quot;PTR&quot;).get().toString();</span>
    }

    /**
     * @return NetworkInterface for the given subinterface name (eg eth0:0)
     * or null if no interface with the given name can be found
     */
    private static NetworkInterface getSubinterface(String strInterface)
            throws SocketException {
        Enumeration&lt;NetworkInterface&gt; nifs =
<span class="nc" id="L100">                NetworkInterface.getNetworkInterfaces();</span>

<span class="nc bnc" id="L102" title="All 2 branches missed.">        while (nifs.hasMoreElements()) {</span>
<span class="nc" id="L103">            Enumeration&lt;NetworkInterface&gt; subNifs =</span>
<span class="nc" id="L104">                    nifs.nextElement().getSubInterfaces();</span>

<span class="nc bnc" id="L106" title="All 2 branches missed.">            while (subNifs.hasMoreElements()) {</span>
<span class="nc" id="L107">                NetworkInterface nif = subNifs.nextElement();</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">                if (nif.getName().equals(strInterface)) {</span>
<span class="nc" id="L109">                    return nif;</span>
                }
<span class="nc" id="L111">            }</span>
<span class="nc" id="L112">        }</span>
<span class="nc" id="L113">        return null;</span>
    }

    /**
     * @param nif network interface to get addresses for
     * @return set containing addresses for each subinterface of nif,
     * see below for the rationale for using an ordered set
     */
    private static LinkedHashSet&lt;InetAddress&gt; getSubinterfaceInetAddrs(
            NetworkInterface nif) {
<span class="nc" id="L123">        LinkedHashSet&lt;InetAddress&gt; addrs = new LinkedHashSet&lt;InetAddress&gt;();</span>
<span class="nc" id="L124">        Enumeration&lt;NetworkInterface&gt; subNifs = nif.getSubInterfaces();</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">        while (subNifs.hasMoreElements()) {</span>
<span class="nc" id="L126">            NetworkInterface subNif = subNifs.nextElement();</span>
<span class="nc" id="L127">            addrs.addAll(Collections.list(subNif.getInetAddresses()));</span>
<span class="nc" id="L128">        }</span>
<span class="nc" id="L129">        return addrs;</span>
    }

    /**
     * Like {@link DNS#getIPs(String, boolean), but returns all
     * IPs associated with the given interface and its subinterfaces.
     */
    public static String[] getIPs(String strInterface)
            throws UnknownHostException {
<span class="nc" id="L138">        return getIPs(strInterface, true);</span>
    }

    /**
     * Returns all the IPs associated with the provided interface, if any, in
     * textual form.
     *
     * @param strInterface        The name of the network interface or sub-interface to query
     *                            (eg eth0 or eth0:0) or the string &quot;default&quot;
     * @param returnSubinterfaces Whether to return IPs associated with subinterfaces of
     *                            the given interface
     * @return A string vector of all the IPs associated with the provided
     * interface. The local host IP is returned if the interface
     * name &quot;default&quot; is specified or there is an I/O error looking
     * for the given interface.
     * @throws UnknownHostException If the given interface is invalid
     */
    public static String[] getIPs(String strInterface,
                                  boolean returnSubinterfaces) throws UnknownHostException {
<span class="nc bnc" id="L157" title="All 2 branches missed.">        if (&quot;default&quot;.equals(strInterface)) {</span>
<span class="nc" id="L158">            return new String[]{cachedHostAddress};</span>
        }
        NetworkInterface netIf;
        try {
<span class="nc" id="L162">            netIf = NetworkInterface.getByName(strInterface);</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">            if (netIf == null) {</span>
<span class="nc" id="L164">                netIf = getSubinterface(strInterface);</span>
            }
<span class="nc" id="L166">        } catch (SocketException e) {</span>
<span class="nc" id="L167">            LOG.warn(&quot;I/O error finding interface &quot; + strInterface +</span>
<span class="nc" id="L168">                    &quot;: &quot; + e.getMessage());</span>
<span class="nc" id="L169">            return new String[]{cachedHostAddress};</span>
<span class="nc" id="L170">        }</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">        if (netIf == null) {</span>
<span class="nc" id="L172">            throw new UnknownHostException(&quot;No such interface &quot; + strInterface);</span>
        }

        // NB: Using a LinkedHashSet to preserve the order for callers
        // that depend on a particular element being 1st in the array.
        // For example, getDefaultIP always returns the first element.
<span class="nc" id="L178">        LinkedHashSet&lt;InetAddress&gt; allAddrs = new LinkedHashSet&lt;InetAddress&gt;();</span>
<span class="nc" id="L179">        allAddrs.addAll(Collections.list(netIf.getInetAddresses()));</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">        if (!returnSubinterfaces) {</span>
<span class="nc" id="L181">            allAddrs.removeAll(getSubinterfaceInetAddrs(netIf));</span>
        }

<span class="nc" id="L184">        String ips[] = new String[allAddrs.size()];</span>
<span class="nc" id="L185">        int i = 0;</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">        for (InetAddress addr : allAddrs) {</span>
<span class="nc" id="L187">            ips[i++] = addr.getHostAddress();</span>
<span class="nc" id="L188">        }</span>
<span class="nc" id="L189">        return ips;</span>
    }


    /**
     * Returns the first available IP address associated with the provided
     * network interface or the local host IP if &quot;default&quot; is given.
     *
     * @param strInterface The name of the network interface or subinterface to query
     *                     (e.g. eth0 or eth0:0) or the string &quot;default&quot;
     * @return The IP address in text form, the local host IP is returned
     * if the interface name &quot;default&quot; is specified
     * @throws UnknownHostException If the given interface is invalid
     */
    public static String getDefaultIP(String strInterface)
            throws UnknownHostException {
<span class="nc" id="L205">        String[] ips = getIPs(strInterface);</span>
<span class="nc" id="L206">        return ips[0];</span>
    }

    /**
     * Returns all the host names associated by the provided nameserver with the
     * address bound to the specified network interface
     *
     * @param strInterface The name of the network interface or subinterface to query
     *                     (e.g. eth0 or eth0:0)
     * @param nameserver   The DNS host name
     * @return A string vector of all host names associated with the IPs tied to
     * the specified interface
     * @throws UnknownHostException if the given interface is invalid
     */
    public static String[] getHosts(String strInterface, String nameserver)
            throws UnknownHostException {
<span class="nc" id="L222">        String[] ips = getIPs(strInterface);</span>
<span class="nc" id="L223">        Vector&lt;String&gt; hosts = new Vector&lt;String&gt;();</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">        for (int ctr = 0; ctr &lt; ips.length; ctr++) {</span>
            try {
<span class="nc" id="L226">                hosts.add(reverseDns(InetAddress.getByName(ips[ctr]),</span>
                        nameserver));
<span class="nc" id="L228">            } catch (UnknownHostException ignored) {</span>
<span class="nc" id="L229">            } catch (NamingException ignored) {</span>
<span class="nc" id="L230">            }</span>
        }
<span class="nc bnc" id="L232" title="All 2 branches missed.">        if (hosts.isEmpty()) {</span>
<span class="nc" id="L233">            LOG.warn(&quot;Unable to determine hostname for interface &quot; + strInterface);</span>
<span class="nc" id="L234">            return new String[]{cachedHostname};</span>
        } else {
<span class="nc" id="L236">            return hosts.toArray(new String[hosts.size()]);</span>
        }
    }


    /**
     * Determine the local hostname; retrieving it from cache if it is known
     * If we cannot determine our host name, return &quot;localhost&quot;
     *
     * @return the local hostname or &quot;localhost&quot;
     */
    private static String resolveLocalHostname() {
        String localhost;
        try {
<span class="fc" id="L250">            localhost = InetAddress.getLocalHost().getCanonicalHostName();</span>
<span class="nc" id="L251">        } catch (UnknownHostException e) {</span>
<span class="nc" id="L252">            LOG.warn(&quot;Unable to determine local hostname &quot;</span>
                    + &quot;-falling back to \&quot;&quot; + LOCALHOST + &quot;\&quot;&quot;, e);
<span class="nc" id="L254">            localhost = LOCALHOST;</span>
<span class="fc" id="L255">        }</span>
<span class="fc" id="L256">        return localhost;</span>
    }


    /**
     * Get the IPAddress of the local host as a string.
     * This will be a loop back value if the local host address cannot be
     * determined.
     * If the loopback address of &quot;localhost&quot; does not resolve, then the system's
     * network is in such a state that nothing is going to work. A message is
     * logged at the error level and a null pointer returned, a pointer
     * which will trigger failures later on the application
     *
     * @return the IPAddress of the local host or null for a serious problem.
     */
    private static String resolveLocalHostIPAddress() {
        String address;
        try {
<span class="fc" id="L274">            address = InetAddress.getLocalHost().getHostAddress();</span>
<span class="nc" id="L275">        } catch (UnknownHostException e) {</span>
<span class="nc" id="L276">            LOG.warn(&quot;Unable to determine address of the host&quot;</span>
                    + &quot;-falling back to \&quot;&quot; + LOCALHOST + &quot;\&quot; address&quot;, e);
            try {
<span class="nc" id="L279">                address = InetAddress.getByName(LOCALHOST).getHostAddress();</span>
<span class="nc" id="L280">            } catch (UnknownHostException noLocalHostAddressException) {</span>
                //at this point, deep trouble
<span class="nc" id="L282">                LOG.error(&quot;Unable to determine local loopback address &quot;</span>
                        + &quot;of \&quot;&quot; + LOCALHOST + &quot;\&quot; &quot; +
                        &quot;-this system's network configuration is unsupported&quot;, e);
<span class="nc" id="L285">                address = null;</span>
<span class="nc" id="L286">            }</span>
<span class="fc" id="L287">        }</span>
<span class="fc" id="L288">        return address;</span>
    }

    /**
     * Returns all the host names associated by the default nameserver with the
     * address bound to the specified network interface
     *
     * @param strInterface The name of the network interface to query (e.g. eth0)
     * @return The list of host names associated with IPs bound to the network
     * interface
     * @throws UnknownHostException If one is encountered while querying the default interface
     */
    public static String[] getHosts(String strInterface)
            throws UnknownHostException {
<span class="nc" id="L302">        return getHosts(strInterface, null);</span>
    }

    /**
     * Returns the default (first) host name associated by the provided
     * nameserver with the address bound to the specified network interface
     *
     * @param strInterface The name of the network interface to query (e.g. eth0)
     * @param nameserver   The DNS host name
     * @return The default host names associated with IPs bound to the network
     * interface
     * @throws UnknownHostException If one is encountered while querying the default interface
     */
    public static String getDefaultHost(String strInterface, String nameserver)
            throws UnknownHostException {
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">        if (&quot;default&quot;.equals(strInterface)) {</span>
<span class="fc" id="L318">            return cachedHostname;</span>
        }

<span class="nc bnc" id="L321" title="All 2 branches missed.">        if (&quot;default&quot;.equals(nameserver)) {</span>
<span class="nc" id="L322">            return getDefaultHost(strInterface);</span>
        }

<span class="nc" id="L325">        String[] hosts = getHosts(strInterface, nameserver);</span>
<span class="nc" id="L326">        return hosts[0];</span>
    }

    /**
     * Returns the default (first) host name associated by the default
     * nameserver with the address bound to the specified network interface
     *
     * @param strInterface The name of the network interface to query (e.g. eth0).
     *                     Must not be null.
     * @return The default host name associated with IPs bound to the network
     * interface
     * @throws UnknownHostException If one is encountered while querying the default interface
     */
    public static String getDefaultHost(String strInterface)
            throws UnknownHostException {
<span class="fc" id="L341">        return getDefaultHost(strInterface, null);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>