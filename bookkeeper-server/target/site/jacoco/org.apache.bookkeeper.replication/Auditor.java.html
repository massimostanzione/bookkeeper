<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Auditor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.replication</a> &gt; <span class="el_source">Auditor.java</span></div><h1>Auditor.java</h1><pre class="source lang-java linenums">/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.bookkeeper.replication;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Stopwatch;
import com.google.common.collect.Sets;
import com.google.common.util.concurrent.SettableFuture;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import org.apache.bookkeeper.client.BKException;
import org.apache.bookkeeper.client.BookKeeper;
import org.apache.bookkeeper.client.BookKeeperAdmin;
import org.apache.bookkeeper.client.LedgerChecker;
import org.apache.bookkeeper.client.LedgerFragment;
import org.apache.bookkeeper.client.LedgerHandle;
import org.apache.bookkeeper.conf.ClientConfiguration;
import org.apache.bookkeeper.conf.ServerConfiguration;
import org.apache.bookkeeper.meta.LedgerManager;
import org.apache.bookkeeper.meta.LedgerManagerFactory;
import org.apache.bookkeeper.meta.LedgerUnderreplicationManager;
import org.apache.bookkeeper.net.BookieSocketAddress;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.Processor;
import org.apache.bookkeeper.replication.ReplicationException.BKAuditException;
import org.apache.bookkeeper.replication.ReplicationException.CompatibilityException;
import org.apache.bookkeeper.replication.ReplicationException.UnavailableException;
import org.apache.bookkeeper.stats.Counter;
import org.apache.bookkeeper.stats.OpStatsLogger;
import org.apache.bookkeeper.stats.StatsLogger;
import org.apache.bookkeeper.zookeeper.ZooKeeperClient;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.zookeeper.AsyncCallback;
import org.apache.zookeeper.KeeperException;
import org.apache.zookeeper.ZooKeeper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Auditor is a single entity in the entire Bookie cluster and will be watching
 * all the bookies under 'ledgerrootpath/available' zkpath. When any of the
 * bookie failed or disconnected from zk, he will start initiating the
 * re-replication activities by keeping all the corresponding ledgers of the
 * failed bookie as underreplicated znode in zk.
 */
public class Auditor {
<span class="nc" id="L76">    private static final Logger LOG = LoggerFactory.getLogger(Auditor.class);</span>
    private final ServerConfiguration conf;
    private BookKeeper bkc;
    private BookKeeperAdmin admin;
    private BookieLedgerIndexer bookieLedgerIndexer;
    private LedgerManager ledgerManager;
    private LedgerUnderreplicationManager ledgerUnderreplicationManager;
    private final ScheduledExecutorService executor;
<span class="nc" id="L84">    private List&lt;String&gt; knownBookies = new ArrayList&lt;String&gt;();</span>
    private final String bookieIdentifier;
    private final StatsLogger statsLogger;
    private final OpStatsLogger numUnderReplicatedLedger;
    private final OpStatsLogger uRLPublishTimeForLostBookies;
    private final OpStatsLogger bookieToLedgersMapCreationTime;
    private final OpStatsLogger checkAllLedgersTime;
    private final Counter numLedgersChecked;
    private final OpStatsLogger numFragmentsPerLedger;
    private final OpStatsLogger numBookiesPerLedger;
    private final Counter numBookieAuditsDelayed;
    private final Counter numDelayedBookieAuditsCancelled;
    private volatile Future&lt;?&gt; auditTask;
<span class="nc" id="L97">    private Set&lt;String&gt; bookiesToBeAudited = Sets.newHashSet();</span>
    private volatile int lostBookieRecoveryDelayBeforeChange;
    
    public Auditor(final String bookieIdentifier, ServerConfiguration conf,
<span class="nc" id="L101">                   ZooKeeper zkc, StatsLogger statsLogger) throws UnavailableException {</span>
<span class="nc" id="L102">        this.conf = conf;</span>
<span class="nc" id="L103">        this.bookieIdentifier = bookieIdentifier;</span>
<span class="nc" id="L104">        this.statsLogger = statsLogger;</span>

<span class="nc" id="L106">        numUnderReplicatedLedger = this.statsLogger.getOpStatsLogger(ReplicationStats.NUM_UNDER_REPLICATED_LEDGERS);</span>
<span class="nc" id="L107">        uRLPublishTimeForLostBookies = this.statsLogger</span>
<span class="nc" id="L108">                .getOpStatsLogger(ReplicationStats.URL_PUBLISH_TIME_FOR_LOST_BOOKIE);</span>
<span class="nc" id="L109">        bookieToLedgersMapCreationTime = this.statsLogger</span>
<span class="nc" id="L110">                .getOpStatsLogger(ReplicationStats.BOOKIE_TO_LEDGERS_MAP_CREATION_TIME);</span>
<span class="nc" id="L111">        checkAllLedgersTime = this.statsLogger.getOpStatsLogger(ReplicationStats.CHECK_ALL_LEDGERS_TIME);</span>
<span class="nc" id="L112">        numLedgersChecked = this.statsLogger.getCounter(ReplicationStats.NUM_LEDGERS_CHECKED);</span>
<span class="nc" id="L113">        numFragmentsPerLedger = statsLogger.getOpStatsLogger(ReplicationStats.NUM_FRAGMENTS_PER_LEDGER);</span>
<span class="nc" id="L114">        numBookiesPerLedger = statsLogger.getOpStatsLogger(ReplicationStats.NUM_BOOKIES_PER_LEDGER);</span>
<span class="nc" id="L115">        numBookieAuditsDelayed = this.statsLogger.getCounter(ReplicationStats.NUM_BOOKIE_AUDITS_DELAYED);</span>
<span class="nc" id="L116">        numDelayedBookieAuditsCancelled = this.statsLogger</span>
<span class="nc" id="L117">                .getCounter(ReplicationStats.NUM_DELAYED_BOOKIE_AUDITS_DELAYES_CANCELLED);</span>

<span class="nc" id="L119">        initialize(conf, zkc);</span>

<span class="nc" id="L121">        executor = Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {</span>
                @Override
                public Thread newThread(Runnable r) {
<span class="nc" id="L124">                    Thread t = new Thread(r, &quot;AuditorBookie-&quot; + bookieIdentifier);</span>
<span class="nc" id="L125">                    t.setDaemon(true);</span>
<span class="nc" id="L126">                    return t;</span>
                }
            });
<span class="nc" id="L129">    }</span>

    private void initialize(ServerConfiguration conf, ZooKeeper zkc)
            throws UnavailableException {
        try {
<span class="nc" id="L134">            LedgerManagerFactory ledgerManagerFactory = LedgerManagerFactory</span>
<span class="nc" id="L135">                    .newLedgerManagerFactory(conf, zkc);</span>
<span class="nc" id="L136">            ledgerManager = ledgerManagerFactory.newLedgerManager();</span>
<span class="nc" id="L137">            this.bookieLedgerIndexer = new BookieLedgerIndexer(ledgerManager);</span>

<span class="nc" id="L139">            this.ledgerUnderreplicationManager = ledgerManagerFactory</span>
<span class="nc" id="L140">                    .newLedgerUnderreplicationManager();</span>

<span class="nc" id="L142">            ClientConfiguration clientConfiguration = new ClientConfiguration(conf);</span>
<span class="nc" id="L143">            clientConfiguration.setClientRole(ClientConfiguration.CLIENT_ROLE_SYSTEM);</span>
<span class="nc" id="L144">            LOG.info(&quot;AuthProvider used by the Auditor is &quot;+clientConfiguration.getClientAuthProviderFactoryClass());</span>
<span class="nc" id="L145">            this.bkc = new BookKeeper(clientConfiguration, zkc);</span>
<span class="nc" id="L146">            this.admin = new BookKeeperAdmin(bkc, statsLogger);</span>
<span class="nc" id="L147">            if (this.ledgerUnderreplicationManager</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">                    .initializeLostBookieRecoveryDelay(conf.getLostBookieRecoveryDelay())) {</span>
<span class="nc" id="L149">                LOG.info(&quot;Initializing lostBookieRecoveryDelay zNode to the conif value: {}&quot;,</span>
<span class="nc" id="L150">                        conf.getLostBookieRecoveryDelay());</span>
            } else {
<span class="nc" id="L152">                LOG.info(</span>
                        &quot;Valid lostBookieRecoveryDelay zNode is available, so not creating lostBookieRecoveryDelay zNode as part of Auditor initialization &quot;);
            }
<span class="nc" id="L155">            lostBookieRecoveryDelayBeforeChange = this.ledgerUnderreplicationManager.getLostBookieRecoveryDelay();</span>
<span class="nc" id="L156">        } catch (CompatibilityException ce) {</span>
<span class="nc" id="L157">            throw new UnavailableException(</span>
                    &quot;CompatibilityException while initializing Auditor&quot;, ce);
<span class="nc" id="L159">        } catch (IOException | BKException | KeeperException ioe) {</span>
<span class="nc" id="L160">            throw new UnavailableException(</span>
                    &quot;Exception while initializing Auditor&quot;, ioe);
<span class="nc" id="L162">        } catch (InterruptedException ie) {</span>
<span class="nc" id="L163">            throw new UnavailableException(</span>
                    &quot;Interrupted while initializing Auditor&quot;, ie);
<span class="nc" id="L165">        }</span>
<span class="nc" id="L166">    }</span>

    private void submitShutdownTask() {
<span class="nc" id="L169">        synchronized (this) {</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">            if (executor.isShutdown()) {</span>
<span class="nc" id="L171">                return;</span>
            }
<span class="nc" id="L173">            executor.submit(new Runnable() {</span>
                    public void run() {
<span class="nc" id="L175">                        synchronized (Auditor.this) {</span>
<span class="nc" id="L176">                            executor.shutdown();</span>
<span class="nc" id="L177">                        }</span>
<span class="nc" id="L178">                    }</span>
                });
<span class="nc" id="L180">        }</span>
<span class="nc" id="L181">    }</span>

    @VisibleForTesting
    synchronized Future&lt;?&gt; submitAuditTask() {
<span class="nc bnc" id="L185" title="All 2 branches missed.">        if (executor.isShutdown()) {</span>
<span class="nc" id="L186">            SettableFuture&lt;Void&gt; f = SettableFuture.&lt;Void&gt;create();</span>
<span class="nc" id="L187">            f.setException(new BKAuditException(&quot;Auditor shutting down&quot;));</span>
<span class="nc" id="L188">            return f;</span>
        }
<span class="nc" id="L190">        return executor.submit(new Runnable() {</span>
                @SuppressWarnings(&quot;unchecked&quot;)
                public void run() {
                    try {
<span class="nc" id="L194">                        waitIfLedgerReplicationDisabled();</span>
<span class="nc" id="L195">                        int lostBookieRecoveryDelay = Auditor.this.ledgerUnderreplicationManager</span>
<span class="nc" id="L196">                                .getLostBookieRecoveryDelay();</span>
<span class="nc" id="L197">                        List&lt;String&gt; availableBookies = getAvailableBookies();</span>

                        // casting to String, as knownBookies and availableBookies
                        // contains only String values
                        // find new bookies(if any) and update the known bookie list
<span class="nc" id="L202">                        Collection&lt;String&gt; newBookies = CollectionUtils.subtract(</span>
<span class="nc" id="L203">                                availableBookies, knownBookies);</span>
<span class="nc" id="L204">                        knownBookies.addAll(newBookies);</span>
<span class="nc bnc" id="L205" title="All 4 branches missed.">                        if (!bookiesToBeAudited.isEmpty() &amp;&amp; knownBookies.containsAll(bookiesToBeAudited)) {</span>
                            // the bookie, which went down earlier and had an audit scheduled for,
                            // has come up. So let us stop tracking it and cancel the audit. Since
                            // we allow delaying of audit when there is only one failed bookie,
                            // bookiesToBeAudited should just have 1 element and hence containsAll
                            // check should be ok
<span class="nc bnc" id="L211" title="All 4 branches missed.">                            if (auditTask != null &amp;&amp; auditTask.cancel(false)) {</span>
<span class="nc" id="L212">                                auditTask = null;</span>
<span class="nc" id="L213">                                numDelayedBookieAuditsCancelled.inc();</span>
                            }
<span class="nc" id="L215">                            bookiesToBeAudited.clear();</span>
                        }

                        // find lost bookies(if any)
<span class="nc" id="L219">                        bookiesToBeAudited.addAll(CollectionUtils.subtract(knownBookies, availableBookies));</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">                        if (bookiesToBeAudited.size() == 0) {</span>
<span class="nc" id="L221">                            return;</span>
                        }

<span class="nc" id="L224">                        knownBookies.removeAll(bookiesToBeAudited);</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">                        if (lostBookieRecoveryDelay == 0) {</span>
<span class="nc" id="L226">                            startAudit(false);</span>
<span class="nc" id="L227">                            bookiesToBeAudited.clear();</span>
<span class="nc" id="L228">                            return;</span>
                        }
<span class="nc bnc" id="L230" title="All 2 branches missed.">                        if (bookiesToBeAudited.size() &gt; 1) {</span>
                            // if more than one bookie is down, start the audit immediately;
<span class="nc" id="L232">                            LOG.info(&quot;Multiple bookie failure; not delaying bookie audit. Bookies lost now: &quot;</span>
<span class="nc" id="L233">                                     + CollectionUtils.subtract(knownBookies, availableBookies)</span>
<span class="nc" id="L234">                                     +&quot;; All lost bookies: &quot; + bookiesToBeAudited.toString());</span>
<span class="nc bnc" id="L235" title="All 4 branches missed.">                            if (auditTask != null &amp;&amp; auditTask.cancel(false)) {</span>
<span class="nc" id="L236">                                auditTask = null;</span>
<span class="nc" id="L237">                                numDelayedBookieAuditsCancelled.inc();</span>
                            }
<span class="nc" id="L239">                            startAudit(false);</span>
<span class="nc" id="L240">                            bookiesToBeAudited.clear();</span>
<span class="nc" id="L241">                            return;</span>
                        }
<span class="nc bnc" id="L243" title="All 2 branches missed.">                        if (auditTask == null) {</span>
                            // if there is no scheduled audit, schedule one
<span class="nc" id="L245">                            auditTask = executor.schedule( new Runnable() {</span>
                                public void run() {
<span class="nc" id="L247">                                    startAudit(false);</span>
<span class="nc" id="L248">                                    auditTask = null;</span>
<span class="nc" id="L249">                                    bookiesToBeAudited.clear();</span>
<span class="nc" id="L250">                                }</span>
                            }, lostBookieRecoveryDelay, TimeUnit.SECONDS);
<span class="nc" id="L252">                            numBookieAuditsDelayed.inc();</span>
<span class="nc" id="L253">                            LOG.info(&quot;Delaying bookie audit by &quot; + lostBookieRecoveryDelay</span>
<span class="nc" id="L254">                                     + &quot;secs for &quot; + bookiesToBeAudited.toString());</span>
                        }
<span class="nc" id="L256">                    } catch (BKException bke) {</span>
<span class="nc" id="L257">                        LOG.error(&quot;Exception getting bookie list&quot;, bke);</span>
<span class="nc" id="L258">                    } catch (InterruptedException ie) {</span>
<span class="nc" id="L259">                        Thread.currentThread().interrupt();</span>
<span class="nc" id="L260">                        LOG.error(&quot;Interrupted while watching available bookies &quot;, ie);</span>
<span class="nc" id="L261">                    } catch (UnavailableException ue) {</span>
<span class="nc" id="L262">                        LOG.error(&quot;Exception while watching available bookies&quot;, ue);</span>
<span class="nc" id="L263">                    }</span>
<span class="nc" id="L264">                }</span>
            });
    }

    synchronized Future&lt;?&gt; submitLostBookieRecoveryDelayChangedEvent() {
<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (executor.isShutdown()) {</span>
<span class="nc" id="L270">            SettableFuture&lt;Void&gt; f = SettableFuture.&lt;Void&gt; create();</span>
<span class="nc" id="L271">            f.setException(new BKAuditException(&quot;Auditor shutting down&quot;));</span>
<span class="nc" id="L272">            return f;</span>
        }
<span class="nc" id="L274">        return executor.submit(new Runnable() {</span>
<span class="nc" id="L275">            int lostBookieRecoveryDelay = -1;</span>
            public void run() {
                try {
<span class="nc" id="L278">                    waitIfLedgerReplicationDisabled();</span>
<span class="nc" id="L279">                    lostBookieRecoveryDelay = Auditor.this.ledgerUnderreplicationManager</span>
<span class="nc" id="L280">                            .getLostBookieRecoveryDelay();</span>
                    // if there is pending auditTask, cancel the task. So that it can be rescheduled
                    // after new lostBookieRecoveryDelay period
<span class="nc bnc" id="L283" title="All 2 branches missed.">                    if (auditTask != null) {</span>
<span class="nc" id="L284">                        LOG.info(&quot;lostBookieRecoveryDelay period has been changed so canceling the pending AuditTask&quot;);</span>
<span class="nc" id="L285">                        auditTask.cancel(false);                        </span>
<span class="nc" id="L286">                        numDelayedBookieAuditsCancelled.inc();</span>
                    }

                    // if lostBookieRecoveryDelay is set to its previous value then consider it as
                    // signal to trigger the Audit immediately.
<span class="nc bnc" id="L291" title="All 2 branches missed.">                    if ((lostBookieRecoveryDelay == 0)</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">                            || (lostBookieRecoveryDelay == lostBookieRecoveryDelayBeforeChange)) {</span>
<span class="nc" id="L293">                        LOG.info(</span>
                                &quot;lostBookieRecoveryDelay has been set to 0 or reset to its previos value, so starting AuditTask. &quot;
                                + &quot;Current lostBookieRecoveryDelay: {}, previous lostBookieRecoveryDelay: {}&quot;,
<span class="nc" id="L296">                                lostBookieRecoveryDelay, lostBookieRecoveryDelayBeforeChange);</span>
<span class="nc" id="L297">                        startAudit(false);</span>
<span class="nc" id="L298">                        auditTask = null;</span>
<span class="nc" id="L299">                        bookiesToBeAudited.clear();                        </span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">                    } else if (auditTask != null) {</span>
<span class="nc" id="L301">                        LOG.info(&quot;lostBookieRecoveryDelay has been set to {}, so rescheduling AuditTask accordingly&quot;,</span>
<span class="nc" id="L302">                                lostBookieRecoveryDelay);</span>
<span class="nc" id="L303">                        auditTask = executor.schedule(new Runnable() {</span>
                            public void run() {
<span class="nc" id="L305">                                startAudit(false);</span>
<span class="nc" id="L306">                                auditTask = null;</span>
<span class="nc" id="L307">                                bookiesToBeAudited.clear();</span>
<span class="nc" id="L308">                            }</span>
                        }, lostBookieRecoveryDelay, TimeUnit.SECONDS);
<span class="nc" id="L310">                        numBookieAuditsDelayed.inc();</span>
                    }                    
<span class="nc" id="L312">                } catch (InterruptedException ie) {</span>
<span class="nc" id="L313">                    Thread.currentThread().interrupt();</span>
<span class="nc" id="L314">                    LOG.error(&quot;Interrupted while for LedgersReplication to be enabled &quot;, ie);</span>
<span class="nc" id="L315">                } catch (UnavailableException ue) {</span>
<span class="nc" id="L316">                    LOG.error(&quot;Exception while reading from ZK&quot;, ue);</span>
                } finally{
<span class="nc bnc" id="L318" title="All 2 branches missed.">                    if (lostBookieRecoveryDelay != -1) {</span>
<span class="nc" id="L319">                        lostBookieRecoveryDelayBeforeChange = lostBookieRecoveryDelay;</span>
                    }
                }
<span class="nc" id="L322">            }</span>
        });
    }

    public void start() {
<span class="nc" id="L327">        LOG.info(&quot;I'm starting as Auditor Bookie. ID: {}&quot;, bookieIdentifier);</span>
        // on startup watching available bookie and based on the
        // available bookies determining the bookie failures.
<span class="nc" id="L330">        synchronized (this) {</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">            if (executor.isShutdown()) {</span>
<span class="nc" id="L332">                return;</span>
            }

<span class="nc" id="L335">            long interval = conf.getAuditorPeriodicCheckInterval();</span>

<span class="nc bnc" id="L337" title="All 2 branches missed.">            if (interval &gt; 0) {</span>
<span class="nc" id="L338">                LOG.info(&quot;Auditor periodic ledger checking enabled&quot;</span>
<span class="nc" id="L339">                         + &quot; 'auditorPeriodicCheckInterval' {} seconds&quot;, interval);</span>
<span class="nc" id="L340">                executor.scheduleAtFixedRate(new Runnable() {</span>
                        public void run() {
                            try {
<span class="nc bnc" id="L343" title="All 2 branches missed.">                                if (!ledgerUnderreplicationManager.isLedgerReplicationEnabled()) {</span>
<span class="nc" id="L344">                                    LOG.info(&quot;Ledger replication disabled, skipping&quot;);</span>
<span class="nc" id="L345">                                    return;</span>
                                }

<span class="nc" id="L348">                                Stopwatch stopwatch = Stopwatch.createStarted();</span>
<span class="nc" id="L349">                                checkAllLedgers();</span>
<span class="nc" id="L350">                                checkAllLedgersTime.registerSuccessfulEvent(stopwatch.stop()</span>
<span class="nc" id="L351">                                                .elapsed(TimeUnit.MILLISECONDS),</span>
                                        TimeUnit.MILLISECONDS);
<span class="nc" id="L353">                            } catch (KeeperException ke) {</span>
<span class="nc" id="L354">                                LOG.error(&quot;Exception while running periodic check&quot;, ke);</span>
<span class="nc" id="L355">                            } catch (InterruptedException ie) {</span>
<span class="nc" id="L356">                                Thread.currentThread().interrupt();</span>
<span class="nc" id="L357">                                LOG.error(&quot;Interrupted while running periodic check&quot;, ie);</span>
<span class="nc" id="L358">                            } catch (BKAuditException bkae) {</span>
<span class="nc" id="L359">                                LOG.error(&quot;Exception while running periodic check&quot;, bkae);</span>
<span class="nc" id="L360">                            } catch (BKException bke) {</span>
<span class="nc" id="L361">                                LOG.error(&quot;Exception running periodic check&quot;, bke);</span>
<span class="nc" id="L362">                            } catch (IOException ioe) {</span>
<span class="nc" id="L363">                                LOG.error(&quot;I/O exception running periodic check&quot;, ioe);</span>
<span class="nc" id="L364">                            } catch (ReplicationException.UnavailableException ue) {</span>
<span class="nc" id="L365">                                LOG.error(&quot;Underreplication manager unavailable &quot;</span>
                                          +&quot;running periodic check&quot;, ue);
<span class="nc" id="L367">                            }</span>
<span class="nc" id="L368">                        }</span>
                    }, interval, interval, TimeUnit.SECONDS);
            } else {
<span class="nc" id="L371">                LOG.info(&quot;Periodic checking disabled&quot;);</span>
            }
            try {
<span class="nc" id="L374">                watchBookieChanges();</span>
<span class="nc" id="L375">                knownBookies = getAvailableBookies();</span>
<span class="nc" id="L376">            } catch (BKException bke) {</span>
<span class="nc" id="L377">                LOG.error(&quot;Couldn't get bookie list, exiting&quot;, bke);</span>
<span class="nc" id="L378">                submitShutdownTask();</span>
<span class="nc" id="L379">            }</span>
            
            try {
<span class="nc" id="L382">                this.ledgerUnderreplicationManager</span>
<span class="nc" id="L383">                        .notifyLostBookieRecoveryDelayChanged(new LostBookieRecoveryDelayChangedCb());</span>
<span class="nc" id="L384">            } catch (UnavailableException ue) {</span>
<span class="nc" id="L385">                LOG.error(&quot;Exception while registering for LostBookieRecoveryDelay change notification&quot;, ue);</span>
<span class="nc" id="L386">                submitShutdownTask();</span>
<span class="nc" id="L387">            }</span>

<span class="nc" id="L389">            long bookieCheckInterval = conf.getAuditorPeriodicBookieCheckInterval();</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">            if (bookieCheckInterval == 0) {</span>
<span class="nc" id="L391">                LOG.info(&quot;Auditor periodic bookie checking disabled, running once check now anyhow&quot;);</span>
<span class="nc" id="L392">                executor.submit(BOOKIE_CHECK);</span>
            } else {
<span class="nc" id="L394">                LOG.info(&quot;Auditor periodic bookie checking enabled&quot;</span>
<span class="nc" id="L395">                         + &quot; 'auditorPeriodicBookieCheckInterval' {} seconds&quot;, bookieCheckInterval);</span>
<span class="nc" id="L396">                executor.scheduleAtFixedRate(BOOKIE_CHECK, 0, bookieCheckInterval, TimeUnit.SECONDS);</span>
            }
<span class="nc" id="L398">        }</span>
<span class="nc" id="L399">    }</span>

<span class="nc" id="L401">    private class LostBookieRecoveryDelayChangedCb implements GenericCallback&lt;Void&gt; {</span>
        @Override
        public void operationComplete(int rc, Void result) {
            try {
<span class="nc" id="L405">                Auditor.this.ledgerUnderreplicationManager</span>
<span class="nc" id="L406">                        .notifyLostBookieRecoveryDelayChanged(LostBookieRecoveryDelayChangedCb.this);</span>
<span class="nc" id="L407">            } catch (UnavailableException ae) {</span>
<span class="nc" id="L408">                LOG.error(&quot;Exception while registering for a LostBookieRecoveryDelay notification&quot;, ae);</span>
<span class="nc" id="L409">            }</span>
<span class="nc" id="L410">            Auditor.this.submitLostBookieRecoveryDelayChangedEvent();</span>
<span class="nc" id="L411">        }</span>
    }
    
    private void waitIfLedgerReplicationDisabled() throws UnavailableException,
            InterruptedException {
<span class="nc" id="L416">        ReplicationEnableCb cb = new ReplicationEnableCb();</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">        if (!ledgerUnderreplicationManager.isLedgerReplicationEnabled()) {</span>
<span class="nc" id="L418">            ledgerUnderreplicationManager.notifyLedgerReplicationEnabled(cb);</span>
<span class="nc" id="L419">            cb.await();</span>
        }
<span class="nc" id="L421">    }</span>

    private List&lt;String&gt; getAvailableBookies() throws BKException {
        // Get the available bookies
<span class="nc" id="L425">        Collection&lt;BookieSocketAddress&gt; availableBkAddresses = admin.getAvailableBookies();</span>
<span class="nc" id="L426">        Collection&lt;BookieSocketAddress&gt; readOnlyBkAddresses = admin.getReadOnlyBookies();</span>
<span class="nc" id="L427">        availableBkAddresses.addAll(readOnlyBkAddresses);</span>

<span class="nc" id="L429">        List&lt;String&gt; availableBookies = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">        for (BookieSocketAddress addr : availableBkAddresses) {</span>
<span class="nc" id="L431">            availableBookies.add(addr.toString());</span>
<span class="nc" id="L432">        }</span>
<span class="nc" id="L433">        return availableBookies;</span>
    }

    private void watchBookieChanges() throws BKException {
<span class="nc" id="L437">        admin.watchWritableBookiesChanged(bookies -&gt; submitAuditTask());</span>
<span class="nc" id="L438">        admin.watchReadOnlyBookiesChanged(bookies -&gt; submitAuditTask());</span>
<span class="nc" id="L439">    }</span>

    /**
     * Start running the actual audit task
     *
     * @param shutDownTask
     *      A boolean that indicates whether or not to schedule shutdown task on any failure
     */
    private void startAudit(boolean shutDownTask) {
        try {
<span class="nc" id="L449">            auditBookies();</span>
<span class="nc" id="L450">            shutDownTask = false;</span>
<span class="nc" id="L451">        } catch (BKException bke) {</span>
<span class="nc" id="L452">            LOG.error(&quot;Exception getting bookie list&quot;, bke);</span>
<span class="nc" id="L453">        } catch (InterruptedException ie) {</span>
<span class="nc" id="L454">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L455">            LOG.error(&quot;Interrupted while watching available bookies &quot;, ie);</span>
<span class="nc" id="L456">        } catch (BKAuditException bke) {</span>
<span class="nc" id="L457">            LOG.error(&quot;Exception while watching available bookies&quot;, bke);</span>
<span class="nc" id="L458">        } catch (KeeperException ke) {</span>
<span class="nc" id="L459">            LOG.error(&quot;Exception reading bookie list&quot;, ke);</span>
<span class="nc" id="L460">        }</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">        if (shutDownTask) {</span>
<span class="nc" id="L462">            submitShutdownTask();</span>
        }
<span class="nc" id="L464">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    private void auditBookies()
            throws BKAuditException, KeeperException,
            InterruptedException, BKException {
        try {
<span class="nc" id="L471">            waitIfLedgerReplicationDisabled();</span>
<span class="nc" id="L472">        } catch (UnavailableException ue) {</span>
<span class="nc" id="L473">            LOG.error(&quot;Underreplication unavailable, skipping audit.&quot;</span>
                      + &quot;Will retry after a period&quot;);
<span class="nc" id="L475">            return;</span>
<span class="nc" id="L476">        }</span>

<span class="nc" id="L478">        Stopwatch stopwatch = Stopwatch.createStarted();</span>
        // put exit cases here
<span class="nc" id="L480">        Map&lt;String, Set&lt;Long&gt;&gt; ledgerDetails = generateBookie2LedgersIndex();</span>
        try {
<span class="nc bnc" id="L482" title="All 2 branches missed.">            if (!ledgerUnderreplicationManager.isLedgerReplicationEnabled()) {</span>
                // has been disabled while we were generating the index
                // discard this run, and schedule a new one
<span class="nc" id="L485">                executor.submit(BOOKIE_CHECK);</span>
<span class="nc" id="L486">                return;</span>
            }
<span class="nc" id="L488">        } catch (UnavailableException ue) {</span>
<span class="nc" id="L489">            LOG.error(&quot;Underreplication unavailable, skipping audit.&quot;</span>
                      + &quot;Will retry after a period&quot;);
<span class="nc" id="L491">            return;</span>
<span class="nc" id="L492">        }</span>

<span class="nc" id="L494">        List&lt;String&gt; availableBookies = getAvailableBookies();</span>
        // find lost bookies
<span class="nc" id="L496">        Set&lt;String&gt; knownBookies = ledgerDetails.keySet();</span>
<span class="nc" id="L497">        Collection&lt;String&gt; lostBookies = CollectionUtils.subtract(knownBookies,</span>
                availableBookies);

<span class="nc" id="L500">        bookieToLedgersMapCreationTime.registerSuccessfulEvent(stopwatch.elapsed(TimeUnit.MILLISECONDS),</span>
                TimeUnit.MILLISECONDS);
<span class="nc bnc" id="L502" title="All 2 branches missed.">        if (lostBookies.size() &gt; 0) {</span>
<span class="nc" id="L503">            handleLostBookies(lostBookies, ledgerDetails);</span>
<span class="nc" id="L504">            uRLPublishTimeForLostBookies.registerSuccessfulEvent(stopwatch.stop().elapsed(TimeUnit.MILLISECONDS),</span>
                    TimeUnit.MILLISECONDS);
        }

<span class="nc" id="L508">    }</span>

    private Map&lt;String, Set&lt;Long&gt;&gt; generateBookie2LedgersIndex()
            throws BKAuditException {
<span class="nc" id="L512">        return bookieLedgerIndexer.getBookieToLedgerIndex();</span>
    }

    private void handleLostBookies(Collection&lt;String&gt; lostBookies,
            Map&lt;String, Set&lt;Long&gt;&gt; ledgerDetails) throws BKAuditException {
<span class="nc" id="L517">        LOG.info(&quot;Following are the failed bookies: &quot; + lostBookies</span>
                + &quot; and searching its ledgers for re-replication&quot;);

<span class="nc bnc" id="L520" title="All 2 branches missed.">        for (String bookieIP : lostBookies) {</span>
            // identify all the ledgers in bookieIP and publishing these ledgers
            // as under-replicated.
<span class="nc" id="L523">            publishSuspectedLedgers(bookieIP, ledgerDetails.get(bookieIP));</span>
<span class="nc" id="L524">        }</span>
<span class="nc" id="L525">    }</span>

    private void publishSuspectedLedgers(String bookieIP, Set&lt;Long&gt; ledgers)
            throws BKAuditException {
<span class="nc bnc" id="L529" title="All 4 branches missed.">        if (null == ledgers || ledgers.size() == 0) {</span>
            // there is no ledgers available for this bookie and just
            // ignoring the bookie failures
<span class="nc" id="L532">            LOG.info(&quot;There is no ledgers for the failed bookie: &quot; + bookieIP);</span>
<span class="nc" id="L533">            return;</span>
        }
<span class="nc" id="L535">        LOG.info(&quot;Following ledgers: &quot; + ledgers + &quot; of bookie: &quot; + bookieIP</span>
                + &quot; are identified as underreplicated&quot;);
<span class="nc" id="L537">        numUnderReplicatedLedger.registerSuccessfulValue(ledgers.size());</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">        for (Long ledgerId : ledgers) {</span>
            try {
<span class="nc" id="L540">                ledgerUnderreplicationManager.markLedgerUnderreplicated(</span>
<span class="nc" id="L541">                        ledgerId, bookieIP);</span>
<span class="nc" id="L542">            } catch (UnavailableException ue) {</span>
<span class="nc" id="L543">                throw new BKAuditException(</span>
                        &quot;Failed to publish underreplicated ledger: &quot; + ledgerId
                                + &quot; of bookie: &quot; + bookieIP, ue);
<span class="nc" id="L546">            }</span>
<span class="nc" id="L547">        }</span>
<span class="nc" id="L548">    }</span>

    /**
     * Process the result returned from checking a ledger
     */
    private class ProcessLostFragmentsCb implements GenericCallback&lt;Set&lt;LedgerFragment&gt;&gt; {
        final LedgerHandle lh;
        final AsyncCallback.VoidCallback callback;

<span class="nc" id="L557">        ProcessLostFragmentsCb(LedgerHandle lh, AsyncCallback.VoidCallback callback) {</span>
<span class="nc" id="L558">            this.lh = lh;</span>
<span class="nc" id="L559">            this.callback = callback;</span>
<span class="nc" id="L560">        }</span>

        public void operationComplete(int rc, Set&lt;LedgerFragment&gt; fragments) {
            try {
<span class="nc bnc" id="L564" title="All 2 branches missed.">                if (rc == BKException.Code.OK) {</span>
<span class="nc" id="L565">                    Set&lt;BookieSocketAddress&gt; bookies = Sets.newHashSet();</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">                    for (LedgerFragment f : fragments) {</span>
<span class="nc" id="L567">                        bookies.addAll(f.getAddresses());</span>
<span class="nc" id="L568">                    }</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">                    for (BookieSocketAddress bookie : bookies) {</span>
<span class="nc" id="L570">                        publishSuspectedLedgers(bookie.toString(), Sets.newHashSet(lh.getId()));</span>
<span class="nc" id="L571">                    }</span>
                }
<span class="nc" id="L573">                lh.close();</span>
<span class="nc" id="L574">            } catch (BKException bke) {</span>
<span class="nc" id="L575">                LOG.error(&quot;Error closing lh&quot;, bke);</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">                if (rc == BKException.Code.OK) {</span>
<span class="nc" id="L577">                    rc = BKException.Code.ReplicationException;</span>
                }
<span class="nc" id="L579">            } catch (InterruptedException ie) {</span>
<span class="nc" id="L580">                LOG.error(&quot;Interrupted publishing suspected ledger&quot;, ie);</span>
<span class="nc" id="L581">                Thread.currentThread().interrupt();</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">                if (rc == BKException.Code.OK) {</span>
<span class="nc" id="L583">                    rc = BKException.Code.InterruptedException;</span>
                }
<span class="nc" id="L585">            } catch (BKAuditException bkae) {</span>
<span class="nc" id="L586">                LOG.error(&quot;Auditor exception publishing suspected ledger&quot;, bkae);</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">                if (rc == BKException.Code.OK) {</span>
<span class="nc" id="L588">                    rc = BKException.Code.ReplicationException;</span>
                }
<span class="nc" id="L590">            }</span>

<span class="nc" id="L592">            callback.processResult(rc, null, null);</span>
<span class="nc" id="L593">        }</span>
    }

    /**
     * List all the ledgers and check them individually. This should not
     * be run very often.
     */
    void checkAllLedgers() throws BKAuditException, BKException,
            IOException, InterruptedException, KeeperException {
<span class="nc" id="L602">        ZooKeeper newzk = ZooKeeperClient.newBuilder()</span>
<span class="nc" id="L603">                .connectString(conf.getZkServers())</span>
<span class="nc" id="L604">                .sessionTimeoutMs(conf.getZkTimeout())</span>
<span class="nc" id="L605">                .build();</span>

<span class="nc" id="L607">        final BookKeeper client = new BookKeeper(new ClientConfiguration(conf),</span>
                                                 newzk);
<span class="nc" id="L609">        final BookKeeperAdmin admin = new BookKeeperAdmin(client, statsLogger);</span>

        try {
<span class="nc" id="L612">            final LedgerChecker checker = new LedgerChecker(client);</span>

<span class="nc" id="L614">            final AtomicInteger returnCode = new AtomicInteger(BKException.Code.OK);</span>
<span class="nc" id="L615">            final CountDownLatch processDone = new CountDownLatch(1);</span>

<span class="nc" id="L617">            Processor&lt;Long&gt; checkLedgersProcessor = new Processor&lt;Long&gt;() {</span>
                @Override
                public void process(final Long ledgerId,
                                    final AsyncCallback.VoidCallback callback) {
                    try {
<span class="nc bnc" id="L622" title="All 2 branches missed.">                        if (!ledgerUnderreplicationManager.isLedgerReplicationEnabled()) {</span>
<span class="nc" id="L623">                            LOG.info(&quot;Ledger rereplication has been disabled, aborting periodic check&quot;);</span>
<span class="nc" id="L624">                            processDone.countDown();</span>
<span class="nc" id="L625">                            return;</span>
                        }
<span class="nc" id="L627">                    } catch (ReplicationException.UnavailableException ue) {</span>
<span class="nc" id="L628">                        LOG.error(&quot;Underreplication manager unavailable &quot;</span>
                                  +&quot;running periodic check&quot;, ue);
<span class="nc" id="L630">                        processDone.countDown();</span>
<span class="nc" id="L631">                        return;</span>
<span class="nc" id="L632">                    }</span>

<span class="nc" id="L634">                    LedgerHandle lh = null;</span>
                    try {
<span class="nc" id="L636">                        lh = admin.openLedgerNoRecovery(ledgerId);</span>
<span class="nc" id="L637">                        checker.checkLedger(lh, new ProcessLostFragmentsCb(lh, callback));</span>
                        // we collect the following stats to get a measure of the
                        // distribution of a single ledger within the bk cluster
                        // the higher the number of fragments/bookies, the more distributed it is
<span class="nc" id="L641">                        numFragmentsPerLedger.registerSuccessfulValue(lh.getNumFragments());</span>
<span class="nc" id="L642">                        numBookiesPerLedger.registerSuccessfulValue(lh.getNumBookies());</span>
<span class="nc" id="L643">                        numLedgersChecked.inc();</span>
<span class="nc" id="L644">                    } catch (BKException.BKNoSuchLedgerExistsException bknsle) {</span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">                        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L646">                            LOG.debug(&quot;Ledger was deleted before we could check it&quot;, bknsle);</span>
                        }
<span class="nc" id="L648">                        callback.processResult(BKException.Code.OK,</span>
                                               null, null);
<span class="nc" id="L650">                        return;</span>
<span class="nc" id="L651">                    } catch (BKException bke) {</span>
<span class="nc" id="L652">                        LOG.error(&quot;Couldn't open ledger &quot; + ledgerId, bke);</span>
<span class="nc" id="L653">                        callback.processResult(BKException.Code.BookieHandleNotAvailableException,</span>
                                         null, null);
<span class="nc" id="L655">                        return;</span>
<span class="nc" id="L656">                    } catch (InterruptedException ie) {</span>
<span class="nc" id="L657">                        LOG.error(&quot;Interrupted opening ledger&quot;, ie);</span>
<span class="nc" id="L658">                        Thread.currentThread().interrupt();</span>
<span class="nc" id="L659">                        callback.processResult(BKException.Code.InterruptedException, null, null);</span>
<span class="nc" id="L660">                        return;</span>
                    } finally {
<span class="nc bnc" id="L662" title="All 2 branches missed.">                        if (lh != null) {</span>
                            try {
<span class="nc" id="L664">                                lh.close();</span>
<span class="nc" id="L665">                            } catch (BKException bke) {</span>
<span class="nc" id="L666">                                LOG.warn(&quot;Couldn't close ledger &quot; + ledgerId, bke);</span>
<span class="nc" id="L667">                            } catch (InterruptedException ie) {</span>
<span class="nc" id="L668">                                LOG.warn(&quot;Interrupted closing ledger &quot; + ledgerId, ie);</span>
<span class="nc" id="L669">                                Thread.currentThread().interrupt();</span>
<span class="nc" id="L670">                            }</span>
                        }
                    }
<span class="nc" id="L673">                }</span>
            };

<span class="nc" id="L676">            ledgerManager.asyncProcessLedgers(checkLedgersProcessor,</span>
<span class="nc" id="L677">                    new AsyncCallback.VoidCallback() {</span>
                        @Override
                        public void processResult(int rc, String s, Object obj) {
<span class="nc" id="L680">                            returnCode.set(rc);</span>
<span class="nc" id="L681">                            processDone.countDown();</span>
<span class="nc" id="L682">                        }</span>
                    }, null, BKException.Code.OK, BKException.Code.ReadException);
            try {
<span class="nc" id="L685">                processDone.await();</span>
<span class="nc" id="L686">            } catch (InterruptedException e) {</span>
<span class="nc" id="L687">                Thread.currentThread().interrupt();</span>
<span class="nc" id="L688">                throw new BKAuditException(</span>
                        &quot;Exception while checking ledgers&quot;, e);
<span class="nc" id="L690">            }</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">            if (returnCode.get() != BKException.Code.OK) {</span>
<span class="nc" id="L692">                throw BKException.create(returnCode.get());</span>
            }
        } finally {
<span class="nc" id="L695">            admin.close();</span>
<span class="nc" id="L696">            client.close();</span>
<span class="nc" id="L697">            newzk.close();</span>
        }
<span class="nc" id="L699">    }</span>

    /**
     * Shutdown the auditor
     */
    public void shutdown() {
<span class="nc" id="L705">        LOG.info(&quot;Shutting down auditor&quot;);</span>
<span class="nc" id="L706">        submitShutdownTask();</span>

        try {
<span class="nc bnc" id="L709" title="All 2 branches missed.">            while (!executor.awaitTermination(30, TimeUnit.SECONDS)) {</span>
<span class="nc" id="L710">                LOG.warn(&quot;Executor not shutting down, interrupting&quot;);</span>
<span class="nc" id="L711">                executor.shutdownNow();</span>
            }
<span class="nc" id="L713">            admin.close();</span>
<span class="nc" id="L714">            bkc.close();</span>
<span class="nc" id="L715">        } catch (InterruptedException ie) {</span>
<span class="nc" id="L716">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L717">            LOG.warn(&quot;Interrupted while shutting down auditor bookie&quot;, ie);</span>
<span class="nc" id="L718">        } catch (BKException bke) {</span>
<span class="nc" id="L719">            LOG.warn(&quot;Exception while shutting down auditor bookie&quot;, bke);</span>
<span class="nc" id="L720">        }</span>
<span class="nc" id="L721">    }</span>

    /**
     * Return true if auditor is running otherwise return false
     *
     * @return auditor status
     */
    public boolean isRunning() {
<span class="nc bnc" id="L729" title="All 2 branches missed.">        return !executor.isShutdown();</span>
    }

<span class="nc" id="L732">    private final Runnable BOOKIE_CHECK = new Runnable() {</span>
            public void run() {
<span class="nc bnc" id="L734" title="All 2 branches missed.">                if (auditTask == null) {</span>
<span class="nc" id="L735">                    startAudit(true);</span>
                } else {
                    // if due to a lost bookie an audit task was scheduled,
                    // let us not run this periodic bookie check now, if we
                    // went ahead, we'll report under replication and the user
                    // wanted to avoid that(with lostBookieRecoveryDelay option)
<span class="nc" id="L741">                    LOG.info(&quot;Audit already scheduled; skipping periodic bookie check&quot;);</span>
                }
<span class="nc" id="L743">            }</span>
        };

    int getLostBookieRecoveryDelayBeforeChange() {
<span class="nc" id="L747">        return lostBookieRecoveryDelayBeforeChange;</span>
    }

    Future&lt;?&gt; getAuditTask() {
<span class="nc" id="L751">        return auditTask;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>