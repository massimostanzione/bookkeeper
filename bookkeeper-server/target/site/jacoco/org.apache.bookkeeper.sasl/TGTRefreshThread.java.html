<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TGTRefreshThread.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.sasl</a> &gt; <span class="el_source">TGTRefreshThread.java</span></div><h1>TGTRefreshThread.java</h1><pre class="source lang-java linenums">/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.bookkeeper.sasl;

import java.util.Date;
import java.util.Random;
import java.util.Set;
import javax.security.auth.kerberos.KerberosPrincipal;
import javax.security.auth.kerberos.KerberosTicket;
import javax.security.auth.login.LoginContext;
import javax.security.auth.login.LoginException;
import org.apache.zookeeper.Login;
import org.apache.zookeeper.Shell;
import org.apache.zookeeper.common.Time;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

// copied from Apache ZooKeeper TGT refresh logic
class TGTRefreshThread extends Thread {

<span class="nc" id="L39">    private static final Logger LOG = LoggerFactory.getLogger(TGTRefreshThread.class);</span>
<span class="nc" id="L40">    private static final Random rng = new Random();</span>

    private long lastLogin;
    private final JAASCredentialsContainer container;

    public long getLastLogin() {
<span class="nc" id="L46">        return lastLogin;</span>
    }

    public void setLastLogin(long lastLogin) {
<span class="nc" id="L50">        this.lastLogin = lastLogin;</span>
<span class="nc" id="L51">    }</span>

<span class="nc" id="L53">    public TGTRefreshThread(JAASCredentialsContainer container) {</span>
<span class="nc" id="L54">        this.container = container;</span>
        // Initialize 'lastLogin' to do a login at first time
<span class="nc" id="L56">        this.lastLogin = System.currentTimeMillis() - MIN_TIME_BEFORE_RELOGIN;</span>
<span class="nc" id="L57">        setDaemon(true);</span>
<span class="nc" id="L58">        setName(&quot;bookkeeper-tgt-refresh-thread&quot;);</span>
<span class="nc" id="L59">    } // Initialize 'lastLogin' to do a login at first time</span>

    private synchronized KerberosTicket getTGT() {
<span class="nc" id="L62">        Set&lt;KerberosTicket&gt; tickets = container.getSubject().getPrivateCredentials(KerberosTicket.class);</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">        for (KerberosTicket ticket : tickets) {</span>
<span class="nc" id="L64">            KerberosPrincipal server = ticket.getServer();</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">            if (server.getName().equals(&quot;krbtgt/&quot; + server.getRealm() + &quot;@&quot; + server.getRealm())) {</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L67">                    LOG.debug(&quot;Client principal is \&quot;&quot; + ticket.getClient().getName() + &quot;\&quot;.&quot;);</span>
<span class="nc" id="L68">                    LOG.debug(&quot;Server principal is \&quot;&quot; + ticket.getServer().getName() + &quot;\&quot;.&quot;);</span>
                }
<span class="nc" id="L70">                return ticket;</span>
            }
<span class="nc" id="L72">        }</span>
<span class="nc" id="L73">        return null;</span>
    }
    // LoginThread will sleep until 80% of time from last refresh to
    // ticket's expiry has been reached, at which time it will wake
    // and try to renew the ticket.
    private static final float TICKET_RENEW_WINDOW = 0.80f;
    /**
     * Percentage of random jitter added to the renewal time
     */
    private static final float TICKET_RENEW_JITTER = 0.05f;
    // Regardless of TICKET_RENEW_WINDOW setting above and the ticket expiry time,
    // thread will not sleep between refresh attempts any less than 1 minute (60*1000 milliseconds = 1 minute).
    // Change the '1' to e.g. 5, to change this to 5 minutes.
    private static final long MIN_TIME_BEFORE_RELOGIN = 1 * 60 * 1000L;

    private long getRefreshTime(KerberosTicket tgt) {
<span class="nc" id="L89">        long start = tgt.getStartTime().getTime();</span>
<span class="nc" id="L90">        long expires = tgt.getEndTime().getTime();</span>
<span class="nc" id="L91">        LOG.info(&quot;TGT valid starting at:        {}&quot;, tgt.getStartTime().toString());</span>
<span class="nc" id="L92">        LOG.info(&quot;TGT expires:                  {}&quot;, tgt.getEndTime().toString());</span>
<span class="nc" id="L93">        long proposedRefresh = start</span>
<span class="nc" id="L94">            + (long) ((expires - start) * (TICKET_RENEW_WINDOW + (TICKET_RENEW_JITTER * rng.nextDouble())));</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">        if (proposedRefresh &gt; expires) {</span>
            // proposedRefresh is too far in the future: it's after ticket expires: simply return now.
<span class="nc" id="L97">            return Time.currentWallTime();</span>
        } else {
<span class="nc" id="L99">            return proposedRefresh;</span>
        }
    }

    @Override
    public void run() {
<span class="nc" id="L105">        LOG.info(&quot;TGT refresh thread started.&quot;);</span>
        while (true) {
            // renewal thread's main loop. if it exits from here, thread will exit.
<span class="nc" id="L108">            KerberosTicket tgt = getTGT();</span>
<span class="nc" id="L109">            long now = Time.currentWallTime();</span>
            long nextRefresh;
            Date nextRefreshDate;
<span class="nc bnc" id="L112" title="All 2 branches missed.">            if (tgt == null) {</span>
<span class="nc" id="L113">                nextRefresh = now + MIN_TIME_BEFORE_RELOGIN;</span>
<span class="nc" id="L114">                nextRefreshDate = new Date(nextRefresh);</span>
<span class="nc" id="L115">                LOG.warn(&quot;No TGT found: will try again at {}&quot;, nextRefreshDate);</span>
            } else {
<span class="nc" id="L117">                nextRefresh = getRefreshTime(tgt);</span>
<span class="nc" id="L118">                long expiry = tgt.getEndTime().getTime();</span>
<span class="nc" id="L119">                Date expiryDate = new Date(expiry);</span>
<span class="nc bnc" id="L120" title="All 4 branches missed.">                if ((container.isUsingTicketCache()) &amp;&amp; (tgt.getEndTime().equals(tgt.getRenewTill()))) {</span>
<span class="nc" id="L121">                    Object[] logPayload = {expiryDate, container.getPrincipal(), container.getPrincipal()};</span>
<span class="nc" id="L122">                    LOG.error(&quot;The TGT cannot be renewed beyond the next expiry date: {}.&quot;</span>
                        + &quot;This process will not be able to authenticate new SASL connections after that &quot;
                        + &quot;time (for example, it will not be authenticate a new connection with a Bookie &quot;
                        + &quot;).  Ask your system administrator to either increase the &quot;
                        + &quot;'renew until' time by doing : 'modprinc -maxrenewlife {}' within &quot;
                        + &quot;kadmin, or instead, to generate a keytab for {}. Because the TGT's &quot;
                        + &quot;expiry cannot be further extended by refreshing, exiting refresh thread now.&quot;, logPayload);
<span class="nc" id="L129">                    return;</span>
                }
                // determine how long to sleep from looking at ticket's expiry.
                // We should not allow the ticket to expire, but we should take into consideration
                // MIN_TIME_BEFORE_RELOGIN. Will not sleep less than MIN_TIME_BEFORE_RELOGIN, unless doing so
                // would cause ticket expiration.
<span class="nc bnc" id="L135" title="All 4 branches missed.">                if ((nextRefresh &gt; expiry) || ((now + MIN_TIME_BEFORE_RELOGIN) &gt; expiry)) {</span>
                    // expiry is before next scheduled refresh).
<span class="nc" id="L137">                    nextRefresh = now;</span>
                } else {
<span class="nc bnc" id="L139" title="All 2 branches missed.">                    if (nextRefresh &lt; (now + MIN_TIME_BEFORE_RELOGIN)) {</span>
                        // next scheduled refresh is sooner than (now + MIN_TIME_BEFORE_LOGIN).
<span class="nc" id="L141">                        Date until = new Date(nextRefresh);</span>
<span class="nc" id="L142">                        Date newuntil = new Date(now + MIN_TIME_BEFORE_RELOGIN);</span>
<span class="nc" id="L143">                        Object[] logPayload = {until, newuntil, MIN_TIME_BEFORE_RELOGIN / 1000};</span>
<span class="nc" id="L144">                        LOG.warn(&quot;TGT refresh thread time adjusted from : {} to : {} since &quot;</span>
                            + &quot;the former is sooner than the minimum refresh interval (&quot;
                            + &quot;{} seconds) from now.&quot;, logPayload);
                    }
<span class="nc" id="L148">                    nextRefresh = Math.max(nextRefresh, now + MIN_TIME_BEFORE_RELOGIN);</span>
                }
<span class="nc" id="L150">                nextRefreshDate = new Date(nextRefresh);</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">                if (nextRefresh &gt; expiry) {</span>
<span class="nc" id="L152">                    Object[] logPayload = {nextRefreshDate, expiryDate};</span>
<span class="nc" id="L153">                    LOG.error(&quot;next refresh: {} is later than expiry {}.&quot; + &quot; This may indicate a clock skew problem.&quot;</span>
                        + &quot;Check that this host and the KDC's &quot; + &quot;hosts' clocks are in sync. Exiting refresh thread.&quot;,
                        logPayload);
<span class="nc" id="L156">                    return;</span>
                }
            }
<span class="nc bnc" id="L159" title="All 2 branches missed.">            if (now == nextRefresh) {</span>
<span class="nc" id="L160">                LOG.info(&quot;refreshing now because expiry is before next scheduled refresh time.&quot;);</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">            } else if (now &lt; nextRefresh) {</span>
<span class="nc" id="L162">                Date until = new Date(nextRefresh);</span>
<span class="nc" id="L163">                LOG.info(&quot;TGT refresh sleeping until: {}&quot;, until.toString());</span>
                try {
<span class="nc" id="L165">                    Thread.sleep(nextRefresh - now);</span>
<span class="nc" id="L166">                } catch (InterruptedException ie) {</span>
<span class="nc" id="L167">                    LOG.warn(&quot;TGT renewal thread has been interrupted and will exit.&quot;);</span>
<span class="nc" id="L168">                    break;</span>
<span class="nc" id="L169">                }</span>
<span class="nc" id="L170">            } else {</span>
<span class="nc" id="L171">                LOG.error(&quot;nextRefresh:{} is in the past: exiting refresh thread. Check&quot;</span>
                    + &quot; clock sync between this host and KDC - (KDC's clock is likely ahead of this host).&quot;
                    + &quot; Manual intervention will be required for this client to successfully authenticate.&quot;
                    + &quot; Exiting refresh thread.&quot;, nextRefreshDate);
<span class="nc" id="L175">                break;</span>
            }
<span class="nc bnc" id="L177" title="All 2 branches missed.">            if (container.isUsingTicketCache()) {</span>
<span class="nc" id="L178">                String cmd = container.getConfiguration().getString(SaslConstants.KINIT_COMMAND, SaslConstants.KINIT_COMMAND_DEFAULT);</span>
<span class="nc" id="L179">                String kinitArgs = &quot;-R&quot;;</span>
<span class="nc" id="L180">                int retry = 1;</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">                while (retry &gt;= 0) {</span>
                    try {
<span class="nc bnc" id="L183" title="All 2 branches missed.">                        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L184">                            LOG.debug(&quot;running ticket cache refresh command: {} {}&quot;, cmd, kinitArgs);</span>
                        }
<span class="nc" id="L186">                        Shell.execCommand(cmd, kinitArgs);</span>
<span class="nc" id="L187">                        break;</span>
<span class="nc" id="L188">                    } catch (Exception e) {</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">                        if (retry &gt; 0) {</span>
<span class="nc" id="L190">                            --retry;</span>
                            // sleep for 10 seconds
                            try {
<span class="nc" id="L193">                                Thread.sleep(10 * 1000);</span>
<span class="nc" id="L194">                            } catch (InterruptedException ie) {</span>
<span class="nc" id="L195">                                LOG.error(&quot;Interrupted while renewing TGT, exiting Login thread&quot;);</span>
<span class="nc" id="L196">                                return;</span>
<span class="nc" id="L197">                            }</span>
                        } else {
<span class="nc" id="L199">                            Object[] logPayload = {cmd, kinitArgs, e.toString(), e};</span>
<span class="nc" id="L200">                            LOG.warn(&quot;Could not renew TGT due to problem running shell command: '{}&quot;</span>
                                + &quot; {}'; exception was:{}. Exiting refresh thread.&quot;, logPayload);
<span class="nc" id="L202">                            return;</span>
                        }
<span class="nc" id="L204">                    }</span>
                }
            }
            try {
<span class="nc" id="L208">                int retry = 1;</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">                while (retry &gt;= 0) {</span>
                    try {
<span class="nc" id="L211">                        reLogin();</span>
<span class="nc" id="L212">                        break;</span>
<span class="nc" id="L213">                    } catch (LoginException le) {</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">                        if (retry &gt; 0) {</span>
<span class="nc" id="L215">                            --retry;</span>
                            // sleep for 10 seconds.
                            try {
<span class="nc" id="L218">                                Thread.sleep(10 * 1000);</span>
<span class="nc" id="L219">                            } catch (InterruptedException e) {</span>
<span class="nc" id="L220">                                LOG.error(&quot;Interrupted during login retry after LoginException:&quot;, le);</span>
<span class="nc" id="L221">                                throw le;</span>
<span class="nc" id="L222">                            }</span>
                        } else {
<span class="nc" id="L224">                            LOG.error(&quot;Could not refresh TGT for principal: {}.&quot;, container.getPrincipal(), le);</span>
                        }
<span class="nc" id="L226">                    }</span>
                }
<span class="nc" id="L228">            } catch (LoginException le) {</span>
<span class="nc" id="L229">                LOG.error(&quot;Failed to refresh TGT: refresh thread exiting now.&quot;, le);</span>
<span class="nc" id="L230">                break;</span>
<span class="nc" id="L231">            }</span>
<span class="nc" id="L232">        }</span>
<span class="nc" id="L233">    }</span>

    /**
     * Re-login a principal. This method assumes that {@link #login(String)} has happened already.
     *
     * @throws javax.security.auth.login.LoginException on a failure
     */
    // c.f. HADOOP-6559
    private synchronized void reLogin() throws LoginException {
<span class="nc" id="L242">        LoginContext login = container.getLogin();</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">        if (login == null) {</span>
<span class="nc" id="L244">            throw new LoginException(&quot;login must be done first&quot;);</span>
        }
<span class="nc bnc" id="L246" title="All 2 branches missed.">        if (!hasSufficientTimeElapsed()) {</span>
<span class="nc" id="L247">            return;</span>
        }
<span class="nc" id="L249">        LOG.info(&quot;Initiating logout for {}&quot;, container.getPrincipal());</span>
<span class="nc" id="L250">        synchronized (Login.class) {</span>
            //clear up the kerberos state. But the tokens are not cleared! As per
            //the Java kerberos login module code, only the kerberos credentials
            //are cleared
<span class="nc" id="L254">            login.logout();</span>
            //login and also update the subject field of this instance to
            //have the new credentials (pass it to the LoginContext constructor)
<span class="nc" id="L257">            login = new LoginContext(container.getLoginContextName(), container.getSubject());</span>
<span class="nc" id="L258">            LOG.info(&quot;Initiating re-login for {}&quot;, container.getPrincipal());</span>
<span class="nc" id="L259">            login.login();</span>
<span class="nc" id="L260">            container.setLogin(login);</span>
<span class="nc" id="L261">        }</span>
<span class="nc" id="L262">    }</span>

    private boolean hasSufficientTimeElapsed() {
<span class="nc" id="L265">        long now = System.currentTimeMillis();</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">        if (now - getLastLogin() &lt; MIN_TIME_BEFORE_RELOGIN) {</span>
<span class="nc" id="L267">            LOG.warn(&quot;Not attempting to re-login since the last re-login was &quot;</span>
<span class="nc" id="L268">                + &quot;attempted less than {} seconds before.&quot;, MIN_TIME_BEFORE_RELOGIN / 1000);</span>
<span class="nc" id="L269">            return false;</span>
        }
        // register most recent relogin attempt
<span class="nc" id="L272">        setLastLogin(now);</span>
<span class="nc" id="L273">        return true;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>