<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LedgerFragmentReplicator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.client</a> &gt; <span class="el_source">LedgerFragmentReplicator.java</span></div><h1>LedgerFragmentReplicator.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.bookkeeper.client;

import static org.apache.bookkeeper.client.LedgerHandle.INVALID_ENTRY_ID;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;
import org.apache.bookkeeper.net.BookieSocketAddress;
import org.apache.bookkeeper.proto.BookieProtocol;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.MultiCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;
import org.apache.bookkeeper.replication.ReplicationStats;
import org.apache.bookkeeper.stats.Counter;
import org.apache.bookkeeper.stats.NullStatsLogger;
import org.apache.bookkeeper.stats.OpStatsLogger;
import org.apache.bookkeeper.stats.StatsLogger;
import org.apache.bookkeeper.util.OrderedSafeExecutor.OrderedSafeGenericCallback;
import org.apache.zookeeper.AsyncCallback;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This is the helper class for replicating the fragments from one bookie to
 * another
 */
public class LedgerFragmentReplicator {

    // BookKeeper instance
    private BookKeeper bkc;
    private StatsLogger statsLogger;
    private final Counter numEntriesRead;
    private final OpStatsLogger numBytesRead;
    private final Counter numEntriesWritten;
    private final OpStatsLogger numBytesWritten;

<span class="nc" id="L66">    public LedgerFragmentReplicator(BookKeeper bkc, StatsLogger statsLogger) {</span>
<span class="nc" id="L67">        this.bkc = bkc;</span>
<span class="nc" id="L68">        this.statsLogger = statsLogger;</span>
<span class="nc" id="L69">        numEntriesRead = this.statsLogger.getCounter(ReplicationStats.NUM_ENTRIES_READ);</span>
<span class="nc" id="L70">        numBytesRead = this.statsLogger.getOpStatsLogger(ReplicationStats.NUM_BYTES_READ);</span>
<span class="nc" id="L71">        numEntriesWritten = this.statsLogger.getCounter(ReplicationStats.NUM_ENTRIES_WRITTEN);</span>
<span class="nc" id="L72">        numBytesWritten = this.statsLogger.getOpStatsLogger(ReplicationStats.NUM_BYTES_WRITTEN);</span>
<span class="nc" id="L73">    }</span>

    public LedgerFragmentReplicator(BookKeeper bkc) {
<span class="nc" id="L76">        this(bkc, NullStatsLogger.INSTANCE);</span>
<span class="nc" id="L77">    }</span>

<span class="nc" id="L79">    private final static Logger LOG = LoggerFactory</span>
<span class="nc" id="L80">            .getLogger(LedgerFragmentReplicator.class);</span>

    private void replicateFragmentInternal(final LedgerHandle lh,
            final LedgerFragment lf,
            final AsyncCallback.VoidCallback ledgerFragmentMcb,
            final Set&lt;BookieSocketAddress&gt; newBookies) throws InterruptedException {
<span class="nc bnc" id="L86" title="All 2 branches missed.">        if (!lf.isClosed()) {</span>
<span class="nc" id="L87">            LOG.error(&quot;Trying to replicate an unclosed fragment;&quot;</span>
                      + &quot; This is not safe {}&quot;, lf);
<span class="nc" id="L89">            ledgerFragmentMcb.processResult(BKException.Code.UnclosedFragmentException,</span>
                                            null, null);
<span class="nc" id="L91">            return;</span>
        }
<span class="nc" id="L93">        Long startEntryId = lf.getFirstStoredEntryId();</span>
<span class="nc" id="L94">        Long endEntryId = lf.getLastStoredEntryId();</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">        if (endEntryId == null) {</span>
            /*
             * Ideally this should never happen if bookie failure is taken care
             * of properly. Nothing we can do though in this case.
             */
<span class="nc" id="L100">            LOG.warn(&quot;Dead bookie (&quot; + lf.getAddresses()</span>
                    + &quot;) is still part of the current&quot;
<span class="nc" id="L102">                    + &quot; active ensemble for ledgerId: &quot; + lh.getId());</span>
<span class="nc" id="L103">            ledgerFragmentMcb.processResult(BKException.Code.OK, null, null);</span>
<span class="nc" id="L104">            return;</span>
        }
<span class="nc bnc" id="L106" title="All 4 branches missed.">        if (startEntryId &gt; endEntryId || endEntryId &lt;= INVALID_ENTRY_ID) {</span>
            // for open ledger which there is no entry, the start entry id is 0,
            // the end entry id is -1.
            // we can return immediately to trigger forward read
<span class="nc" id="L110">            ledgerFragmentMcb.processResult(BKException.Code.OK, null, null);</span>
<span class="nc" id="L111">            return;</span>
        }

        /*
         * Add all the entries to entriesToReplicate list from
         * firstStoredEntryId to lastStoredEntryID.
         */
<span class="nc" id="L118">        List&lt;Long&gt; entriesToReplicate = new LinkedList&lt;Long&gt;();</span>
<span class="nc" id="L119">        long lastStoredEntryId = lf.getLastStoredEntryId();</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">        for (long i = lf.getFirstStoredEntryId(); i &lt;= lastStoredEntryId; i++) {</span>
<span class="nc" id="L121">            entriesToReplicate.add(i);</span>
        }
        /*
         * Now asynchronously replicate all of the entries for the ledger
         * fragment that were on the dead bookie.
         */
<span class="nc" id="L127">        MultiCallback ledgerFragmentEntryMcb = new MultiCallback(</span>
<span class="nc" id="L128">                entriesToReplicate.size(), ledgerFragmentMcb, null, BKException.Code.OK,</span>
                BKException.Code.LedgerRecoveryException);
<span class="nc bnc" id="L130" title="All 2 branches missed.">        for (final Long entryId : entriesToReplicate) {</span>
<span class="nc" id="L131">            recoverLedgerFragmentEntry(entryId, lh, ledgerFragmentEntryMcb,</span>
                    newBookies);
<span class="nc" id="L133">        }</span>
<span class="nc" id="L134">    }</span>

    /**
     * This method replicate a ledger fragment which is a contiguous portion of
     * a ledger that was stored in an ensemble that included the failed bookie.
     * It will Splits the fragment into multiple sub fragments by keeping the
     * max entries up to the configured value of rereplicationEntryBatchSize and
     * then it re-replicates that batched entry fragments one by one. After
     * re-replication of all batched entry fragments, it will update the
     * ensemble info with new Bookie once
     * 
     * @param lh
     *            LedgerHandle for the ledger
     * @param lf
     *            LedgerFragment to replicate
     * @param ledgerFragmentMcb
     *            MultiCallback to invoke once we've recovered the current
     *            ledger fragment.
     * @param targetBookieAddresses
     *            New bookies we want to use to recover and replicate the ledger
     *            entries that were stored on the failed bookie.
     */
    void replicate(final LedgerHandle lh, final LedgerFragment lf,
            final AsyncCallback.VoidCallback ledgerFragmentMcb,
            final Set&lt;BookieSocketAddress&gt; targetBookieAddresses)
            throws InterruptedException {
<span class="nc" id="L160">        Set&lt;LedgerFragment&gt; partionedFragments = splitIntoSubFragments(lh, lf,</span>
<span class="nc" id="L161">                bkc.getConf().getRereplicationEntryBatchSize());</span>
<span class="nc" id="L162">        LOG.info(&quot;Replicating fragment {} in {} sub fragments.&quot;,</span>
<span class="nc" id="L163">                lf, partionedFragments.size());</span>
<span class="nc" id="L164">        replicateNextBatch(lh, partionedFragments.iterator(),</span>
                ledgerFragmentMcb, targetBookieAddresses);
<span class="nc" id="L166">    }</span>

    /** Replicate the batched entry fragments one after other */
    private void replicateNextBatch(final LedgerHandle lh,
            final Iterator&lt;LedgerFragment&gt; fragments,
            final AsyncCallback.VoidCallback ledgerFragmentMcb,
            final Set&lt;BookieSocketAddress&gt; targetBookieAddresses) {
<span class="nc bnc" id="L173" title="All 2 branches missed.">        if (fragments.hasNext()) {</span>
            try {
<span class="nc" id="L175">                replicateFragmentInternal(lh, fragments.next(),</span>
<span class="nc" id="L176">                        new AsyncCallback.VoidCallback() {</span>
                            @Override
                            public void processResult(int rc, String v, Object ctx) {
<span class="nc bnc" id="L179" title="All 2 branches missed.">                                if (rc != BKException.Code.OK) {</span>
<span class="nc" id="L180">                                    ledgerFragmentMcb.processResult(rc, null,</span>
                                            null);
                                } else {
<span class="nc" id="L183">                                    replicateNextBatch(lh, fragments,</span>
                                            ledgerFragmentMcb,
                                            targetBookieAddresses);
                                }
<span class="nc" id="L187">                            }</span>

                        }, targetBookieAddresses);
<span class="nc" id="L190">            } catch (InterruptedException e) {</span>
<span class="nc" id="L191">                ledgerFragmentMcb.processResult(</span>
                        BKException.Code.InterruptedException, null, null);
<span class="nc" id="L193">                Thread.currentThread().interrupt();</span>
<span class="nc" id="L194">            }</span>
        } else {
<span class="nc" id="L196">            ledgerFragmentMcb.processResult(BKException.Code.OK, null, null);</span>
        }
<span class="nc" id="L198">    }</span>

    /**
     * Split the full fragment into batched entry fragments by keeping
     * rereplicationEntryBatchSize of entries in each one and can treat them as
     * sub fragments
     */
    static Set&lt;LedgerFragment&gt; splitIntoSubFragments(LedgerHandle lh,
            LedgerFragment ledgerFragment, long rereplicationEntryBatchSize) {
<span class="nc" id="L207">        Set&lt;LedgerFragment&gt; fragments = new HashSet&lt;LedgerFragment&gt;();</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">        if (rereplicationEntryBatchSize &lt;= 0) {</span>
            // rereplicationEntryBatchSize can not be 0 or less than 0,
            // returning with the current fragment
<span class="nc" id="L211">            fragments.add(ledgerFragment);</span>
<span class="nc" id="L212">            return fragments;</span>
        }

<span class="nc" id="L215">        long firstEntryId = ledgerFragment.getFirstStoredEntryId();</span>
<span class="nc" id="L216">        long lastEntryId = ledgerFragment.getLastStoredEntryId();</span>
<span class="nc" id="L217">        long numberOfEntriesToReplicate = (lastEntryId - firstEntryId) + 1;</span>
<span class="nc" id="L218">        long splitsWithFullEntries = numberOfEntriesToReplicate</span>
                / rereplicationEntryBatchSize;

<span class="nc bnc" id="L221" title="All 2 branches missed.">        if (splitsWithFullEntries == 0) {// only one fragment</span>
<span class="nc" id="L222">            fragments.add(ledgerFragment);</span>
<span class="nc" id="L223">            return fragments;</span>
        }

<span class="nc" id="L226">        long fragmentSplitLastEntry = 0;</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">        for (int i = 0; i &lt; splitsWithFullEntries; i++) {</span>
<span class="nc" id="L228">            fragmentSplitLastEntry = (firstEntryId + rereplicationEntryBatchSize) - 1;</span>
<span class="nc" id="L229">            fragments.add(new LedgerFragment(lh, firstEntryId,</span>
<span class="nc" id="L230">                    fragmentSplitLastEntry, ledgerFragment.getBookiesIndexes()));</span>
<span class="nc" id="L231">            firstEntryId = fragmentSplitLastEntry + 1;</span>
        }

<span class="nc" id="L234">        long lastSplitWithPartialEntries = numberOfEntriesToReplicate</span>
                % rereplicationEntryBatchSize;
<span class="nc bnc" id="L236" title="All 2 branches missed.">        if (lastSplitWithPartialEntries &gt; 0) {</span>
<span class="nc" id="L237">            fragments.add(new LedgerFragment(lh, firstEntryId, firstEntryId</span>
                    + lastSplitWithPartialEntries - 1, ledgerFragment
<span class="nc" id="L239">                    .getBookiesIndexes()));</span>
        }
<span class="nc" id="L241">        return fragments;</span>
    }

    /**
     * This method asynchronously recovers a specific ledger entry by reading
     * the values via the BookKeeper Client (which would read it from the other
     * replicas) and then writing it to the chosen new bookie.
     *
     * @param entryId
     *            Ledger Entry ID to recover.
     * @param lh
     *            LedgerHandle for the ledger
     * @param ledgerFragmentEntryMcb
     *            MultiCallback to invoke once we've recovered the current
     *            ledger entry.
     * @param newBookies
     *            New bookies we want to use to recover and replicate the ledger
     *            entries that were stored on the failed bookie.
     */
    private void recoverLedgerFragmentEntry(final Long entryId,
            final LedgerHandle lh,
            final AsyncCallback.VoidCallback ledgerFragmentEntryMcb,
            final Set&lt;BookieSocketAddress&gt; newBookies) throws InterruptedException {
<span class="nc" id="L264">        final AtomicInteger numCompleted = new AtomicInteger(0);</span>
<span class="nc" id="L265">        final AtomicBoolean completed = new AtomicBoolean(false);</span>
<span class="nc" id="L266">        final WriteCallback multiWriteCallback = new WriteCallback() {</span>
            @Override
            public void writeComplete(int rc, long ledgerId, long entryId, BookieSocketAddress addr, Object ctx) {
<span class="nc bnc" id="L269" title="All 2 branches missed.">                if (rc != BKException.Code.OK) {</span>
<span class="nc" id="L270">                    LOG.error(&quot;BK error writing entry for ledgerId: {}, entryId: {}, bookie: {}&quot;,</span>
<span class="nc" id="L271">                              new Object[] { ledgerId, entryId, addr, BKException.create(rc) });</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">                    if (completed.compareAndSet(false, true)) {</span>
<span class="nc" id="L273">                        ledgerFragmentEntryMcb.processResult(rc, null, null);</span>
                    }
                } else {
<span class="nc" id="L276">                    numEntriesWritten.inc();</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">                    if (ctx instanceof Long) {</span>
<span class="nc" id="L278">                        numBytesWritten.registerSuccessfulValue((Long) ctx);</span>
                    }
<span class="nc bnc" id="L280" title="All 2 branches missed.">                    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L281">                        LOG.debug(&quot;Success writing ledger id {}, entry id {} to a new bookie {}!&quot;,</span>
<span class="nc" id="L282">                                  new Object[] { ledgerId, entryId, addr });</span>
                    }
<span class="nc bnc" id="L284" title="All 2 branches missed.">                    if (numCompleted.incrementAndGet() == newBookies.size() &amp;&amp;</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">                        completed.compareAndSet(false, true)) {</span>
<span class="nc" id="L286">                        ledgerFragmentEntryMcb.processResult(rc, null, null);</span>
                    }
                }
<span class="nc" id="L289">            }</span>
        };
        /*
         * Read the ledger entry using the LedgerHandle. This will allow us to
         * read the entry from one of the other replicated bookies other than
         * the dead one.
         */
<span class="nc" id="L296">        lh.asyncReadEntries(entryId, entryId, new ReadCallback() {</span>
            @Override
            public void readComplete(int rc, LedgerHandle lh,
                    Enumeration&lt;LedgerEntry&gt; seq, Object ctx) {
<span class="nc bnc" id="L300" title="All 2 branches missed.">                if (rc != BKException.Code.OK) {</span>
<span class="nc" id="L301">                    LOG.error(&quot;BK error reading ledger entry: &quot; + entryId,</span>
<span class="nc" id="L302">                            BKException.create(rc));</span>
<span class="nc" id="L303">                    ledgerFragmentEntryMcb.processResult(rc, null, null);</span>
<span class="nc" id="L304">                    return;</span>
                }
                /*
                 * Now that we've read the ledger entry, write it to the new
                 * bookie we've selected.
                 */
<span class="nc" id="L310">                LedgerEntry entry = seq.nextElement();</span>
<span class="nc" id="L311">                byte[] data = entry.getEntry();</span>
<span class="nc" id="L312">                final long dataLength = data.length;</span>
<span class="nc" id="L313">                numEntriesRead.inc();</span>
<span class="nc" id="L314">                numBytesRead.registerSuccessfulValue(dataLength);</span>
<span class="nc" id="L315">                ByteBuf toSend = lh.getDigestManager()</span>
<span class="nc" id="L316">                        .computeDigestAndPackageForSending(entryId,</span>
<span class="nc" id="L317">                                lh.getLastAddConfirmed(), entry.getLength(),</span>
<span class="nc" id="L318">                                Unpooled.wrappedBuffer(data, 0, data.length));</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">                for (BookieSocketAddress newBookie : newBookies) {</span>
<span class="nc" id="L320">                    bkc.getBookieClient().addEntry(newBookie, lh.getId(),</span>
<span class="nc" id="L321">                            lh.getLedgerKey(), entryId, toSend.retainedSlice(),</span>
<span class="nc" id="L322">                            multiWriteCallback, dataLength, BookieProtocol.FLAG_RECOVERY_ADD);</span>
<span class="nc" id="L323">                }</span>
<span class="nc" id="L324">                toSend.release();</span>
<span class="nc" id="L325">            }</span>
        }, null);
<span class="nc" id="L327">    }</span>

    /**
     * Callback for recovery of a single ledger fragment. Once the fragment has
     * had all entries replicated, update the ensemble in zookeeper. Once
     * finished propogate callback up to ledgerFragmentsMcb which should be a
     * multicallback responsible for all fragments in a single ledger
     */
    static class SingleFragmentCallback implements AsyncCallback.VoidCallback {
        final AsyncCallback.VoidCallback ledgerFragmentsMcb;
        final LedgerHandle lh;
        final long fragmentStartId;
        final Map&lt;BookieSocketAddress, BookieSocketAddress&gt; oldBookie2NewBookie;

        SingleFragmentCallback(AsyncCallback.VoidCallback ledgerFragmentsMcb,
                LedgerHandle lh, long fragmentStartId,
<span class="nc" id="L343">                Map&lt;BookieSocketAddress, BookieSocketAddress&gt; oldBookie2NewBookie) {</span>
<span class="nc" id="L344">            this.ledgerFragmentsMcb = ledgerFragmentsMcb;</span>
<span class="nc" id="L345">            this.lh = lh;</span>
<span class="nc" id="L346">            this.fragmentStartId = fragmentStartId;</span>
<span class="nc" id="L347">            this.oldBookie2NewBookie = oldBookie2NewBookie;</span>
<span class="nc" id="L348">        }</span>

        @Override
        public void processResult(int rc, String path, Object ctx) {
<span class="nc bnc" id="L352" title="All 2 branches missed.">            if (rc != BKException.Code.OK) {</span>
<span class="nc" id="L353">                LOG.error(&quot;BK error replicating ledger fragments for ledger: &quot;</span>
<span class="nc" id="L354">                        + lh.getId(), BKException.create(rc));</span>
<span class="nc" id="L355">                ledgerFragmentsMcb.processResult(rc, null, null);</span>
<span class="nc" id="L356">                return;</span>
            }
<span class="nc" id="L358">            updateEnsembleInfo(ledgerFragmentsMcb, fragmentStartId, lh, oldBookie2NewBookie);</span>
<span class="nc" id="L359">        }</span>
    }

    /** Updates the ensemble with newBookie and notify the ensembleUpdatedCb */
    private static void updateEnsembleInfo(
            AsyncCallback.VoidCallback ensembleUpdatedCb, long fragmentStartId,
            LedgerHandle lh, Map&lt;BookieSocketAddress, BookieSocketAddress&gt; oldBookie2NewBookie) {
        /*
         * Update the ledger metadata's ensemble info to point to the new
         * bookie.
         */
<span class="nc" id="L370">        ArrayList&lt;BookieSocketAddress&gt; ensemble = lh.getLedgerMetadata()</span>
<span class="nc" id="L371">                .getEnsembles().get(fragmentStartId);</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">        for (Map.Entry&lt;BookieSocketAddress, BookieSocketAddress&gt; entry : oldBookie2NewBookie.entrySet()) {</span>
<span class="nc" id="L373">            int deadBookieIndex = ensemble.indexOf(entry.getKey());</span>
            // update ensemble info might happen after re-read ledger metadata, so the ensemble might already
            // change. if ensemble is already changed, skip replacing the bookie doesn't exist.
<span class="nc bnc" id="L376" title="All 2 branches missed.">            if (deadBookieIndex &gt;= 0) {</span>
<span class="nc" id="L377">                ensemble.set(deadBookieIndex, entry.getValue());</span>
            } else {
<span class="nc" id="L379">                LOG.info(&quot;Bookie {} doesn't exist in ensemble {} anymore.&quot;, entry.getKey(), ensemble);</span>
            }
<span class="nc" id="L381">        }</span>
<span class="nc" id="L382">        lh.writeLedgerConfig(new UpdateEnsembleCb(ensembleUpdatedCb,</span>
                fragmentStartId, lh, oldBookie2NewBookie));
<span class="nc" id="L384">    }</span>

    /**
     * Update the ensemble data with newBookie. re-reads the metadata on
     * MetadataVersionException and update ensemble again. On successfull
     * updation, it will also notify to super call back
     */
    private static class UpdateEnsembleCb implements GenericCallback&lt;Void&gt; {
        final AsyncCallback.VoidCallback ensembleUpdatedCb;
        final LedgerHandle lh;
        final long fragmentStartId;
        final Map&lt;BookieSocketAddress, BookieSocketAddress&gt; oldBookie2NewBookie;

        public UpdateEnsembleCb(AsyncCallback.VoidCallback ledgerFragmentsMcb,
                long fragmentStartId, LedgerHandle lh,
<span class="nc" id="L399">                Map&lt;BookieSocketAddress, BookieSocketAddress&gt; oldBookie2NewBookie) {</span>
<span class="nc" id="L400">            this.ensembleUpdatedCb = ledgerFragmentsMcb;</span>
<span class="nc" id="L401">            this.lh = lh;</span>
<span class="nc" id="L402">            this.fragmentStartId = fragmentStartId;</span>
<span class="nc" id="L403">            this.oldBookie2NewBookie = oldBookie2NewBookie;</span>
<span class="nc" id="L404">        }</span>

        @Override
        public void operationComplete(int rc, Void result) {
<span class="nc bnc" id="L408" title="All 2 branches missed.">            if (rc == BKException.Code.MetadataVersionException) {</span>
<span class="nc" id="L409">                LOG.warn(&quot;Two fragments attempted update at once; ledger id: &quot;</span>
<span class="nc" id="L410">                        + lh.getId() + &quot; startid: &quot; + fragmentStartId);</span>
                // try again, the previous success (with which this has
                // conflicted) will have updated the stat other operations
                // such as (addEnsemble) would update it too.
<span class="nc" id="L414">                lh.rereadMetadata(new OrderedSafeGenericCallback&lt;LedgerMetadata&gt;(</span>
<span class="nc" id="L415">                                lh.bk.mainWorkerPool, lh.getId()) {</span>
                            @Override
                            public void safeOperationComplete(int rc,
                                    LedgerMetadata newMeta) {
<span class="nc bnc" id="L419" title="All 2 branches missed.">                                if (rc != BKException.Code.OK) {</span>
<span class="nc" id="L420">                                    LOG</span>
<span class="nc" id="L421">                                            .error(&quot;Error reading updated ledger metadata for ledger &quot;</span>
<span class="nc" id="L422">                                                    + lh.getId());</span>
<span class="nc" id="L423">                                    ensembleUpdatedCb.processResult(rc, null,</span>
                                            null);
                                } else {
<span class="nc" id="L426">                                    lh.metadata = newMeta;</span>
<span class="nc" id="L427">                                    updateEnsembleInfo(ensembleUpdatedCb,</span>
                                            fragmentStartId, lh, oldBookie2NewBookie);
                                }
<span class="nc" id="L430">                            }</span>
                            @Override
                            public String toString() {
<span class="nc" id="L433">                                return String.format(&quot;ReReadMetadataForUpdateEnsemble(%d)&quot;, lh.getId());</span>
                            }
                        });
<span class="nc" id="L436">                return;</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">            } else if (rc != BKException.Code.OK) {</span>
<span class="nc" id="L438">                LOG.error(&quot;Error updating ledger config metadata for ledgerId &quot;</span>
<span class="nc" id="L439">                        + lh.getId() + &quot; : &quot; + BKException.getMessage(rc));</span>
            } else {
<span class="nc" id="L441">                LOG.info(&quot;Updated ZK for ledgerId: (&quot; + lh.getId() + &quot; : &quot;</span>
                        + fragmentStartId
                        + &quot;) to point ledger fragments from old bookies to new bookies: &quot;
                        + oldBookie2NewBookie);
            }
            /*
             * Pass the return code result up the chain with the parent
             * callback.
             */
<span class="nc" id="L450">            ensembleUpdatedCb.processResult(rc, null, null);</span>
<span class="nc" id="L451">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>