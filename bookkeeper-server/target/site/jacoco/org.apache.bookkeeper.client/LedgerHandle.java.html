<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LedgerHandle.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.client</a> &gt; <span class="el_source">LedgerHandle.java</span></div><h1>LedgerHandle.java</h1><pre class="source lang-java linenums">/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.bookkeeper.client;

import static org.apache.bookkeeper.client.api.BKException.Code.ClientClosedException;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Objects;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.collect.Iterators;
import com.google.common.collect.Sets;
import com.google.common.util.concurrent.RateLimiter;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import java.security.GeneralSecurityException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import org.apache.bookkeeper.client.AsyncCallback.AddCallback;
import org.apache.bookkeeper.client.AsyncCallback.CloseCallback;
import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;
import org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback;
import org.apache.bookkeeper.client.BKException.BKIncorrectParameterException;
import org.apache.bookkeeper.client.BKException.BKReadException;
import org.apache.bookkeeper.client.BookKeeper.DigestType;
import org.apache.bookkeeper.client.SyncCallbackUtils.FutureReadLastConfirmed;
import org.apache.bookkeeper.client.SyncCallbackUtils.FutureReadLastConfirmedAndEntry;
import org.apache.bookkeeper.client.SyncCallbackUtils.SyncAddCallback;
import org.apache.bookkeeper.client.SyncCallbackUtils.SyncCloseCallback;
import org.apache.bookkeeper.client.SyncCallbackUtils.SyncReadCallback;
import org.apache.bookkeeper.client.SyncCallbackUtils.SyncReadLastConfirmedCallback;
import org.apache.bookkeeper.client.api.BKException.Code;
import org.apache.bookkeeper.client.api.LastConfirmedAndEntry;
import org.apache.bookkeeper.client.api.LedgerEntries;
import org.apache.bookkeeper.client.api.WriteHandle;
import org.apache.bookkeeper.client.impl.LedgerEntryImpl;
import org.apache.bookkeeper.common.concurrent.FutureEventListener;
import org.apache.bookkeeper.common.concurrent.FutureUtils;
import org.apache.bookkeeper.net.BookieSocketAddress;
import org.apache.bookkeeper.proto.BookieProtocol;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.TimedGenericCallback;
import org.apache.bookkeeper.proto.DataFormats.LedgerMetadataFormat.State;
import org.apache.bookkeeper.stats.Counter;
import org.apache.bookkeeper.stats.Gauge;
import org.apache.bookkeeper.util.OrderedSafeExecutor.OrderedSafeGenericCallback;
import org.apache.bookkeeper.util.SafeRunnable;
import org.apache.commons.collections4.IteratorUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Ledger handle contains ledger metadata and is used to access the read and
 * write operations to a ledger.
 */
public class LedgerHandle implements WriteHandle {
<span class="fc" id="L90">    final static Logger LOG = LoggerFactory.getLogger(LedgerHandle.class);</span>

    final byte[] ledgerKey;
    LedgerMetadata metadata;
    final BookKeeper bk;
    final long ledgerId;
    long lastAddPushed;
    volatile long lastAddConfirmed;

    long length;
    final DigestManager macManager;
    final DistributionSchedule distributionSchedule;
    final RateLimiter throttler;
    final LoadingCache&lt;BookieSocketAddress, Long&gt; bookieFailureHistory;
    final boolean enableParallelRecoveryRead;
    final int recoveryReadBatchSize;

    /**
     * Invalid entry id. This value is returned from methods which
     * should return an entry id but there is no valid entry available.
     */
    final static public long INVALID_ENTRY_ID = BookieProtocol.INVALID_ENTRY_ID;

<span class="fc" id="L113">    final AtomicInteger blockAddCompletions = new AtomicInteger(0);</span>
<span class="fc" id="L114">    final AtomicInteger numEnsembleChanges = new AtomicInteger(0);</span>
    Queue&lt;PendingAddOp&gt; pendingAddOps;
    ExplicitLacFlushPolicy explicitLacFlushPolicy;

    final Counter ensembleChangeCounter;
    final Counter lacUpdateHitsCounter;
    final Counter lacUpdateMissesCounter;

    // This empty master key is used when an empty password is provided which is the hash of an empty string
    private final static byte[] emptyLedgerKey;
    static {
        try {
<span class="fc" id="L126">            emptyLedgerKey = MacDigestManager.genDigest(&quot;ledger&quot;, new byte[0]);</span>
<span class="nc" id="L127">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L128">            throw new RuntimeException(e);</span>
<span class="fc" id="L129">        }</span>
<span class="fc" id="L130">    }</span>

    LedgerHandle(BookKeeper bk, long ledgerId, LedgerMetadata metadata,
                 DigestType digestType, byte[] password)
<span class="fc" id="L134">            throws GeneralSecurityException, NumberFormatException {</span>
<span class="fc" id="L135">        this.bk = bk;</span>
<span class="fc" id="L136">        this.metadata = metadata;</span>
<span class="fc" id="L137">        this.pendingAddOps = new ConcurrentLinkedQueue&lt;PendingAddOp&gt;();</span>
<span class="fc" id="L138">        this.enableParallelRecoveryRead = bk.getConf().getEnableParallelRecoveryRead();</span>
<span class="fc" id="L139">        this.recoveryReadBatchSize = bk.getConf().getRecoveryReadBatchSize();</span>

<span class="pc bpc" id="L141" title="1 of 2 branches missed.">        if (metadata.isClosed()) {</span>
<span class="nc" id="L142">            lastAddConfirmed = lastAddPushed = metadata.getLastEntryId();</span>
<span class="nc" id="L143">            length = metadata.getLength();</span>
        } else {
<span class="fc" id="L145">            lastAddConfirmed = lastAddPushed = INVALID_ENTRY_ID;</span>
<span class="fc" id="L146">            length = 0;</span>
        }

<span class="fc" id="L149">        this.ledgerId = ledgerId;</span>

<span class="pc bpc" id="L151" title="1 of 2 branches missed.">        if (bk.getConf().getThrottleValue() &gt; 0) {</span>
<span class="fc" id="L152">            this.throttler = RateLimiter.create(bk.getConf().getThrottleValue());</span>
        } else {
<span class="nc" id="L154">            this.throttler = null;</span>
        }

<span class="fc" id="L157">        macManager = DigestManager.instantiate(ledgerId, password, digestType);</span>

        // If the password is empty, pass the same random ledger key which is generated by the hash of the empty
        // password, so that the bookie can avoid processing the keys for each entry
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">        this.ledgerKey = password.length &gt; 0 ? MacDigestManager.genDigest(&quot;ledger&quot;, password) : emptyLedgerKey;</span>
<span class="fc" id="L162">        distributionSchedule = new RoundRobinDistributionSchedule(</span>
<span class="fc" id="L163">                metadata.getWriteQuorumSize(), metadata.getAckQuorumSize(), metadata.getEnsembleSize());</span>
<span class="fc" id="L164">        this.bookieFailureHistory = CacheBuilder.newBuilder()</span>
<span class="fc" id="L165">            .expireAfterWrite(bk.getConf().getBookieFailureHistoryExpirationMSec(), TimeUnit.MILLISECONDS)</span>
<span class="fc" id="L166">            .build(new CacheLoader&lt;BookieSocketAddress, Long&gt;() {</span>
            public Long load(BookieSocketAddress key) {
<span class="nc" id="L168">                return -1L;</span>
            }
        });

<span class="fc" id="L172">        ensembleChangeCounter = bk.getStatsLogger().getCounter(BookKeeperClientStats.ENSEMBLE_CHANGES);</span>
<span class="fc" id="L173">        lacUpdateHitsCounter = bk.getStatsLogger().getCounter(BookKeeperClientStats.LAC_UPDATE_HITS);</span>
<span class="fc" id="L174">        lacUpdateMissesCounter = bk.getStatsLogger().getCounter(BookKeeperClientStats.LAC_UPDATE_MISSES);</span>
<span class="fc" id="L175">        bk.getStatsLogger().registerGauge(BookKeeperClientStats.PENDING_ADDS,</span>
<span class="fc" id="L176">                                          new Gauge&lt;Integer&gt;() {</span>
                                              public Integer getDefaultValue() {
<span class="nc" id="L178">                                                  return 0;</span>
                                              }
                                              public Integer getSample() {
<span class="nc" id="L181">                                                  return pendingAddOps.size();</span>
                                              }
                                          });
<span class="fc" id="L184">        initializeExplicitLacFlushPolicy();</span>
<span class="fc" id="L185">    }</span>

    protected void initializeExplicitLacFlushPolicy() {
<span class="pc bpc" id="L188" title="2 of 4 branches missed.">        if (!metadata.isClosed() &amp;&amp; bk.getExplicitLacInterval() &gt; 0) {</span>
<span class="nc" id="L189">            explicitLacFlushPolicy = new ExplicitLacFlushPolicy.ExplicitLacFlushPolicyImpl(this);</span>
        } else {
<span class="fc" id="L191">            explicitLacFlushPolicy = ExplicitLacFlushPolicy.VOID_EXPLICITLAC_FLUSH_POLICY;</span>
        }
<span class="fc" id="L193">    }</span>

    /**
     * Get the id of the current ledger
     *
     * @return the id of the ledger
     */
    public long getId() {
<span class="fc" id="L201">        return ledgerId;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public synchronized long getLastAddConfirmed() {
<span class="fc" id="L209">        return lastAddConfirmed;</span>
    }

    synchronized void setLastAddConfirmed(long lac) {
<span class="nc" id="L213">        this.lastAddConfirmed = lac;</span>
<span class="nc" id="L214">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public synchronized long getLastAddPushed() {
<span class="nc" id="L221">        return lastAddPushed;</span>
    }

    /**
     * Get the Ledger's key/password.
     *
     * @return byte array for the ledger's key/password.
     */
    public byte[] getLedgerKey() {
<span class="nc" id="L230">        return Arrays.copyOf(ledgerKey, ledgerKey.length);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public LedgerMetadata getLedgerMetadata() {
<span class="fc" id="L238">        return metadata;</span>
    }

    /**
     * Get this ledger's customMetadata map.
     *
     * @return map containing user provided customMetadata.
     */
    public Map&lt;String, byte[]&gt; getCustomMetadata() {
<span class="nc" id="L247">        return metadata.getCustomMetadata();</span>
    }

    /**
     * Get the number of fragments that makeup this ledger
     *
     * @return the count of fragments
     */
    synchronized public long getNumFragments() {
<span class="nc" id="L256">        return metadata.getEnsembles().size();</span>
    }

    /**
     * Get the count of unique bookies that own part of this ledger
     * by going over all the fragments of the ledger.
     *
     * @return count of unique bookies
     */
    synchronized public long getNumBookies() {
<span class="nc" id="L266">        Map&lt;Long, ArrayList&lt;BookieSocketAddress&gt;&gt; m = metadata.getEnsembles();</span>
<span class="nc" id="L267">        Set&lt;BookieSocketAddress&gt; s = Sets.newHashSet();</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">        for (ArrayList&lt;BookieSocketAddress&gt; aList : m.values()) {</span>
<span class="nc" id="L269">            s.addAll(aList);</span>
<span class="nc" id="L270">        }</span>
<span class="nc" id="L271">        return s.size();</span>
    }

    /**
     * Get the DigestManager
     *
     * @return DigestManager for the LedgerHandle
     */
    DigestManager getDigestManager() {
<span class="nc" id="L280">        return macManager;</span>
    }

    /**
     *  Add to the length of the ledger in bytes.
     *
     * @param delta
     * @return the length of the ledger after the addition
     */
    synchronized long addToLength(long delta) {
<span class="fc" id="L290">        this.length += delta;</span>
<span class="fc" id="L291">        return this.length;</span>
    }

    /**
     * Returns the length of the ledger in bytes.
     *
     * @return the length of the ledger in bytes
     */
    synchronized public long getLength() {
<span class="nc" id="L300">        return this.length;</span>
    }

    /**
     * Get the Distribution Schedule
     *
     * @return DistributionSchedule for the LedgerHandle
     */
    DistributionSchedule getDistributionSchedule() {
<span class="nc" id="L309">        return distributionSchedule;</span>
    }

    void writeLedgerConfig(GenericCallback&lt;Void&gt; writeCb) {
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L314">            LOG.debug(&quot;Writing metadata to ledger manager: {}, {}&quot;, this.ledgerId, metadata.getVersion());</span>
        }

<span class="fc" id="L317">        bk.getLedgerManager().writeLedgerMetadata(ledgerId, metadata, writeCb);</span>
<span class="fc" id="L318">    }</span>

    /**
     * {@inheritDoc }
     */
    @Override
    public void close()
            throws InterruptedException, BKException {
<span class="fc" id="L326">        SyncCallbackUtils.waitForResult(asyncClose());</span>
<span class="fc" id="L327">    }</span>

    /**
     * {@inheritDoc }
     */
    @Override
    public CompletableFuture&lt;Void&gt; asyncClose() {
<span class="fc" id="L334">        CompletableFuture&lt;Void&gt; result = new CompletableFuture&lt;&gt;();</span>
<span class="fc" id="L335">        SyncCloseCallback callback = new SyncCloseCallback(result);</span>
<span class="fc" id="L336">        asyncClose(callback, null);</span>
<span class="fc" id="L337">        explicitLacFlushPolicy.stopExplicitLacFlush();</span>
<span class="fc" id="L338">        return result;</span>
    }

    /**
     * Asynchronous close, any adds in flight will return errors.
     *
     * Closing a ledger will ensure that all clients agree on what the last entry
     * of the ledger is. This ensures that, once the ledger has been closed, all
     * reads from the ledger will return the same set of entries.
     *
     * @param cb
     *          callback implementation
     * @param ctx
     *          control object
     */
    public void asyncClose(CloseCallback cb, Object ctx) {
<span class="fc" id="L354">        asyncCloseInternal(cb, ctx, BKException.Code.LedgerClosedException);</span>
<span class="fc" id="L355">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public synchronized boolean isClosed() {
<span class="fc" id="L362">        return metadata.isClosed();</span>
    }

    void asyncCloseInternal(final CloseCallback cb, final Object ctx, final int rc) {
        try {
<span class="fc" id="L367">            doAsyncCloseInternal(cb, ctx, rc);</span>
<span class="nc" id="L368">        } catch (RejectedExecutionException re) {</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L370">                LOG.debug(&quot;Failed to close ledger {} : &quot;, ledgerId, re);</span>
            }
<span class="nc" id="L372">            errorOutPendingAdds(bk.getReturnRc(rc));</span>
<span class="nc" id="L373">            cb.closeComplete(bk.getReturnRc(BKException.Code.InterruptedException), this, ctx);</span>
<span class="fc" id="L374">        }</span>
<span class="fc" id="L375">    }</span>

    /**
     * Same as public version of asyncClose except that this one takes an
     * additional parameter which is the return code to hand to all the pending
     * add ops
     *
     * @param cb
     * @param ctx
     * @param rc
     */
    void doAsyncCloseInternal(final CloseCallback cb, final Object ctx, final int rc) {
<span class="fc" id="L387">        bk.getMainWorkerPool().submitOrdered(ledgerId, new SafeRunnable() {</span>
            @Override
            public void safeRun() {
                final long prevLastEntryId;
                final long prevLength;
                final State prevState;
                List&lt;PendingAddOp&gt; pendingAdds;

<span class="pc bpc" id="L395" title="1 of 2 branches missed.">                if (isClosed()) {</span>
                    // TODO: make ledger metadata immutable {@link https://github.com/apache/bookkeeper/issues/281}
                    // Although the metadata is already closed, we don't need to proceed zookeeper metadata update, but
                    // we still need to error out the pending add ops.
                    //
                    // There is a race condition a pending add op is enqueued, after a close op reset ledger metadata state
                    // to unclosed to resolve metadata conflicts. If we don't error out these pending add ops, they would be
                    // leak and never callback.
                    //
                    // The race condition happen in following sequence:
                    // a) ledger L is fenced
                    // b) write entry E encountered LedgerFencedException, trigger ledger close procedure
                    // c) ledger close encountered metadata version exception and set ledger metadata back to open
                    // d) writer tries to write entry E+1, since ledger metadata is still open (reset by c))
                    // e) the close procedure in c) resolved the metadata conflicts and set ledger metadata to closed
                    // f) writing entry E+1 encountered LedgerFencedException which will enter ledger close procedure
                    // g) it would find that ledger metadata is closed, then it callbacks immediately without erroring out any pendings
<span class="nc" id="L412">                    synchronized (LedgerHandle.this) {</span>
<span class="nc" id="L413">                        pendingAdds = drainPendingAddsToErrorOut();</span>
<span class="nc" id="L414">                    }</span>
<span class="nc" id="L415">                    errorOutPendingAdds(rc, pendingAdds);</span>
<span class="nc" id="L416">                    cb.closeComplete(BKException.Code.OK, LedgerHandle.this, ctx);</span>
<span class="nc" id="L417">                    return;</span>
                }

<span class="fc" id="L420">                synchronized(LedgerHandle.this) {</span>
<span class="fc" id="L421">                    prevState = metadata.getState();</span>
<span class="fc" id="L422">                    prevLastEntryId = metadata.getLastEntryId();</span>
<span class="fc" id="L423">                    prevLength = metadata.getLength();</span>

                    // drain pending adds first
<span class="fc" id="L426">                    pendingAdds = drainPendingAddsToErrorOut();</span>

                    // synchronized on LedgerHandle.this to ensure that
                    // lastAddPushed can not be updated after the metadata
                    // is closed.
<span class="fc" id="L431">                    metadata.setLength(length);</span>
<span class="fc" id="L432">                    metadata.close(lastAddConfirmed);</span>
<span class="fc" id="L433">                    lastAddPushed = lastAddConfirmed;</span>
<span class="fc" id="L434">                }</span>

                // error out all pending adds during closing, the callbacks shouldn't be
                // running under any bk locks.
<span class="fc" id="L438">                errorOutPendingAdds(rc, pendingAdds);</span>

<span class="pc bpc" id="L440" title="1 of 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L441">                    LOG.debug(&quot;Closing ledger: &quot; + ledgerId + &quot; at entryId: &quot;</span>
<span class="nc" id="L442">                              + metadata.getLastEntryId() + &quot; with this many bytes: &quot; + metadata.getLength());</span>
                }

                final class CloseCb extends OrderedSafeGenericCallback&lt;Void&gt; {
<span class="fc" id="L446">                    CloseCb() {</span>
<span class="fc" id="L447">                        super(bk.getMainWorkerPool(), ledgerId);</span>
<span class="fc" id="L448">                    }</span>

                    @Override
                    public void safeOperationComplete(final int rc, Void result) {
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">                        if (rc == BKException.Code.MetadataVersionException) {</span>
<span class="nc" id="L453">                            rereadMetadata(new OrderedSafeGenericCallback&lt;LedgerMetadata&gt;(bk.getMainWorkerPool(),</span>
<span class="nc" id="L454">                                                                                          ledgerId) {</span>
                                @Override
                                public void safeOperationComplete(int newrc, LedgerMetadata newMeta) {
<span class="nc bnc" id="L457" title="All 2 branches missed.">                                    if (newrc != BKException.Code.OK) {</span>
<span class="nc" id="L458">                                        LOG.error(&quot;Error reading new metadata from ledger {} when closing, code={}&quot;,</span>
<span class="nc" id="L459">                                                ledgerId, newrc);</span>
<span class="nc" id="L460">                                        cb.closeComplete(rc, LedgerHandle.this, ctx);</span>
                                    } else {
<span class="nc" id="L462">                                        metadata.setState(prevState);</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">                                        if (prevState.equals(State.CLOSED)) {</span>
<span class="nc" id="L464">                                            metadata.close(prevLastEntryId);</span>
                                        }

<span class="nc" id="L467">                                        metadata.setLength(prevLength);</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">                                        if (!metadata.isNewerThan(newMeta)</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">                                                &amp;&amp; !metadata.isConflictWith(newMeta)) {</span>
                                            // use the new metadata's ensemble, in case re-replication already
                                            // replaced some bookies in the ensemble.
<span class="nc" id="L472">                                            metadata.setEnsembles(newMeta.getEnsembles());</span>
<span class="nc" id="L473">                                            metadata.setVersion(newMeta.version);</span>
<span class="nc" id="L474">                                            metadata.setLength(length);</span>
<span class="nc" id="L475">                                            metadata.close(getLastAddConfirmed());</span>
<span class="nc" id="L476">                                            writeLedgerConfig(new CloseCb());</span>
<span class="nc" id="L477">                                            return;</span>
                                        } else {
<span class="nc" id="L479">                                            metadata.setLength(length);</span>
<span class="nc" id="L480">                                            metadata.close(getLastAddConfirmed());</span>
<span class="nc" id="L481">                                            LOG.warn(&quot;Conditional update ledger metadata for ledger {} failed.&quot;, ledgerId);</span>
<span class="nc" id="L482">                                            cb.closeComplete(rc, LedgerHandle.this, ctx);</span>
                                        }
                                    }
<span class="nc" id="L485">                                }</span>

                                @Override
                                public String toString() {
<span class="nc" id="L489">                                    return String.format(&quot;ReReadMetadataForClose(%d)&quot;, ledgerId);</span>
                                }
                            });
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">                        } else if (rc != BKException.Code.OK) {</span>
<span class="nc" id="L493">                            LOG.error(&quot;Error update ledger metadata for ledger {} : {}&quot;, ledgerId, rc);</span>
<span class="nc" id="L494">                            cb.closeComplete(rc, LedgerHandle.this, ctx);</span>
                        } else {
<span class="fc" id="L496">                            cb.closeComplete(BKException.Code.OK, LedgerHandle.this, ctx);</span>
                        }
<span class="fc" id="L498">                    }</span>

                    @Override
                    public String toString() {
<span class="nc" id="L502">                        return String.format(&quot;WriteLedgerConfigForClose(%d)&quot;, ledgerId);</span>
                    }
                }

<span class="fc" id="L506">                writeLedgerConfig(new CloseCb());</span>

<span class="fc" id="L508">            }</span>

            @Override
            public String toString() {
<span class="nc" id="L512">                return String.format(&quot;CloseLedgerHandle(%d)&quot;, ledgerId);</span>
            }
        });
<span class="fc" id="L515">    }</span>

    /**
     * Read a sequence of entries synchronously.
     *
     * @param firstEntry
     *          id of first entry of sequence (included)
     * @param lastEntry
     *          id of last entry of sequence (included)
     *
     * @see #asyncReadEntries(long, long, org.apache.bookkeeper.client.AsyncCallback.ReadCallback, java.lang.Object)
     */
    public Enumeration&lt;LedgerEntry&gt; readEntries(long firstEntry, long lastEntry)
            throws InterruptedException, BKException {
<span class="fc" id="L529">        CompletableFuture&lt;Enumeration&lt;LedgerEntry&gt;&gt; result = new CompletableFuture&lt;&gt;();</span>

<span class="fc" id="L531">        asyncReadEntries(firstEntry, lastEntry, new SyncReadCallback(result), null);</span>

<span class="fc" id="L533">        return SyncCallbackUtils.waitForResult(result);</span>
    }

    /**
     * Read a sequence of entries synchronously, allowing to read after the LastAddConfirmed range.&lt;br&gt;
     * This is the same of
     * {@link #asyncReadUnconfirmedEntries(long, long, org.apache.bookkeeper.client.AsyncCallback.ReadCallback, java.lang.Object) }
     *
     * @param firstEntry
     *          id of first entry of sequence (included)
     * @param lastEntry
     *          id of last entry of sequence (included)
     *
     * @see #readEntries(long, long)
     * @see #asyncReadUnconfirmedEntries(long, long, org.apache.bookkeeper.client.AsyncCallback.ReadCallback, java.lang.Object)
     * @see #asyncReadLastConfirmed(org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback, java.lang.Object)
     */
    public Enumeration&lt;LedgerEntry&gt; readUnconfirmedEntries(long firstEntry, long lastEntry)
            throws InterruptedException, BKException {
<span class="nc" id="L552">        CompletableFuture&lt;Enumeration&lt;LedgerEntry&gt;&gt; result = new CompletableFuture&lt;&gt;();</span>

<span class="nc" id="L554">        asyncReadUnconfirmedEntries(firstEntry, lastEntry, new SyncReadCallback(result), null);</span>

<span class="nc" id="L556">        return SyncCallbackUtils.waitForResult(result);</span>
    }

    /**
     * Read a sequence of entries asynchronously.
     *
     * @param firstEntry
     *          id of first entry of sequence
     * @param lastEntry
     *          id of last entry of sequence
     * @param cb
     *          object implementing read callback interface
     * @param ctx
     *          control object
     */
    public void asyncReadEntries(long firstEntry, long lastEntry, ReadCallback cb, Object ctx) {
        // Little sanity check
<span class="fc bfc" id="L573" title="All 4 branches covered.">        if (firstEntry &lt; 0 || firstEntry &gt; lastEntry) {</span>
<span class="fc" id="L574">            LOG.error(&quot;IncorrectParameterException on ledgerId:{} firstEntry:{} lastEntry:{}&quot;,</span>
<span class="fc" id="L575">                    new Object[] { ledgerId, firstEntry, lastEntry });</span>
<span class="fc" id="L576">            cb.readComplete(BKException.Code.IncorrectParameterException, this, null, ctx);</span>
<span class="fc" id="L577">            return;</span>
        }

<span class="pc bpc" id="L580" title="1 of 2 branches missed.">        if (lastEntry &gt; lastAddConfirmed) {</span>
<span class="nc" id="L581">            LOG.error(&quot;ReadException on ledgerId:{} firstEntry:{} lastEntry:{}&quot;,</span>
<span class="nc" id="L582">                    new Object[] { ledgerId, firstEntry, lastEntry });</span>
<span class="nc" id="L583">            cb.readComplete(BKException.Code.ReadException, this, null, ctx);</span>
<span class="nc" id="L584">            return;</span>
        }

<span class="fc" id="L587">        asyncReadEntriesInternal(firstEntry, lastEntry, cb, ctx);</span>
<span class="fc" id="L588">    }</span>

    /**
     * Read a sequence of entries asynchronously, allowing to read after the LastAddConfirmed range.
     * &lt;br&gt;This is the same of
     * {@link #asyncReadEntries(long, long, org.apache.bookkeeper.client.AsyncCallback.ReadCallback, java.lang.Object) }
     * but it lets the client read without checking the local value of LastAddConfirmed, so that it is possibile to
     * read entries for which the writer has not received the acknowledge yet. &lt;br&gt;
     * For entries which are within the range 0..LastAddConfirmed BookKeeper guarantees that the writer has successfully
     * received the acknowledge.&lt;br&gt;
     * For entries outside that range it is possible that the writer never received the acknowledge
     * and so there is the risk that the reader is seeing entries before the writer and this could result in a consistency
     * issue in some cases.&lt;br&gt;
     * With this method you can even read entries before the LastAddConfirmed and entries after it with one call,
     * the expected consistency will be as described above for each subrange of ids.
     *
     * @param firstEntry
     *          id of first entry of sequence
     * @param lastEntry
     *          id of last entry of sequence
     * @param cb
     *          object implementing read callback interface
     * @param ctx
     *          control object
     *
     * @see #asyncReadEntries(long, long, org.apache.bookkeeper.client.AsyncCallback.ReadCallback, java.lang.Object)
     * @see #asyncReadLastConfirmed(org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback, java.lang.Object)
     * @see #readUnconfirmedEntries(long, long)
     */
    public void asyncReadUnconfirmedEntries(long firstEntry, long lastEntry, ReadCallback cb, Object ctx) {
        // Little sanity check
<span class="nc bnc" id="L619" title="All 4 branches missed.">        if (firstEntry &lt; 0 || firstEntry &gt; lastEntry) {</span>
<span class="nc" id="L620">            LOG.error(&quot;IncorrectParameterException on ledgerId:{} firstEntry:{} lastEntry:{}&quot;,</span>
<span class="nc" id="L621">                    new Object[] { ledgerId, firstEntry, lastEntry });</span>
<span class="nc" id="L622">            cb.readComplete(BKException.Code.IncorrectParameterException, this, null, ctx);</span>
<span class="nc" id="L623">            return;</span>
        }

<span class="nc" id="L626">        asyncReadEntriesInternal(firstEntry, lastEntry, cb, ctx);</span>
<span class="nc" id="L627">    }</span>

    /**
     * Read a sequence of entries asynchronously.
     *
     * @param firstEntry
     *          id of first entry of sequence
     * @param lastEntry
     *          id of last entry of sequence
     */
    @Override
    public CompletableFuture&lt;LedgerEntries&gt; read(long firstEntry, long lastEntry) {
        // Little sanity check
<span class="nc bnc" id="L640" title="All 4 branches missed.">        if (firstEntry &lt; 0 || firstEntry &gt; lastEntry) {</span>
<span class="nc" id="L641">            LOG.error(&quot;IncorrectParameterException on ledgerId:{} firstEntry:{} lastEntry:{}&quot;,</span>
<span class="nc" id="L642">                    new Object[] { ledgerId, firstEntry, lastEntry });</span>
<span class="nc" id="L643">            return FutureUtils.exception(new BKIncorrectParameterException());</span>
        }

<span class="nc bnc" id="L646" title="All 2 branches missed.">        if (lastEntry &gt; lastAddConfirmed) {</span>
<span class="nc" id="L647">            LOG.error(&quot;ReadException on ledgerId:{} firstEntry:{} lastEntry:{}&quot;,</span>
<span class="nc" id="L648">                    new Object[] { ledgerId, firstEntry, lastEntry });</span>
<span class="nc" id="L649">            return FutureUtils.exception(new BKReadException());</span>
        }

<span class="nc" id="L652">        return readEntriesInternalAsync(firstEntry, lastEntry);</span>
    }

    /**
     * Read a sequence of entries asynchronously, allowing to read after the LastAddConfirmed range.
     * &lt;br&gt;This is the same of
     * {@link #asyncReadEntries(long, long, org.apache.bookkeeper.client.AsyncCallback.ReadCallback, java.lang.Object) }
     * but it lets the client read without checking the local value of LastAddConfirmed, so that it is possibile to
     * read entries for which the writer has not received the acknowledge yet. &lt;br&gt;
     * For entries which are within the range 0..LastAddConfirmed BookKeeper guarantees that the writer has successfully
     * received the acknowledge.&lt;br&gt;
     * For entries outside that range it is possible that the writer never received the acknowledge
     * and so there is the risk that the reader is seeing entries before the writer and this could result in a consistency
     * issue in some cases.&lt;br&gt;
     * With this method you can even read entries before the LastAddConfirmed and entries after it with one call,
     * the expected consistency will be as described above for each subrange of ids.
     *
     * @param firstEntry
     *          id of first entry of sequence
     * @param lastEntry
     *          id of last entry of sequence
     *
     * @see #asyncReadEntries(long, long, org.apache.bookkeeper.client.AsyncCallback.ReadCallback, java.lang.Object)
     * @see #asyncReadLastConfirmed(org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback, java.lang.Object)
     * @see #readUnconfirmedEntries(long, long)
     */
    @Override
    public CompletableFuture&lt;LedgerEntries&gt; readUnconfirmed(long firstEntry, long lastEntry) {
        // Little sanity check
<span class="nc bnc" id="L681" title="All 4 branches missed.">        if (firstEntry &lt; 0 || firstEntry &gt; lastEntry) {</span>
<span class="nc" id="L682">            LOG.error(&quot;IncorrectParameterException on ledgerId:{} firstEntry:{} lastEntry:{}&quot;,</span>
<span class="nc" id="L683">                    new Object[] { ledgerId, firstEntry, lastEntry });</span>
<span class="nc" id="L684">            return FutureUtils.exception(new BKIncorrectParameterException());</span>
        }

<span class="nc" id="L687">        return readEntriesInternalAsync(firstEntry, lastEntry);</span>
    }

    void asyncReadEntriesInternal(long firstEntry, long lastEntry, ReadCallback cb, Object ctx) {
<span class="pc bpc" id="L691" title="1 of 2 branches missed.">        if(!bk.isClosed()) {</span>
<span class="fc" id="L692">            readEntriesInternalAsync(firstEntry, lastEntry)</span>
<span class="fc" id="L693">                .whenCompleteAsync(new FutureEventListener&lt;LedgerEntries&gt;() {</span>
                    @Override
                    public void onSuccess(LedgerEntries entries) {
<span class="fc" id="L696">                        cb.readComplete(</span>
                            Code.OK,
                            LedgerHandle.this,
<span class="fc" id="L699">                            IteratorUtils.asEnumeration(</span>
<span class="fc" id="L700">                                Iterators.transform(entries.iterator(), le -&gt; {</span>
<span class="fc" id="L701">                                    LedgerEntry entry = new LedgerEntry((LedgerEntryImpl) le);</span>
<span class="fc" id="L702">                                    le.close();</span>
<span class="fc" id="L703">                                    return entry;</span>
                                })),
                            ctx);
<span class="fc" id="L706">                    }</span>

                    @Override
                    public void onFailure(Throwable cause) {
<span class="nc bnc" id="L710" title="All 2 branches missed.">                        if (cause instanceof BKException) {</span>
<span class="nc" id="L711">                            BKException bke = (BKException) cause;</span>
<span class="nc" id="L712">                            cb.readComplete(bke.getCode(), LedgerHandle.this, null, ctx);</span>
<span class="nc" id="L713">                        } else {</span>
<span class="nc" id="L714">                            cb.readComplete(Code.UnexpectedConditionException, LedgerHandle.this, null, ctx);</span>
                        }
<span class="nc" id="L716">                    }</span>
<span class="fc" id="L717">                }, bk.getMainWorkerPool().chooseThread(ledgerId));</span>
        } else {
<span class="nc" id="L719">            cb.readComplete(Code.ClientClosedException, LedgerHandle.this, null, ctx);</span>
        }
<span class="fc" id="L721">    }</span>

    CompletableFuture&lt;LedgerEntries&gt; readEntriesInternalAsync(long firstEntry,
                                                              long lastEntry) {
<span class="fc" id="L725">        PendingReadOp op = new PendingReadOp(this, bk.getScheduler(), firstEntry, lastEntry);</span>
<span class="pc bpc" id="L726" title="1 of 2 branches missed.">        if(!bk.isClosed()) {</span>
<span class="fc" id="L727">            bk.getMainWorkerPool().submitOrdered(ledgerId, op);</span>
        } else {
<span class="nc" id="L729">            op.future().completeExceptionally(BKException.create(ClientClosedException));</span>
        }
<span class="fc" id="L731">        return op.future();</span>
    }

    /**
     * Add entry synchronously to an open ledger.
     *
     * @param data
     *         array of bytes to be written to the ledger
     * @return the entryId of the new inserted entry
     */
    public long addEntry(byte[] data) throws InterruptedException, BKException {
<span class="nc" id="L742">        return addEntry(data, 0, data.length);</span>
    }

    /**
     * {@inheritDoc }
     */
    @Override
    public CompletableFuture&lt;Long&gt; append(ByteBuf data) {
<span class="nc" id="L750">        SyncAddCallback callback = new SyncAddCallback();</span>
<span class="nc" id="L751">        asyncAddEntry(data, callback, null);</span>
<span class="nc" id="L752">        return callback;</span>
    }

    /**
     * Add entry synchronously to an open ledger. This can be used only with
     * {@link LedgerHandleAdv} returned through ledgers created with {@link
     * BookKeeper#createLedgerAdv(int, int, int, DigestType, byte[])}.
     *
     *
     * @param entryId
     *            entryId to be added
     * @param data
     *            array of bytes to be written to the ledger
     * @return the entryId of the new inserted entry
     */
    public long addEntry(final long entryId, byte[] data) throws InterruptedException, BKException {
<span class="nc" id="L768">        LOG.error(&quot;To use this feature Ledger must be created with createLedgerAdv interface.&quot;);</span>
<span class="nc" id="L769">        throw BKException.create(BKException.Code.IllegalOpException);</span>
    }

    /**
     * Add entry synchronously to an open ledger.
     *
     * @param data
     *         array of bytes to be written to the ledger
     * @param offset
     *          offset from which to take bytes from data
     * @param length
     *          number of bytes to take from data
     * @return the entryId of the new inserted entry
     */
    public long addEntry(byte[] data, int offset, int length)
            throws InterruptedException, BKException {
<span class="pc bpc" id="L785" title="1 of 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L786">            LOG.debug(&quot;Adding entry {}&quot;, data);</span>
        }

<span class="fc" id="L789">        SyncAddCallback callback = new SyncAddCallback();</span>
<span class="fc" id="L790">        asyncAddEntry(data, offset, length, callback, null);</span>

<span class="fc" id="L792">        return SyncCallbackUtils.waitForResult(callback);</span>
    }

    /**
     * Add entry synchronously to an open ledger. This can be used only with
     * {@link LedgerHandleAdv} returned through ledgers created with {@link
     * BookKeeper#createLedgerAdv(int, int, int, DigestType, byte[])}.
     *
     * @param entryId
     *            entryId to be added.
     * @param data
     *            array of bytes to be written to the ledger
     * @param offset
     *            offset from which to take bytes from data
     * @param length
     *            number of bytes to take from data
     * @return entryId
     */
    public long addEntry(final long entryId, byte[] data, int offset, int length) throws InterruptedException,
            BKException {
<span class="nc" id="L812">        LOG.error(&quot;To use this feature Ledger must be created with createLedgerAdv() interface.&quot;);</span>
<span class="nc" id="L813">        throw BKException.create(BKException.Code.IllegalOpException);</span>
    }

    /**
     * Add entry asynchronously to an open ledger.
     *
     * @param data
     *          array of bytes to be written
     * @param cb
     *          object implementing callbackinterface
     * @param ctx
     *          some control object
     */
    public void asyncAddEntry(final byte[] data, final AddCallback cb,
                              final Object ctx) {
<span class="nc" id="L828">        asyncAddEntry(data, 0, data.length, cb, ctx);</span>
<span class="nc" id="L829">    }</span>

    /**
     * Add entry asynchronously to an open ledger. This can be used only with
     * {@link LedgerHandleAdv} returned through ledgers created with {@link
     * BookKeeper#createLedgerAdv(int, int, int, DigestType, byte[])}.
     *
     * @param entryId
     *            entryId to be added
     * @param data
     *            array of bytes to be written
     * @param cb
     *            object implementing callbackinterface
     * @param ctx
     *            some control object
     */
    public void asyncAddEntry(final long entryId, final byte[] data, final AddCallback cb, final Object ctx) {
<span class="nc" id="L846">        LOG.error(&quot;To use this feature Ledger must be created with createLedgerAdv() interface.&quot;);</span>
<span class="nc" id="L847">        cb.addComplete(BKException.Code.IllegalOpException, LedgerHandle.this, entryId, ctx);</span>
<span class="nc" id="L848">    }</span>

    /**
     * Add entry asynchronously to an open ledger, using an offset and range.
     *
     * @param data
     *          array of bytes to be written
     * @param offset
     *          offset from which to take bytes from data
     * @param length
     *          number of bytes to take from data
     * @param cb
     *          object implementing callbackinterface
     * @param ctx
     *          some control object
     * @throws ArrayIndexOutOfBoundsException if offset or length is negative or
     *          offset and length sum to a value higher than the length of data.
     */
    public void asyncAddEntry(final byte[] data, final int offset, final int length,
                              final AddCallback cb, final Object ctx) {
<span class="fc bfc" id="L868" title="All 6 branches covered.">        if (offset &lt; 0 || length &lt; 0</span>
                || (offset + length) &gt; data.length) {
<span class="fc" id="L870">            throw new ArrayIndexOutOfBoundsException(</span>
                    &quot;Invalid values for offset(&quot;+offset
                    +&quot;) or length(&quot;+length+&quot;)&quot;);
        }

<span class="fc" id="L875">        asyncAddEntry(Unpooled.wrappedBuffer(data, offset, length), cb, ctx);</span>
<span class="fc" id="L876">    }</span>

    public void asyncAddEntry(ByteBuf data, final AddCallback cb, final Object ctx) {
<span class="fc" id="L879">        data.retain();</span>
<span class="fc" id="L880">        PendingAddOp op = PendingAddOp.create(this, data, cb, ctx);</span>
<span class="fc" id="L881">        doAsyncAddEntry(op);</span>
<span class="fc" id="L882">    }</span>

    /**
     * Add entry asynchronously to an open ledger, using an offset and range.
     * This can be used only with {@link LedgerHandleAdv} returned through
     * ledgers created with {@link BookKeeper#createLedgerAdv(int, int, int, DigestType, byte[])}.
     *
     * @param entryId
     *            entryId of the entry to add.
     * @param data
     *            array of bytes to be written
     * @param offset
     *            offset from which to take bytes from data
     * @param length
     *            number of bytes to take from data
     * @param cb
     *            object implementing callbackinterface
     * @param ctx
     *            some control object
     * @throws ArrayIndexOutOfBoundsException
     *             if offset or length is negative or offset and length sum to a
     *             value higher than the length of data.
     */
    public void asyncAddEntry(final long entryId, final byte[] data, final int offset, final int length,
            final AddCallback cb, final Object ctx) throws BKException {
<span class="nc" id="L907">        LOG.error(&quot;To use this feature Ledger must be created with createLedgerAdv() interface.&quot;);</span>
<span class="nc" id="L908">        cb.addComplete(BKException.Code.IllegalOpException, LedgerHandle.this, entryId, ctx);</span>
<span class="nc" id="L909">    }</span>

    /**
     * Make a recovery add entry request. Recovery adds can add to a ledger even
     * if it has been fenced.
     *
     * This is only valid for bookie and ledger recovery, which may need to replicate
     * entries to a quorum of bookies to ensure data safety.
     *
     * Normal client should never call this method.
     */
    void asyncRecoveryAddEntry(final byte[] data, final int offset, final int length,
                               final AddCallback cb, final Object ctx) {
<span class="nc" id="L922">        PendingAddOp op = PendingAddOp.create(this, Unpooled.wrappedBuffer(data, offset, length), cb, ctx)</span>
<span class="nc" id="L923">                .enableRecoveryAdd();</span>
<span class="nc" id="L924">        doAsyncAddEntry(op);</span>
<span class="nc" id="L925">    }</span>

    protected void doAsyncAddEntry(final PendingAddOp op) {
<span class="pc bpc" id="L928" title="1 of 2 branches missed.">        if (throttler != null) {</span>
<span class="fc" id="L929">            throttler.acquire();</span>
        }

<span class="fc" id="L932">        boolean wasClosed = false;</span>
<span class="fc" id="L933">        synchronized(this) {</span>
            // synchronized on this to ensure that
            // the ledger isn't closed between checking and
            // updating lastAddPushed
<span class="pc bpc" id="L937" title="1 of 2 branches missed.">            if (metadata.isClosed()) {</span>
<span class="nc" id="L938">                wasClosed = true;</span>
            } else {
<span class="fc" id="L940">                long entryId = ++lastAddPushed;</span>
<span class="fc" id="L941">                long currentLedgerLength = addToLength(op.payload.readableBytes());</span>
<span class="fc" id="L942">                op.setEntryId(entryId);</span>
<span class="fc" id="L943">                op.setLedgerLength(currentLedgerLength);</span>
<span class="fc" id="L944">                pendingAddOps.add(op);</span>
            }
<span class="fc" id="L946">        }</span>

<span class="pc bpc" id="L948" title="1 of 2 branches missed.">        if (wasClosed) {</span>
            // make sure the callback is triggered in main worker pool
            try {
<span class="nc" id="L951">                bk.getMainWorkerPool().submit(new SafeRunnable() {</span>
                    @Override
                    public void safeRun() {
<span class="nc" id="L954">                        LOG.warn(&quot;Attempt to add to closed ledger: {}&quot;, ledgerId);</span>
<span class="nc" id="L955">                        op.cb.addComplete(BKException.Code.LedgerClosedException,</span>
                                LedgerHandle.this, INVALID_ENTRY_ID, op.ctx);
<span class="nc" id="L957">                    }</span>

                    @Override
                    public String toString() {
<span class="nc" id="L961">                        return String.format(&quot;AsyncAddEntryToClosedLedger(lid=%d)&quot;, ledgerId);</span>
                    }
                });
<span class="nc" id="L964">            } catch (RejectedExecutionException e) {</span>
<span class="nc" id="L965">                op.cb.addComplete(bk.getReturnRc(BKException.Code.InterruptedException),</span>
                        LedgerHandle.this, INVALID_ENTRY_ID, op.ctx);
<span class="nc" id="L967">            }</span>
<span class="nc" id="L968">            return;</span>
        }

        try {
<span class="fc" id="L972">            bk.getMainWorkerPool().submitOrdered(ledgerId, op);</span>
<span class="nc" id="L973">        } catch (RejectedExecutionException e) {</span>
<span class="nc" id="L974">            op.cb.addComplete(bk.getReturnRc(BKException.Code.InterruptedException),</span>
                    LedgerHandle.this, INVALID_ENTRY_ID, op.ctx);
<span class="fc" id="L976">        }</span>
<span class="fc" id="L977">    }</span>

    synchronized void updateLastConfirmed(long lac, long len) {
<span class="pc bpc" id="L980" title="1 of 2 branches missed.">        if (lac &gt; lastAddConfirmed) {</span>
<span class="nc" id="L981">            lastAddConfirmed = lac;</span>
<span class="nc" id="L982">            lacUpdateHitsCounter.inc();</span>
        } else {
<span class="fc" id="L984">            lacUpdateMissesCounter.inc();</span>
        }
<span class="fc" id="L986">        lastAddPushed = Math.max(lastAddPushed, lac);</span>
<span class="fc" id="L987">        length = Math.max(length, len);</span>
<span class="fc" id="L988">    }</span>

    /**
     * Obtains asynchronously the last confirmed write from a quorum of bookies. This
     * call obtains the the last add confirmed each bookie has received for this ledger
     * and returns the maximum. If the ledger has been closed, the value returned by this
     * call may not correspond to the id of the last entry of the ledger, since it reads
     * the hint of bookies. Consequently, in the case the ledger has been closed, it may
     * return a different value than getLastAddConfirmed, which returns the local value
     * of the ledger handle.
     *
     * @see #getLastAddConfirmed()
     *
     * @param cb
     * @param ctx
     */

    public void asyncReadLastConfirmed(final ReadLastConfirmedCallback cb, final Object ctx) {
        boolean isClosed;
        long lastEntryId;
<span class="nc" id="L1008">        synchronized (this) {</span>
<span class="nc" id="L1009">            isClosed = metadata.isClosed();</span>
<span class="nc" id="L1010">            lastEntryId = metadata.getLastEntryId();</span>
<span class="nc" id="L1011">        }</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">        if (isClosed) {</span>
<span class="nc" id="L1013">            cb.readLastConfirmedComplete(BKException.Code.OK, lastEntryId, ctx);</span>
<span class="nc" id="L1014">            return;</span>
        }
<span class="nc" id="L1016">        ReadLastConfirmedOp.LastConfirmedDataCallback innercb = new ReadLastConfirmedOp.LastConfirmedDataCallback() {</span>
                @Override
                public void readLastConfirmedDataComplete(int rc, DigestManager.RecoveryData data) {
<span class="nc bnc" id="L1019" title="All 2 branches missed.">                    if (rc == BKException.Code.OK) {</span>
<span class="nc" id="L1020">                        updateLastConfirmed(data.lastAddConfirmed, data.length);</span>
<span class="nc" id="L1021">                        cb.readLastConfirmedComplete(rc, data.lastAddConfirmed, ctx);</span>
                    } else {
<span class="nc" id="L1023">                        cb.readLastConfirmedComplete(rc, INVALID_ENTRY_ID, ctx);</span>
                    }
<span class="nc" id="L1025">                }</span>
            };
<span class="nc" id="L1027">        new ReadLastConfirmedOp(this, innercb).initiate();</span>
<span class="nc" id="L1028">    }</span>

    /**
     * Obtains asynchronously the last confirmed write from a quorum of bookies.
     * It is similar as
     * {@link #asyncReadLastConfirmed(org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback, Object)},
     * but it doesn't wait all the responses from the quorum. It would callback
     * immediately if it received a LAC which is larger than current LAC.
     *
     * @see #asyncTryReadLastConfirmed(org.apache.bookkeeper.client.AsyncCallback.ReadLastConfirmedCallback, Object)
     *
     * @param cb
     *          callback to return read last confirmed
     * @param ctx
     *          callback context
     */
    public void asyncTryReadLastConfirmed(final ReadLastConfirmedCallback cb, final Object ctx) {
        boolean isClosed;
        long lastEntryId;
<span class="nc" id="L1047">        synchronized (this) {</span>
<span class="nc" id="L1048">            isClosed = metadata.isClosed();</span>
<span class="nc" id="L1049">            lastEntryId = metadata.getLastEntryId();</span>
<span class="nc" id="L1050">        }</span>
<span class="nc bnc" id="L1051" title="All 2 branches missed.">        if (isClosed) {</span>
<span class="nc" id="L1052">            cb.readLastConfirmedComplete(BKException.Code.OK, lastEntryId, ctx);</span>
<span class="nc" id="L1053">            return;</span>
        }
<span class="nc" id="L1055">        ReadLastConfirmedOp.LastConfirmedDataCallback innercb = new ReadLastConfirmedOp.LastConfirmedDataCallback() {</span>
<span class="nc" id="L1056">            AtomicBoolean completed = new AtomicBoolean(false);</span>

            @Override
            public void readLastConfirmedDataComplete(int rc, DigestManager.RecoveryData data) {
<span class="nc bnc" id="L1060" title="All 2 branches missed.">                if (rc == BKException.Code.OK) {</span>
<span class="nc" id="L1061">                    updateLastConfirmed(data.lastAddConfirmed, data.length);</span>
<span class="nc bnc" id="L1062" title="All 2 branches missed.">                    if (completed.compareAndSet(false, true)) {</span>
<span class="nc" id="L1063">                        cb.readLastConfirmedComplete(rc, data.lastAddConfirmed, ctx);</span>
                    }
                } else {
<span class="nc bnc" id="L1066" title="All 2 branches missed.">                    if (completed.compareAndSet(false, true)) {</span>
<span class="nc" id="L1067">                        cb.readLastConfirmedComplete(rc, INVALID_ENTRY_ID, ctx);</span>
                    }
                }
<span class="nc" id="L1070">            }</span>
        };
<span class="nc" id="L1072">        new TryReadLastConfirmedOp(this, innercb, getLastAddConfirmed()).initiate();</span>
<span class="nc" id="L1073">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public CompletableFuture&lt;Long&gt; tryReadLastAddConfirmed() {
<span class="nc" id="L1080">        FutureReadLastConfirmed result = new FutureReadLastConfirmed();</span>
<span class="nc" id="L1081">        asyncTryReadLastConfirmed(result, null);</span>
<span class="nc" id="L1082">        return result;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CompletableFuture&lt;Long&gt; readLastAddConfirmed() {
<span class="nc" id="L1090">        FutureReadLastConfirmed result = new FutureReadLastConfirmed();</span>
<span class="nc" id="L1091">        asyncReadLastConfirmed(result, null);</span>
<span class="nc" id="L1092">        return result;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CompletableFuture&lt;LastConfirmedAndEntry&gt; readLastAddConfirmedAndEntry(long entryId,
                                                                                 long timeOutInMillis,
                                                                                 boolean parallel) {
<span class="nc" id="L1102">        FutureReadLastConfirmedAndEntry result = new FutureReadLastConfirmedAndEntry();</span>
<span class="nc" id="L1103">        asyncReadLastConfirmedAndEntry(entryId, timeOutInMillis, parallel, result, null);</span>
<span class="nc" id="L1104">        return result;</span>
    }

    /**
     * Asynchronous read next entry and the latest last add confirmed.
     * If the next entryId is less than known last add confirmed, the call will read next entry directly.
     * If the next entryId is ahead of known last add confirmed, the call will issue a long poll read
     * to wait for the next entry &lt;i&gt;entryId&lt;/i&gt;.
     *
     * The callback will return the latest last add confirmed and next entry if it is available within timeout period &lt;i&gt;timeOutInMillis&lt;/i&gt;.
     *
     * @param entryId
     *          next entry id to read
     * @param timeOutInMillis
     *          timeout period to wait for the entry id to be available (for long poll only)
     * @param parallel
     *          whether to issue the long poll reads in parallel
     * @param cb
     *          callback to return the result
     * @param ctx
     *          callback context
     */
    public void asyncReadLastConfirmedAndEntry(final long entryId,
                                               final long timeOutInMillis,
                                               final boolean parallel,
                                               final AsyncCallback.ReadLastConfirmedAndEntryCallback cb,
                                               final Object ctx) {
        boolean isClosed;
        long lac;
<span class="nc" id="L1133">        synchronized (this) {</span>
<span class="nc" id="L1134">            isClosed = metadata.isClosed();</span>
<span class="nc" id="L1135">            lac = metadata.getLastEntryId();</span>
<span class="nc" id="L1136">        }</span>
<span class="nc bnc" id="L1137" title="All 2 branches missed.">        if (isClosed) {</span>
<span class="nc bnc" id="L1138" title="All 2 branches missed.">            if (entryId &gt; lac) {</span>
<span class="nc" id="L1139">                cb.readLastConfirmedAndEntryComplete(BKException.Code.OK, lac, null, ctx);</span>
<span class="nc" id="L1140">                return;</span>
            }
        } else {
<span class="nc" id="L1143">            lac = getLastAddConfirmed();</span>
        }
<span class="nc bnc" id="L1145" title="All 2 branches missed.">        if (entryId &lt;= lac) {</span>
<span class="nc" id="L1146">            asyncReadEntries(entryId, entryId, new ReadCallback() {</span>
                @Override
                public void readComplete(int rc, LedgerHandle lh, Enumeration&lt;LedgerEntry&gt; seq, Object ctx) {
<span class="nc bnc" id="L1149" title="All 2 branches missed.">                    if (BKException.Code.OK == rc) {</span>
<span class="nc bnc" id="L1150" title="All 2 branches missed.">                        if (seq.hasMoreElements()) {</span>
<span class="nc" id="L1151">                            cb.readLastConfirmedAndEntryComplete(rc, getLastAddConfirmed(), seq.nextElement(), ctx);</span>
                        } else {
<span class="nc" id="L1153">                            cb.readLastConfirmedAndEntryComplete(rc, getLastAddConfirmed(), null, ctx);</span>
                        }
                    } else {
<span class="nc" id="L1156">                        cb.readLastConfirmedAndEntryComplete(rc, INVALID_ENTRY_ID, null, ctx);</span>
                    }
<span class="nc" id="L1158">                }</span>
            }, ctx);
<span class="nc" id="L1160">            return;</span>
        }
        // wait for entry &lt;i&gt;entryId&lt;/i&gt;
<span class="nc" id="L1163">        ReadLastConfirmedAndEntryOp.LastConfirmedAndEntryCallback innercb =</span>
<span class="nc" id="L1164">            new ReadLastConfirmedAndEntryOp.LastConfirmedAndEntryCallback() {</span>
<span class="nc" id="L1165">            AtomicBoolean completed = new AtomicBoolean(false);</span>
            @Override
            public void readLastConfirmedAndEntryComplete(int rc, long lastAddConfirmed, LedgerEntry entry) {
<span class="nc bnc" id="L1168" title="All 2 branches missed.">                if (rc == BKException.Code.OK) {</span>
<span class="nc bnc" id="L1169" title="All 2 branches missed.">                    if (completed.compareAndSet(false, true)) {</span>
<span class="nc" id="L1170">                        cb.readLastConfirmedAndEntryComplete(rc, lastAddConfirmed, entry, ctx);</span>
                    }
                } else {
<span class="nc bnc" id="L1173" title="All 2 branches missed.">                    if (completed.compareAndSet(false, true)) {</span>
<span class="nc" id="L1174">                        cb.readLastConfirmedAndEntryComplete(rc, INVALID_ENTRY_ID, null, ctx);</span>
                    }
                }
<span class="nc" id="L1177">            }</span>
        };
<span class="nc" id="L1179">        new ReadLastConfirmedAndEntryOp(this,</span>
            innercb,
            entryId - 1,
            timeOutInMillis,
<span class="nc" id="L1183">            bk.getScheduler())</span>
<span class="nc" id="L1184">            .parallelRead(parallel)</span>
<span class="nc" id="L1185">            .initiate();</span>
<span class="nc" id="L1186">    }</span>

    /**
     * Context objects for synchronous call to read last confirmed.
     */
    static class LastConfirmedCtx {
        final static long ENTRY_ID_PENDING = -10;
        long response;
        int rc;

<span class="nc" id="L1196">        LastConfirmedCtx() {</span>
<span class="nc" id="L1197">            this.response = ENTRY_ID_PENDING;</span>
<span class="nc" id="L1198">        }</span>

        void setLastConfirmed(long lastConfirmed) {
<span class="nc" id="L1201">            this.response = lastConfirmed;</span>
<span class="nc" id="L1202">        }</span>

        long getlastConfirmed() {
<span class="nc" id="L1205">            return this.response;</span>
        }

        void setRC(int rc) {
<span class="nc" id="L1209">            this.rc = rc;</span>
<span class="nc" id="L1210">        }</span>

        int getRC() {
<span class="nc" id="L1213">            return this.rc;</span>
        }

        boolean ready() {
<span class="nc bnc" id="L1217" title="All 2 branches missed.">            return (this.response != ENTRY_ID_PENDING);</span>
        }
    }

    /**
     * Obtains synchronously the last confirmed write from a quorum of bookies. This call
     * obtains the the last add confirmed each bookie has received for this ledger
     * and returns the maximum. If the ledger has been closed, the value returned by this
     * call may not correspond to the id of the last entry of the ledger, since it reads
     * the hint of bookies. Consequently, in the case the ledger has been closed, it may
     * return a different value than getLastAddConfirmed, which returns the local value
     * of the ledger handle.
     *
     * @see #getLastAddConfirmed()
     *
     * @return The entry id of the last confirmed write or {@link #INVALID_ENTRY_ID INVALID_ENTRY_ID}
     *         if no entry has been confirmed
     * @throws InterruptedException
     * @throws BKException
     */
    public long readLastConfirmed()
            throws InterruptedException, BKException {
<span class="nc" id="L1239">        LastConfirmedCtx ctx = new LastConfirmedCtx();</span>
<span class="nc" id="L1240">        asyncReadLastConfirmed(new SyncReadLastConfirmedCallback(), ctx);</span>
<span class="nc" id="L1241">        synchronized(ctx) {</span>
<span class="nc bnc" id="L1242" title="All 2 branches missed.">            while(!ctx.ready()) {</span>
<span class="nc" id="L1243">                ctx.wait();</span>
            }
<span class="nc" id="L1245">        }</span>

<span class="nc bnc" id="L1247" title="All 2 branches missed.">        if(ctx.getRC() != BKException.Code.OK) throw BKException.create(ctx.getRC());</span>
<span class="nc" id="L1248">        return ctx.getlastConfirmed();</span>
    }

    /**
     * Obtains synchronously the last confirmed write from a quorum of bookies.
     * It is similar as {@link #readLastConfirmed()}, but it doesn't wait all the responses
     * from the quorum. It would callback immediately if it received a LAC which is larger
     * than current LAC.
     *
     * @see #readLastConfirmed()
     *
     * @return The entry id of the last confirmed write or {@link #INVALID_ENTRY_ID INVALID_ENTRY_ID}
     *         if no entry has been confirmed
     * @throws InterruptedException
     * @throws BKException
     */
    public long tryReadLastConfirmed() throws InterruptedException, BKException {
<span class="nc" id="L1265">        LastConfirmedCtx ctx = new LastConfirmedCtx();</span>
<span class="nc" id="L1266">        asyncTryReadLastConfirmed(new SyncReadLastConfirmedCallback(), ctx);</span>
<span class="nc" id="L1267">        synchronized (ctx) {</span>
<span class="nc bnc" id="L1268" title="All 2 branches missed.">            while (!ctx.ready()) {</span>
<span class="nc" id="L1269">                ctx.wait();</span>
            }
<span class="nc" id="L1271">        }</span>
<span class="nc bnc" id="L1272" title="All 2 branches missed.">        if (ctx.getRC() != BKException.Code.OK) throw BKException.create(ctx.getRC());</span>
<span class="nc" id="L1273">        return ctx.getlastConfirmed();</span>
    }

    /**
     * Obtains asynchronously the explicit last add confirmed from a quorum of
     * bookies. This call obtains the the explicit last add confirmed each
     * bookie has received for this ledger and returns the maximum. If in the
     * write LedgerHandle, explicitLAC feature is not enabled then this will
     * return {@link #INVALID_ENTRY_ID INVALID_ENTRY_ID}. If the read explicit
     * lastaddconfirmed is greater than getLastAddConfirmed, then it updates the
     * lastAddConfirmed of this ledgerhandle. If the ledger has been closed, it
     * returns the value of the last add confirmed from the metadata.
     *
     * @see #getLastAddConfirmed()
     *
     * @param cb
     *          callback to return read explicit last confirmed
     * @param ctx
     *          callback context
     */
    public void asyncReadExplicitLastConfirmed(final ReadLastConfirmedCallback cb, final Object ctx) {
        boolean isClosed;
<span class="nc" id="L1295">        synchronized (this) {</span>
<span class="nc" id="L1296">            isClosed = metadata.isClosed();</span>
<span class="nc bnc" id="L1297" title="All 2 branches missed.">            if (isClosed) {</span>
<span class="nc" id="L1298">                lastAddConfirmed = metadata.getLastEntryId();</span>
<span class="nc" id="L1299">                length = metadata.getLength();</span>
            }
<span class="nc" id="L1301">        }</span>
<span class="nc bnc" id="L1302" title="All 2 branches missed.">        if (isClosed) {</span>
<span class="nc" id="L1303">            cb.readLastConfirmedComplete(BKException.Code.OK, lastAddConfirmed, ctx);</span>
<span class="nc" id="L1304">            return;</span>
        }

<span class="nc" id="L1307">        PendingReadLacOp.LacCallback innercb = new PendingReadLacOp.LacCallback() {</span>

            @Override
            public void getLacComplete(int rc, long lac) {
<span class="nc bnc" id="L1311" title="All 2 branches missed.">                if (rc == BKException.Code.OK) {</span>
                    // here we are trying to update lac only but not length
<span class="nc" id="L1313">                    updateLastConfirmed(lac, 0);</span>
<span class="nc" id="L1314">                    cb.readLastConfirmedComplete(rc, lac, ctx);</span>
                } else {
<span class="nc" id="L1316">                    cb.readLastConfirmedComplete(rc, INVALID_ENTRY_ID, ctx);</span>
                }
<span class="nc" id="L1318">            }</span>
        };
<span class="nc" id="L1320">        new PendingReadLacOp(this, innercb).initiate();</span>
<span class="nc" id="L1321">    }</span>

    /**
     * Obtains synchronously the explicit last add confirmed from a quorum of
     * bookies. This call obtains the the explicit last add confirmed each
     * bookie has received for this ledger and returns the maximum. If in the
     * write LedgerHandle, explicitLAC feature is not enabled then this will
     * return {@link #INVALID_ENTRY_ID INVALID_ENTRY_ID}. If the read explicit
     * lastaddconfirmed is greater than getLastAddConfirmed, then it updates the
     * lastAddConfirmed of this ledgerhandle. If the ledger has been closed, it
     * returns the value of the last add confirmed from the metadata.
     *
     * @see #getLastAddConfirmed()
     *
     * @return The entry id of the explicit last confirmed write or
     *         {@link #INVALID_ENTRY_ID INVALID_ENTRY_ID} if no entry has been
     *         confirmed or if explicitLAC feature is not enabled in write
     *         LedgerHandle.
     * @throws InterruptedException
     * @throws BKException
     */
    public long readExplicitLastConfirmed() throws InterruptedException, BKException {
<span class="nc" id="L1343">        LastConfirmedCtx ctx = new LastConfirmedCtx();</span>
<span class="nc" id="L1344">        asyncReadExplicitLastConfirmed(new SyncReadLastConfirmedCallback(), ctx);</span>
<span class="nc" id="L1345">        synchronized (ctx) {</span>
<span class="nc bnc" id="L1346" title="All 2 branches missed.">            while (!ctx.ready()) {</span>
<span class="nc" id="L1347">                ctx.wait();</span>
            }
<span class="nc" id="L1349">        }</span>
<span class="nc bnc" id="L1350" title="All 2 branches missed.">        if (ctx.getRC() != BKException.Code.OK) {</span>
<span class="nc" id="L1351">            throw BKException.create(ctx.getRC());</span>
        }
<span class="nc" id="L1353">        return ctx.getlastConfirmed();</span>
    }

    // close the ledger and send fails to all the adds in the pipeline
    void handleUnrecoverableErrorDuringAdd(int rc) {
<span class="nc bnc" id="L1358" title="All 2 branches missed.">        if (metadata.isInRecovery()) {</span>
            // we should not close ledger if ledger is recovery mode
            // otherwise we may lose entry.
<span class="nc" id="L1361">            errorOutPendingAdds(rc);</span>
<span class="nc" id="L1362">            return;</span>
        }
<span class="nc" id="L1364">        LOG.error(&quot;Closing ledger {} due to error {}&quot;, ledgerId, rc);</span>
<span class="nc" id="L1365">        asyncCloseInternal(NoopCloseCallback.instance, null, rc);</span>
<span class="nc" id="L1366">    }</span>

    void errorOutPendingAdds(int rc) {
<span class="nc" id="L1369">        errorOutPendingAdds(rc, drainPendingAddsToErrorOut());</span>
<span class="nc" id="L1370">    }</span>

    synchronized List&lt;PendingAddOp&gt; drainPendingAddsToErrorOut() {
        PendingAddOp pendingAddOp;
<span class="fc" id="L1374">        List&lt;PendingAddOp&gt; opsDrained = new ArrayList&lt;PendingAddOp&gt;(pendingAddOps.size());</span>
<span class="pc bpc" id="L1375" title="1 of 2 branches missed.">        while ((pendingAddOp = pendingAddOps.poll()) != null) {</span>
<span class="nc" id="L1376">            addToLength(-pendingAddOp.entryLength);</span>
<span class="nc" id="L1377">            opsDrained.add(pendingAddOp);</span>
        }
<span class="fc" id="L1379">        return opsDrained;</span>
    }

    void errorOutPendingAdds(int rc, List&lt;PendingAddOp&gt; ops) {
<span class="pc bpc" id="L1383" title="1 of 2 branches missed.">        for (PendingAddOp op : ops) {</span>
<span class="nc" id="L1384">            op.submitCallback(rc);</span>
<span class="nc" id="L1385">        }</span>
<span class="fc" id="L1386">    }</span>

    void sendAddSuccessCallbacks() {
        // Start from the head of the queue and proceed while there are
        // entries that have had all their responses come back
        PendingAddOp pendingAddOp;

<span class="fc bfc" id="L1393" title="All 2 branches covered.">        while ((pendingAddOp = pendingAddOps.peek()) != null</span>
<span class="pc bpc" id="L1394" title="1 of 2 branches missed.">               &amp;&amp; blockAddCompletions.get() == 0) {</span>
<span class="pc bpc" id="L1395" title="1 of 2 branches missed.">            if (!pendingAddOp.completed) {</span>
<span class="nc bnc" id="L1396" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1397">                    LOG.debug(&quot;pending add not completed: {}&quot;, pendingAddOp);</span>
                }
<span class="nc" id="L1399">                return;</span>
            }
            // Check if it is the next entry in the sequence.
<span class="pc bpc" id="L1402" title="1 of 4 branches missed.">            if (pendingAddOp.entryId != 0 &amp;&amp; pendingAddOp.entryId != lastAddConfirmed + 1) {</span>
<span class="nc bnc" id="L1403" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1404">                    LOG.debug(&quot;Head of the queue entryId: {} is not lac: {} + 1&quot;, pendingAddOp.entryId,</span>
<span class="nc" id="L1405">                            lastAddConfirmed);</span>
                }
<span class="nc" id="L1407">                return;</span>
            }

<span class="fc" id="L1410">            pendingAddOps.remove();</span>
<span class="fc" id="L1411">            explicitLacFlushPolicy.updatePiggyBackedLac(lastAddConfirmed);</span>
<span class="fc" id="L1412">            lastAddConfirmed = pendingAddOp.entryId;</span>

<span class="fc" id="L1414">            pendingAddOp.submitCallback(BKException.Code.OK);</span>
        }

<span class="fc" id="L1417">    }</span>

    EnsembleInfo replaceBookieInMetadata(final Map&lt;Integer, BookieSocketAddress&gt; failedBookies,
                                         int ensembleChangeIdx)
            throws BKException.BKNotEnoughBookiesException {
<span class="nc" id="L1422">        final ArrayList&lt;BookieSocketAddress&gt; newEnsemble = new ArrayList&lt;BookieSocketAddress&gt;();</span>
<span class="nc" id="L1423">        final long newEnsembleStartEntry = getLastAddConfirmed() + 1;</span>
<span class="nc" id="L1424">        final HashSet&lt;Integer&gt; replacedBookies = new HashSet&lt;Integer&gt;();</span>
<span class="nc" id="L1425">        synchronized (metadata) {</span>
<span class="nc" id="L1426">            newEnsemble.addAll(metadata.currentEnsemble);</span>
<span class="nc bnc" id="L1427" title="All 2 branches missed.">            for (Map.Entry&lt;Integer, BookieSocketAddress&gt; entry : failedBookies.entrySet()) {</span>
<span class="nc" id="L1428">                int idx = entry.getKey();</span>
<span class="nc" id="L1429">                BookieSocketAddress addr = entry.getValue();</span>
<span class="nc bnc" id="L1430" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1431">                    LOG.debug(&quot;[EnsembleChange-L{}-{}] : replacing bookie: {} index: {}&quot;,</span>
<span class="nc" id="L1432">                        new Object[]{getId(), ensembleChangeIdx, addr, idx});</span>
                }
<span class="nc bnc" id="L1434" title="All 2 branches missed.">                if (!newEnsemble.get(idx).equals(addr)) {</span>
                    // ensemble has already changed, failure of this addr is immaterial
<span class="nc bnc" id="L1436" title="All 2 branches missed.">                    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1437">                        LOG.debug(&quot;Write did not succeed to {}, bookieIndex {}, but we have already fixed it.&quot;,</span>
<span class="nc" id="L1438">                                  addr, idx);</span>
                    }
                    continue;
                }
                try {
<span class="nc" id="L1443">                    BookieSocketAddress newBookie = bk.bookieWatcher.replaceBookie(</span>
<span class="nc" id="L1444">                        metadata.getEnsembleSize(),</span>
<span class="nc" id="L1445">                        metadata.getWriteQuorumSize(),</span>
<span class="nc" id="L1446">                        metadata.getAckQuorumSize(),</span>
<span class="nc" id="L1447">                        metadata.getCustomMetadata(),</span>
                        newEnsemble,
                        idx,
<span class="nc" id="L1450">                        new HashSet&lt;BookieSocketAddress&gt;(failedBookies.values()));</span>
<span class="nc" id="L1451">                    newEnsemble.set(idx, newBookie);</span>
<span class="nc" id="L1452">                    replacedBookies.add(idx);</span>
<span class="nc" id="L1453">                } catch (BKException.BKNotEnoughBookiesException e) {</span>
                    // if there is no bookie replaced, we throw not enough bookie exception
<span class="nc bnc" id="L1455" title="All 2 branches missed.">                    if (replacedBookies.size() &lt;= 0) {</span>
<span class="nc" id="L1456">                        throw e;</span>
                    } else {
<span class="nc" id="L1458">                        break;</span>
                    }
<span class="nc" id="L1460">                }</span>
<span class="nc" id="L1461">            }</span>
<span class="nc bnc" id="L1462" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1463">                LOG.debug(&quot;[EnsembleChange-L{}-{}] : changing ensemble from: {} to: {} starting at entry: {},&quot; +</span>
                    &quot; failed bookies: {}, replaced bookies: {}&quot;,
<span class="nc" id="L1465">                      new Object[] { ledgerId, ensembleChangeIdx, metadata.currentEnsemble, newEnsemble,</span>
<span class="nc" id="L1466">                              (getLastAddConfirmed() + 1), failedBookies, replacedBookies });</span>
            }
<span class="nc" id="L1468">            metadata.addEnsemble(newEnsembleStartEntry, newEnsemble);</span>
<span class="nc" id="L1469">        }</span>
<span class="nc" id="L1470">        return new EnsembleInfo(newEnsemble, failedBookies, replacedBookies);</span>
    }

    void handleBookieFailure(final Map&lt;Integer, BookieSocketAddress&gt; failedBookies) {
<span class="nc" id="L1474">        int curBlockAddCompletions = blockAddCompletions.incrementAndGet();</span>

<span class="nc bnc" id="L1476" title="All 2 branches missed.">        if (bk.disableEnsembleChangeFeature.isAvailable()) {</span>
<span class="nc" id="L1477">            blockAddCompletions.decrementAndGet();</span>
<span class="nc bnc" id="L1478" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1479">                LOG.debug(&quot;Ensemble change is disabled. Retry sending to failed bookies {} for ledger {}.&quot;,</span>
<span class="nc" id="L1480">                    failedBookies, ledgerId);</span>
            }
<span class="nc" id="L1482">            unsetSuccessAndSendWriteRequest(failedBookies.keySet());</span>
<span class="nc" id="L1483">            return;</span>
        }

<span class="nc" id="L1486">        int curNumEnsembleChanges = numEnsembleChanges.incrementAndGet();</span>

<span class="nc" id="L1488">        synchronized (metadata) {</span>
            try {
<span class="nc" id="L1490">                EnsembleInfo ensembleInfo = replaceBookieInMetadata(failedBookies, curNumEnsembleChanges);</span>
<span class="nc bnc" id="L1491" title="All 2 branches missed.">                if (ensembleInfo.replacedBookies.isEmpty()) {</span>
<span class="nc" id="L1492">                    blockAddCompletions.decrementAndGet();</span>
<span class="nc" id="L1493">                    return;</span>
                }
<span class="nc bnc" id="L1495" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1496">                    LOG.debug(&quot;[EnsembleChange-L{}-{}] : writing new ensemble info = {}, block add completions = {}&quot;,</span>
<span class="nc" id="L1497">                        new Object[]{getId(), curNumEnsembleChanges, ensembleInfo, curBlockAddCompletions});</span>
                }
<span class="nc" id="L1499">                writeLedgerConfig(new ChangeEnsembleCb(ensembleInfo, curBlockAddCompletions, curNumEnsembleChanges));</span>
<span class="nc" id="L1500">            } catch (BKException.BKNotEnoughBookiesException e) {</span>
<span class="nc" id="L1501">                LOG.error(&quot;Could not get additional bookie to remake ensemble, closing ledger: {}&quot;, ledgerId);</span>
<span class="nc" id="L1502">                handleUnrecoverableErrorDuringAdd(e.getCode());</span>
<span class="nc" id="L1503">                return;</span>
<span class="nc" id="L1504">            }</span>
<span class="nc" id="L1505">        }</span>
<span class="nc" id="L1506">    }</span>

    // Contains newly reformed ensemble, bookieIndex, failedBookieAddress
    static final class EnsembleInfo {
        private final ArrayList&lt;BookieSocketAddress&gt; newEnsemble;
        private final Map&lt;Integer, BookieSocketAddress&gt; failedBookies;
        final Set&lt;Integer&gt; replacedBookies;

        public EnsembleInfo(ArrayList&lt;BookieSocketAddress&gt; newEnsemble,
                            Map&lt;Integer, BookieSocketAddress&gt; failedBookies,
<span class="nc" id="L1516">                            Set&lt;Integer&gt; replacedBookies) {</span>
<span class="nc" id="L1517">            this.newEnsemble = newEnsemble;</span>
<span class="nc" id="L1518">            this.failedBookies = failedBookies;</span>
<span class="nc" id="L1519">            this.replacedBookies = replacedBookies;</span>
<span class="nc" id="L1520">        }</span>

        @Override
        public String toString() {
<span class="nc" id="L1524">            StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L1525">            sb.append(&quot;Ensemble Info : failed bookies = &quot;).append(failedBookies)</span>
<span class="nc" id="L1526">                    .append(&quot;, replaced bookies = &quot;).append(replacedBookies)</span>
<span class="nc" id="L1527">                    .append(&quot;, new ensemble = &quot;).append(newEnsemble);</span>
<span class="nc" id="L1528">            return sb.toString();</span>
        }
    }

    /**
     * Callback which is updating the ledgerMetadata in zk with the newly
     * reformed ensemble. On MetadataVersionException, will reread latest
     * ledgerMetadata and act upon.
     */
    private final class ChangeEnsembleCb extends OrderedSafeGenericCallback&lt;Void&gt; {
        private final EnsembleInfo ensembleInfo;
        private final int curBlockAddCompletions;
        private final int ensembleChangeIdx;

        ChangeEnsembleCb(EnsembleInfo ensembleInfo,
                         int curBlockAddCompletions,
<span class="nc" id="L1544">                         int ensembleChangeIdx) {</span>
<span class="nc" id="L1545">            super(bk.getMainWorkerPool(), ledgerId);</span>
<span class="nc" id="L1546">            this.ensembleInfo = ensembleInfo;</span>
<span class="nc" id="L1547">            this.curBlockAddCompletions = curBlockAddCompletions;</span>
<span class="nc" id="L1548">            this.ensembleChangeIdx = ensembleChangeIdx;</span>
<span class="nc" id="L1549">        }</span>

        @Override
        public void safeOperationComplete(final int rc, Void result) {
<span class="nc bnc" id="L1553" title="All 2 branches missed.">            if (rc == BKException.Code.MetadataVersionException) {</span>
                // We changed the ensemble, but got a version exception. We
                // should still consider this as an ensemble change
<span class="nc" id="L1556">                ensembleChangeCounter.inc();</span>

<span class="nc bnc" id="L1558" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1559">                    LOG.info(&quot;[EnsembleChange-L{}-{}] : encountered version conflicts, re-read ledger metadata.&quot;,</span>
<span class="nc" id="L1560">                        getId(), ensembleChangeIdx);</span>
                }

<span class="nc" id="L1563">                rereadMetadata(new ReReadLedgerMetadataCb(rc,</span>
                                       ensembleInfo, curBlockAddCompletions, ensembleChangeIdx));
<span class="nc" id="L1565">                return;</span>
<span class="nc bnc" id="L1566" title="All 2 branches missed.">            } else if (rc != BKException.Code.OK) {</span>
<span class="nc" id="L1567">                LOG.error(&quot;[EnsembleChange-L{}-{}] : could not persist ledger metadata : info = {}, closing ledger : {}.&quot;,</span>
<span class="nc" id="L1568">                        new Object[] { getId(), ensembleChangeIdx, ensembleInfo, rc });</span>
<span class="nc" id="L1569">                handleUnrecoverableErrorDuringAdd(rc);</span>
<span class="nc" id="L1570">                return;</span>
            }
<span class="nc" id="L1572">            int newBlockAddCompletions = blockAddCompletions.decrementAndGet();</span>

<span class="nc bnc" id="L1574" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1575">                LOG.info(&quot;[EnsembleChange-L{}-{}] : completed ensemble change, block add completion {} =&gt; {}&quot;,</span>
<span class="nc" id="L1576">                    new Object[]{getId(), ensembleChangeIdx, curBlockAddCompletions, newBlockAddCompletions});</span>
            }

            // We've successfully changed an ensemble
<span class="nc" id="L1580">            ensembleChangeCounter.inc();</span>
            // the failed bookie has been replaced
<span class="nc" id="L1582">            unsetSuccessAndSendWriteRequest(ensembleInfo.replacedBookies);</span>
<span class="nc" id="L1583">        }</span>

        @Override
        public String toString() {
<span class="nc" id="L1587">            return String.format(&quot;ChangeEnsemble(%d)&quot;, ledgerId);</span>
        }
    }

    /**
     * Callback which is reading the ledgerMetadata present in zk. This will try
     * to resolve the version conflicts.
     */
    private final class ReReadLedgerMetadataCb extends OrderedSafeGenericCallback&lt;LedgerMetadata&gt; {
        private final int rc;
        private final EnsembleInfo ensembleInfo;
        private final int curBlockAddCompletions;
        private final int ensembleChangeIdx;

        ReReadLedgerMetadataCb(int rc,
                               EnsembleInfo ensembleInfo,
                               int curBlockAddCompletions,
<span class="nc" id="L1604">                               int ensembleChangeIdx) {</span>
<span class="nc" id="L1605">            super(bk.getMainWorkerPool(), ledgerId);</span>
<span class="nc" id="L1606">            this.rc = rc;</span>
<span class="nc" id="L1607">            this.ensembleInfo = ensembleInfo;</span>
<span class="nc" id="L1608">            this.curBlockAddCompletions = curBlockAddCompletions;</span>
<span class="nc" id="L1609">            this.ensembleChangeIdx = ensembleChangeIdx;</span>
<span class="nc" id="L1610">        }</span>

        @Override
        public void safeOperationComplete(int newrc, LedgerMetadata newMeta) {
<span class="nc bnc" id="L1614" title="All 2 branches missed.">            if (newrc != BKException.Code.OK) {</span>
<span class="nc" id="L1615">                LOG.error(&quot;[EnsembleChange-L{}-{}] : error re-reading metadata to address ensemble change conflicts,&quot; +</span>
<span class="nc" id="L1616">                        &quot; code=&quot;, new Object[] { ledgerId, ensembleChangeIdx, newrc });</span>
<span class="nc" id="L1617">                handleUnrecoverableErrorDuringAdd(rc);</span>
            } else {
<span class="nc bnc" id="L1619" title="All 2 branches missed.">                if (!resolveConflict(newMeta)) {</span>
<span class="nc" id="L1620">                    LOG.error(&quot;[EnsembleChange-L{}-{}] : could not resolve ledger metadata conflict&quot; +</span>
                            &quot; while changing ensemble to: {}, local meta data is \n {} \n,&quot; +
                            &quot; zk meta data is \n {} \n, closing ledger&quot;,
<span class="nc" id="L1623">                            new Object[] { ledgerId, ensembleChangeIdx, ensembleInfo.newEnsemble, metadata, newMeta });</span>
<span class="nc" id="L1624">                    handleUnrecoverableErrorDuringAdd(rc);</span>
                }
            }
<span class="nc" id="L1627">        }</span>

        /**
         * Specific resolve conflicts happened when multiple bookies failures in same ensemble.
         * &lt;p&gt;
         * Resolving the version conflicts between local ledgerMetadata and zk
         * ledgerMetadata. This will do the following:
         * &lt;ul&gt;
         * &lt;li&gt;
         * check whether ledgerMetadata state matches of local and zk&lt;/li&gt;
         * &lt;li&gt;
         * if the zk ledgerMetadata still contains the failed bookie, then
         * update zookeeper with the newBookie otherwise send write request&lt;/li&gt;
         * &lt;/ul&gt;
         * &lt;/p&gt;
         */
        private boolean resolveConflict(LedgerMetadata newMeta) {
<span class="nc bnc" id="L1644" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1645">                LOG.debug(&quot;[EnsembleChange-L{}-{}] : resolving conflicts - local metadata = \n {} \n,&quot; +</span>
<span class="nc" id="L1646">                    &quot; zk metadata = \n {} \n&quot;, new Object[]{ledgerId, ensembleChangeIdx, metadata, newMeta});</span>
            }
            // make sure the ledger isn't closed by other ones.
<span class="nc bnc" id="L1649" title="All 2 branches missed.">            if (metadata.getState() != newMeta.getState()) {</span>
<span class="nc bnc" id="L1650" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1651">                    LOG.info(&quot;[EnsembleChange-L{}-{}] : resolving conflicts but state changed,&quot; +</span>
                            &quot; local metadata = \n {} \n, zk metadata = \n {} \n&quot;,
<span class="nc" id="L1653">                        new Object[]{ledgerId, ensembleChangeIdx, metadata, newMeta});</span>
                }
<span class="nc" id="L1655">                return false;</span>
            }

            // We should check number of ensembles since there are two kinds of metadata conflicts:
            // - Case 1: Multiple bookies involved in ensemble change.
            //           Number of ensembles should be same in this case.
            // - Case 2: Recovery (Auto/Manually) replaced ensemble and ensemble changed.
            //           The metadata changed due to ensemble change would have one more ensemble
            //           than the metadata changed by recovery.
<span class="nc" id="L1664">            int diff = newMeta.getEnsembles().size() - metadata.getEnsembles().size();</span>
<span class="nc bnc" id="L1665" title="All 2 branches missed.">            if (0 != diff) {</span>
<span class="nc bnc" id="L1666" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1667">                    LOG.debug(&quot;[EnsembleChange-L{}-{}] : resolving conflicts but ensembles have {} differences,&quot; +</span>
                            &quot; local metadata = \n {} \n, zk metadata = \n {} \n&quot;,
<span class="nc" id="L1669">                        new Object[]{ledgerId, ensembleChangeIdx, diff, metadata, newMeta});</span>
                }
<span class="nc bnc" id="L1671" title="All 2 branches missed.">                if (-1 == diff) {</span>
                    // Case 1: metadata is changed by other ones (e.g. Recovery)
<span class="nc" id="L1673">                    return updateMetadataIfPossible(newMeta);</span>
                }
<span class="nc" id="L1675">                return false;</span>
            }

            //
            // Case 2:
            //
            // If the failed the bookie is still existed in the metadata (in zookeeper), it means that
            // the ensemble change of the failed bookie is failed due to metadata conflicts. so try to
            // update the ensemble change metadata again. Otherwise, it means that the ensemble change
            // is already succeed, unset the success and re-adding entries.
<span class="nc bnc" id="L1685" title="All 2 branches missed.">            if (!areFailedBookiesReplaced(newMeta, ensembleInfo)) {</span>
                // If the in-memory data doesn't contains the failed bookie, it means the ensemble change
                // didn't finish, so try to resolve conflicts with the metadata read from zookeeper and
                // update ensemble changed metadata again.
<span class="nc bnc" id="L1689" title="All 2 branches missed.">                if (areFailedBookiesReplaced(metadata, ensembleInfo)) {</span>
<span class="nc" id="L1690">                    return updateMetadataIfPossible(newMeta);</span>
                }
            } else {
<span class="nc" id="L1693">                ensembleChangeCounter.inc();</span>
                // We've successfully changed an ensemble
                // the failed bookie has been replaced
<span class="nc" id="L1696">                int newBlockAddCompletions = blockAddCompletions.decrementAndGet();</span>
<span class="nc" id="L1697">                unsetSuccessAndSendWriteRequest(ensembleInfo.replacedBookies);</span>
<span class="nc bnc" id="L1698" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1699">                    LOG.info(&quot;[EnsembleChange-L{}-{}] : resolved conflicts, block add complectiosn {} =&gt; {}.&quot;,</span>
<span class="nc" id="L1700">                        new Object[]{ledgerId, ensembleChangeIdx, curBlockAddCompletions, newBlockAddCompletions});</span>
                }
            }
<span class="nc" id="L1703">            return true;</span>
        }

        /**
         * Check whether all the failed bookies are replaced.
         *
         * @param newMeta
         *          new ledger metadata
         * @param ensembleInfo
         *          ensemble info used for ensemble change.
         * @return true if all failed bookies are replaced, false otherwise
         */
        private boolean areFailedBookiesReplaced(LedgerMetadata newMeta, EnsembleInfo ensembleInfo) {
<span class="nc" id="L1716">            boolean replaced = true;</span>
<span class="nc bnc" id="L1717" title="All 2 branches missed.">            for (Integer replacedBookieIdx : ensembleInfo.replacedBookies) {</span>
<span class="nc" id="L1718">                BookieSocketAddress failedBookieAddr = ensembleInfo.failedBookies.get(replacedBookieIdx);</span>
<span class="nc" id="L1719">                BookieSocketAddress replacedBookieAddr = newMeta.currentEnsemble.get(replacedBookieIdx);</span>
<span class="nc bnc" id="L1720" title="All 2 branches missed.">                replaced &amp;= !Objects.equal(replacedBookieAddr, failedBookieAddr);</span>
<span class="nc" id="L1721">            }</span>
<span class="nc" id="L1722">            return replaced;</span>
        }

        private boolean updateMetadataIfPossible(LedgerMetadata newMeta) {
            // if the local metadata is newer than zookeeper metadata, it means that metadata is updated
            // again when it was trying re-reading the metatada, re-kick the reread again
<span class="nc bnc" id="L1728" title="All 2 branches missed.">            if (metadata.isNewerThan(newMeta)) {</span>
<span class="nc bnc" id="L1729" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1730">                    LOG.debug(&quot;[EnsembleChange-L{}-{}] : reread metadata because local metadata is newer.&quot;,</span>
<span class="nc" id="L1731">                        new Object[]{ledgerId, ensembleChangeIdx});</span>
                }
<span class="nc" id="L1733">                rereadMetadata(this);</span>
<span class="nc" id="L1734">                return true;</span>
            }
            // make sure the metadata doesn't changed by other ones.
<span class="nc bnc" id="L1737" title="All 2 branches missed.">            if (metadata.isConflictWith(newMeta)) {</span>
<span class="nc bnc" id="L1738" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1739">                    LOG.debug(&quot;[EnsembleChange-L{}-{}] : metadata is conflicted, local metadata = \n {} \n,&quot; +</span>
<span class="nc" id="L1740">                        &quot; zk metadata = \n {} \n&quot;, new Object[]{ledgerId, ensembleChangeIdx, metadata, newMeta});</span>
                }
<span class="nc" id="L1742">                return false;</span>
            }
<span class="nc bnc" id="L1744" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1745">                LOG.info(&quot;[EnsembleChange-L{}-{}] : resolved ledger metadata conflict and writing to zookeeper,&quot;</span>
                        + &quot; local meta data is \n {} \n, zk meta data is \n {}.&quot;,
<span class="nc" id="L1747">                    new Object[]{ledgerId, ensembleChangeIdx, metadata, newMeta});</span>
            }
            // update znode version
<span class="nc" id="L1750">            metadata.setVersion(newMeta.getVersion());</span>
            // merge ensemble infos from new meta except last ensemble
            // since they might be modified by recovery tool.
<span class="nc" id="L1753">            metadata.mergeEnsembles(newMeta.getEnsembles());</span>
<span class="nc" id="L1754">            writeLedgerConfig(new ChangeEnsembleCb(ensembleInfo, curBlockAddCompletions, ensembleChangeIdx));</span>
<span class="nc" id="L1755">            return true;</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L1760">            return String.format(&quot;ReReadLedgerMetadata(%d)&quot;, ledgerId);</span>
        }
    }

    void unsetSuccessAndSendWriteRequest(final Set&lt;Integer&gt; bookies) {
<span class="nc bnc" id="L1765" title="All 2 branches missed.">        for (PendingAddOp pendingAddOp : pendingAddOps) {</span>
<span class="nc bnc" id="L1766" title="All 2 branches missed.">            for (Integer bookieIndex: bookies) {</span>
<span class="nc" id="L1767">                pendingAddOp.unsetSuccessAndSendWriteRequest(bookieIndex);</span>
<span class="nc" id="L1768">            }</span>
<span class="nc" id="L1769">        }</span>
<span class="nc" id="L1770">    }</span>

    void rereadMetadata(final GenericCallback&lt;LedgerMetadata&gt; cb) {
<span class="nc" id="L1773">        bk.getLedgerManager().readLedgerMetadata(ledgerId, cb);</span>
<span class="nc" id="L1774">    }</span>

    void registerOperationFailureOnBookie(BookieSocketAddress bookie, long entryId) {
<span class="nc bnc" id="L1777" title="All 2 branches missed.">        if (bk.getConf().getEnableBookieFailureTracking()) {</span>
<span class="nc" id="L1778">            bookieFailureHistory.put(bookie, entryId);</span>
        }
<span class="nc" id="L1780">    }</span>


    void recover(GenericCallback&lt;Void&gt; finalCb) {
<span class="nc" id="L1784">        recover(finalCb, null, false);</span>
<span class="nc" id="L1785">    }</span>

    /**
     * Recover the ledger.
     *
     * @param finalCb
     *          callback after recovery is done.
     * @param listener
     *          read entry listener on recovery reads.
     * @param forceRecovery
     *          force the recovery procedure even the ledger metadata shows the ledger is closed.
     */
    void recover(GenericCallback&lt;Void&gt; finalCb,
                 final @VisibleForTesting BookkeeperInternalCallbacks.ReadEntryListener listener,
                 final boolean forceRecovery) {
<span class="nc" id="L1800">        final GenericCallback&lt;Void&gt; cb = new TimedGenericCallback&lt;Void&gt;(</span>
            finalCb,
            BKException.Code.OK,
<span class="nc" id="L1803">            bk.getRecoverOpLogger());</span>
<span class="nc" id="L1804">        boolean wasClosed = false;</span>
<span class="nc" id="L1805">        boolean wasInRecovery = false;</span>

<span class="nc" id="L1807">        synchronized (this) {</span>
<span class="nc bnc" id="L1808" title="All 2 branches missed.">            if (metadata.isClosed()) {</span>
<span class="nc bnc" id="L1809" title="All 2 branches missed.">                if (forceRecovery) {</span>
<span class="nc" id="L1810">                    wasClosed = false;</span>
                    // mark the ledger back to in recovery state, so it would proceed ledger recovery again.
<span class="nc" id="L1812">                    wasInRecovery = false;</span>
<span class="nc" id="L1813">                    metadata.markLedgerInRecovery();</span>
                } else {
<span class="nc" id="L1815">                    lastAddConfirmed = lastAddPushed = metadata.getLastEntryId();</span>
<span class="nc" id="L1816">                    length = metadata.getLength();</span>
<span class="nc" id="L1817">                    wasClosed = true;</span>
                }
            } else {
<span class="nc" id="L1820">                wasClosed = false;</span>
<span class="nc bnc" id="L1821" title="All 2 branches missed.">                if (metadata.isInRecovery()) {</span>
<span class="nc" id="L1822">                    wasInRecovery = true;</span>
                } else {
<span class="nc" id="L1824">                    wasInRecovery = false;</span>
<span class="nc" id="L1825">                    metadata.markLedgerInRecovery();</span>
                }
            }
<span class="nc" id="L1828">        }</span>

<span class="nc bnc" id="L1830" title="All 2 branches missed.">        if (wasClosed) {</span>
            // We are already closed, nothing to do
<span class="nc" id="L1832">            cb.operationComplete(BKException.Code.OK, null);</span>
<span class="nc" id="L1833">            return;</span>
        }

<span class="nc bnc" id="L1836" title="All 2 branches missed.">        if (wasInRecovery) {</span>
            // if metadata is already in recover, dont try to write again,
            // just do the recovery from the starting point
<span class="nc" id="L1839">            new LedgerRecoveryOp(LedgerHandle.this, cb)</span>
<span class="nc" id="L1840">                    .parallelRead(enableParallelRecoveryRead)</span>
<span class="nc" id="L1841">                    .readBatchSize(recoveryReadBatchSize)</span>
<span class="nc" id="L1842">                    .setEntryListener(listener)</span>
<span class="nc" id="L1843">                    .initiate();</span>
<span class="nc" id="L1844">            return;</span>
        }

<span class="nc" id="L1847">        writeLedgerConfig(new OrderedSafeGenericCallback&lt;Void&gt;(bk.getMainWorkerPool(), ledgerId) {</span>
            @Override
            public void safeOperationComplete(final int rc, Void result) {
<span class="nc bnc" id="L1850" title="All 2 branches missed.">                if (rc == BKException.Code.MetadataVersionException) {</span>
<span class="nc" id="L1851">                    rereadMetadata(new OrderedSafeGenericCallback&lt;LedgerMetadata&gt;(bk.getMainWorkerPool(),</span>
<span class="nc" id="L1852">                                                                                  ledgerId) {</span>
                        @Override
                        public void safeOperationComplete(int rc, LedgerMetadata newMeta) {
<span class="nc bnc" id="L1855" title="All 2 branches missed.">                            if (rc != BKException.Code.OK) {</span>
<span class="nc" id="L1856">                                cb.operationComplete(rc, null);</span>
                            } else {
<span class="nc" id="L1858">                                metadata = newMeta;</span>
<span class="nc" id="L1859">                                recover(cb, listener, forceRecovery);</span>
                            }
<span class="nc" id="L1861">                        }</span>

                        @Override
                        public String toString() {
<span class="nc" id="L1865">                            return String.format(&quot;ReReadMetadataForRecover(%d)&quot;, ledgerId);</span>
                        }
                    });
<span class="nc bnc" id="L1868" title="All 2 branches missed.">                } else if (rc == BKException.Code.OK) {</span>
                    // we only could issue recovery operation after we successfully update the ledger state to in recovery
                    // otherwise, it couldn't prevent us advancing last confirmed while the other writer is closing the ledger,
                    // which will cause inconsistent last add confirmed on bookies &amp; zookeeper metadata.
<span class="nc" id="L1872">                    new LedgerRecoveryOp(LedgerHandle.this, cb)</span>
<span class="nc" id="L1873">                        .parallelRead(enableParallelRecoveryRead)</span>
<span class="nc" id="L1874">                        .readBatchSize(recoveryReadBatchSize)</span>
<span class="nc" id="L1875">                        .setEntryListener(listener)</span>
<span class="nc" id="L1876">                        .initiate();</span>
                } else {
<span class="nc" id="L1878">                    LOG.error(&quot;Error writing ledger config {} of ledger {}&quot;, rc, ledgerId);</span>
<span class="nc" id="L1879">                    cb.operationComplete(rc, null);</span>
                }
<span class="nc" id="L1881">            }</span>

            @Override
            public String toString() {
<span class="nc" id="L1885">                return String.format(&quot;WriteLedgerConfigForRecover(%d)&quot;, ledgerId);</span>
            }
        });
<span class="nc" id="L1888">    }</span>

<span class="nc" id="L1890">    static class NoopCloseCallback implements CloseCallback {</span>
<span class="nc" id="L1891">        static NoopCloseCallback instance = new NoopCloseCallback();</span>

        @Override
        public void closeComplete(int rc, LedgerHandle lh, Object ctx) {
<span class="nc bnc" id="L1895" title="All 2 branches missed.">            if (rc != BKException.Code.OK) {</span>
<span class="nc" id="L1896">                LOG.warn(&quot;Close failed: &quot; + BKException.getMessage(rc));</span>
            }
            // noop
<span class="nc" id="L1899">        }</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>