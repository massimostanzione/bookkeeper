<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SyncCallbackUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.client</a> &gt; <span class="el_source">SyncCallbackUtils.java</span></div><h1>SyncCallbackUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.bookkeeper.client;

import java.util.Enumeration;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import lombok.extern.slf4j.Slf4j;
import org.apache.bookkeeper.client.api.LastConfirmedAndEntry;
import org.apache.bookkeeper.client.impl.LastConfirmedAndEntryImpl;

/**
 * Utility for callbacks
 *
 */
<span class="fc" id="L31">@Slf4j</span>
<span class="nc" id="L32">class SyncCallbackUtils {</span>

    /**
     * Wait for a result. This is convenience method to implement callbacks
     *
     * @param &lt;T&gt;
     * @param future
     * @return
     * @throws InterruptedException
     * @throws BKException
     */
    public static &lt;T&gt; T waitForResult(CompletableFuture&lt;T&gt; future) throws InterruptedException, BKException {
        try {
<span class="fc" id="L45">            return future.get();</span>
<span class="fc" id="L46">        } catch (ExecutionException err) {</span>
<span class="pc bpc" id="L47" title="1 of 2 branches missed.">            if (err.getCause() instanceof BKException) {</span>
<span class="fc" id="L48">                throw (BKException) err.getCause();</span>
            } else {
<span class="nc" id="L50">                BKException unexpectedConditionException</span>
<span class="nc" id="L51">                    = BKException.create(BKException.Code.UnexpectedConditionException);</span>
<span class="nc" id="L52">                unexpectedConditionException.initCause(err.getCause());</span>
<span class="nc" id="L53">                throw unexpectedConditionException;</span>
            }

        }
    }

    /**
     * Handle the Response Code and transform it to a BKException
     *
     * @param &lt;T&gt;
     * @param rc
     * @param result
     * @param future
     */
    public static &lt;T&gt; void finish(int rc, T result, CompletableFuture&lt;? super T&gt; future) {
<span class="fc bfc" id="L68" title="All 2 branches covered.">        if (rc != BKException.Code.OK) {</span>
<span class="fc" id="L69">            future.completeExceptionally(BKException.create(rc).fillInStackTrace());</span>
        } else {
<span class="fc" id="L71">            future.complete(result);</span>
        }
<span class="fc" id="L73">    }</span>

    static class SyncCreateCallback implements AsyncCallback.CreateCallback {

        private final CompletableFuture&lt;? super LedgerHandle&gt; future;

<span class="fc" id="L79">        public SyncCreateCallback(CompletableFuture&lt;? super LedgerHandle&gt; future) {</span>
<span class="fc" id="L80">            this.future = future;</span>
<span class="fc" id="L81">        }</span>

        /**
         * Create callback implementation for synchronous create call.
         *
         * @param rc return code
         * @param lh ledger handle object
         * @param ctx optional control object
         */
        @Override
        public void createComplete(int rc, LedgerHandle lh, Object ctx) {
<span class="fc" id="L92">            finish(rc, lh, future);</span>
<span class="fc" id="L93">        }</span>

    }

    static class SyncCreateAdvCallback implements AsyncCallback.CreateCallback {

        private final CompletableFuture&lt;? super LedgerHandleAdv&gt; future;

<span class="nc" id="L101">        public SyncCreateAdvCallback(CompletableFuture&lt;? super LedgerHandleAdv&gt; future) {</span>
<span class="nc" id="L102">            this.future = future;</span>
<span class="nc" id="L103">        }</span>

        /**
         * Create callback implementation for synchronous create call.
         *
         * @param rc return code
         * @param lh ledger handle object
         * @param ctx optional control object
         */
        @Override
        public void createComplete(int rc, LedgerHandle lh, Object ctx) {
<span class="nc bnc" id="L114" title="All 4 branches missed.">            if (lh == null || lh instanceof LedgerHandleAdv) {</span>
<span class="nc" id="L115">                finish(rc, (LedgerHandleAdv) lh, future);</span>
            } else {
<span class="nc" id="L117">                finish(BKException.Code.UnexpectedConditionException, null, future);</span>
            }
<span class="nc" id="L119">        }</span>

    }

    static class SyncOpenCallback implements AsyncCallback.OpenCallback {

        private final CompletableFuture&lt;? super LedgerHandle&gt; future;

<span class="nc" id="L127">        public SyncOpenCallback(CompletableFuture&lt;? super LedgerHandle&gt; future) {</span>
<span class="nc" id="L128">            this.future = future;</span>
<span class="nc" id="L129">        }</span>

        /**
         * Callback method for synchronous open operation
         *
         * @param rc
         *          return code
         * @param lh
         *          ledger handle
         * @param ctx
         *          optional control object
         */
        @Override
        public void openComplete(int rc, LedgerHandle lh, Object ctx) {
<span class="nc" id="L143">            finish(rc, lh, future);</span>
<span class="nc" id="L144">        }</span>
    }

    static class SyncDeleteCallback implements AsyncCallback.DeleteCallback {

        private final CompletableFuture&lt;Void&gt; future;

<span class="nc" id="L151">        public SyncDeleteCallback(CompletableFuture&lt;Void&gt; future) {</span>
<span class="nc" id="L152">            this.future = future;</span>
<span class="nc" id="L153">        }</span>


        /**
         * Delete callback implementation for synchronous delete call.
         *
         * @param rc
         *            return code
         * @param ctx
         *            optional control object
         */
        @Override
        public void deleteComplete(int rc, Object ctx) {
<span class="nc" id="L166">            finish(rc, null, future);</span>
<span class="nc" id="L167">        }</span>
    }

<span class="nc" id="L170">    static class LastAddConfirmedCallback implements AsyncCallback.AddLacCallback {</span>
<span class="nc" id="L171">        static final LastAddConfirmedCallback INSTANCE = new LastAddConfirmedCallback();</span>
        /**
         * Implementation of callback interface for synchronous read method.
         *
         * @param rc
         *          return code
         * @param lh
         *          ledger identifier
         * @param ctx
         *          control object
         */
        @Override
        public void addLacComplete(int rc, LedgerHandle lh, Object ctx) {
<span class="nc bnc" id="L184" title="All 2 branches missed.">            if (rc != BKException.Code.OK) {</span>
<span class="nc" id="L185">                log.warn(&quot;LastAddConfirmedUpdate failed: {} &quot;, BKException.getMessage(rc));</span>
            } else {
<span class="nc bnc" id="L187" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L188">                    log.debug(&quot;Callback LAC Updated for: {} &quot;, lh.getId());</span>
                }
            }
<span class="nc" id="L191">        }</span>
    }

    static class SyncReadCallback implements AsyncCallback.ReadCallback {

        private final CompletableFuture&lt;Enumeration&lt;LedgerEntry&gt;&gt; future;

<span class="fc" id="L198">        public SyncReadCallback(CompletableFuture&lt;Enumeration&lt;LedgerEntry&gt;&gt; future) {</span>
<span class="fc" id="L199">            this.future = future;</span>
<span class="fc" id="L200">        }</span>

        /**
         * Implementation of callback interface for synchronous read method.
         *
         * @param rc
         *          return code
         * @param lh
         *          ledger handle
         * @param seq
         *          sequence of entries
         * @param ctx
         *          control object
         */
        @Override
        public void readComplete(int rc, LedgerHandle lh,
                                 Enumeration&lt;LedgerEntry&gt; seq, Object ctx) {
<span class="fc" id="L217">            finish(rc, seq, future);</span>
<span class="fc" id="L218">        }</span>
    }

<span class="fc" id="L221">    static class SyncAddCallback extends CompletableFuture&lt;Long&gt; implements AsyncCallback.AddCallback {</span>

        /**
         * Implementation of callback interface for synchronous read method.
         *
         * @param rc
         *          return code
         * @param lh
         *          ledger handle
         * @param entry
         *          entry identifier
         * @param ctx
         *          control object
         */
        @Override
        public void addComplete(int rc, LedgerHandle lh, long entry, Object ctx) {
<span class="fc" id="L237">            finish(rc, entry, this);</span>
<span class="fc" id="L238">        }</span>
    }

<span class="nc" id="L241">    static class FutureReadLastConfirmed extends CompletableFuture&lt;Long&gt;</span>
        implements AsyncCallback.ReadLastConfirmedCallback {

        @Override
        public void readLastConfirmedComplete(int rc, long lastConfirmed, Object ctx) {
<span class="nc" id="L246">            finish(rc, lastConfirmed, this);</span>
<span class="nc" id="L247">        }</span>

    }

<span class="nc" id="L251">    static class SyncReadLastConfirmedCallback implements AsyncCallback.ReadLastConfirmedCallback {</span>
        /**
         * Implementation of  callback interface for synchronous read last confirmed method.
         */
        @Override
        public void readLastConfirmedComplete(int rc, long lastConfirmed, Object ctx) {
<span class="nc" id="L257">            LedgerHandle.LastConfirmedCtx lcCtx = (LedgerHandle.LastConfirmedCtx) ctx;</span>

<span class="nc" id="L259">            synchronized(lcCtx) {</span>
<span class="nc" id="L260">                lcCtx.setRC(rc);</span>
<span class="nc" id="L261">                lcCtx.setLastConfirmed(lastConfirmed);</span>
<span class="nc" id="L262">                lcCtx.notify();</span>
<span class="nc" id="L263">            }</span>
<span class="nc" id="L264">        }</span>
    }

    static class SyncCloseCallback implements AsyncCallback.CloseCallback {

        private final CompletableFuture&lt;Void&gt; future;

<span class="fc" id="L271">        public SyncCloseCallback(CompletableFuture&lt;Void&gt; future) {</span>
<span class="fc" id="L272">            this.future = future;</span>
<span class="fc" id="L273">        }</span>

        /**
         * Close callback method
         *
         * @param rc
         * @param lh
         * @param ctx
         */
        @Override
        public void closeComplete(int rc, LedgerHandle lh, Object ctx) {
<span class="fc" id="L284">            finish(rc, null, future);</span>
<span class="fc" id="L285">        }</span>
    }

<span class="nc" id="L288">    static class FutureReadLastConfirmedAndEntry</span>
        extends CompletableFuture&lt;LastConfirmedAndEntry&gt; implements AsyncCallback.ReadLastConfirmedAndEntryCallback {

        @Override
        public void readLastConfirmedAndEntryComplete(int rc, long lastConfirmed, LedgerEntry entry, Object ctx) {
<span class="nc" id="L293">            LastConfirmedAndEntry result = LastConfirmedAndEntryImpl.create(lastConfirmed, entry);</span>
<span class="nc" id="L294">            finish(rc, result, this);</span>
<span class="nc" id="L295">        }</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>