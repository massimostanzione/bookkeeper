<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BookieWatcher.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.client</a> &gt; <span class="el_source">BookieWatcher.java</span></div><h1>BookieWatcher.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.bookkeeper.client;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.RemovalListener;
import com.google.common.cache.RemovalNotification;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;
import lombok.extern.slf4j.Slf4j;
import org.apache.bookkeeper.client.BKException.BKInterruptedException;
import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;
import org.apache.bookkeeper.client.BKException.MetaStoreException;
import org.apache.bookkeeper.common.concurrent.FutureUtils;
import org.apache.bookkeeper.conf.ClientConfiguration;
import org.apache.bookkeeper.discover.RegistrationClient;
import org.apache.bookkeeper.net.BookieSocketAddress;

/**
 * This class is responsible for maintaining a consistent view of what bookies
 * are available by reading Zookeeper (and setting watches on the bookie nodes).
 * When a bookie fails, the other parts of the code turn to this class to find a
 * replacement
 *
 */
<span class="pc bpc" id="L49" title="1 of 2 branches missed.">@Slf4j</span>
class BookieWatcher {

<span class="fc" id="L52">    private static final Function&lt;Throwable, BKException&gt; EXCEPTION_FUNC = cause -&gt; {</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">        if (cause instanceof BKException) {</span>
<span class="nc" id="L54">            log.error(&quot;Failed to get bookie list : &quot;, cause);</span>
<span class="nc" id="L55">            return (BKException) cause;</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">        } else if (cause instanceof InterruptedException) {</span>
<span class="nc" id="L57">            log.error(&quot;Interrupted reading bookie list : &quot;, cause);</span>
<span class="nc" id="L58">            return new BKInterruptedException();</span>
        } else {
<span class="nc" id="L60">            return new MetaStoreException();</span>
        }
    };

    private final ClientConfiguration conf;
    private final RegistrationClient registrationClient;
    private final EnsemblePlacementPolicy placementPolicy;

    // Bookies that will not be preferred to be chosen in a new ensemble
    final Cache&lt;BookieSocketAddress, Boolean&gt; quarantinedBookies;

<span class="fc" id="L71">    private volatile Set&lt;BookieSocketAddress&gt; writableBookies = Collections.emptySet();</span>
<span class="fc" id="L72">    private volatile Set&lt;BookieSocketAddress&gt; readOnlyBookies = Collections.emptySet();</span>

<span class="fc" id="L74">    private CompletableFuture&lt;?&gt; initialWritableBookiesFuture = null;</span>
<span class="fc" id="L75">    private CompletableFuture&lt;?&gt; initialReadonlyBookiesFuture = null;</span>

    public BookieWatcher(ClientConfiguration conf,
                         EnsemblePlacementPolicy placementPolicy,
<span class="fc" id="L79">                         RegistrationClient registrationClient) {</span>
<span class="fc" id="L80">        this.conf = conf;</span>
<span class="fc" id="L81">        this.placementPolicy = placementPolicy;</span>
<span class="fc" id="L82">        this.registrationClient = registrationClient;</span>
<span class="fc" id="L83">        this.quarantinedBookies = CacheBuilder.newBuilder()</span>
<span class="fc" id="L84">                .expireAfterWrite(conf.getBookieQuarantineTimeSeconds(), TimeUnit.SECONDS)</span>
<span class="fc" id="L85">                .removalListener(new RemovalListener&lt;BookieSocketAddress, Boolean&gt;() {</span>

                    @Override
                    public void onRemoval(RemovalNotification&lt;BookieSocketAddress, Boolean&gt; bookie) {
<span class="nc" id="L89">                        log.info(&quot;Bookie {} is no longer quarantined&quot;, bookie.getKey());</span>
<span class="nc" id="L90">                    }</span>

<span class="fc" id="L92">                }).build();</span>
<span class="fc" id="L93">    }</span>

    public Set&lt;BookieSocketAddress&gt; getBookies() throws BKException {
        try {
<span class="nc" id="L97">            return FutureUtils.result(registrationClient.getWritableBookies(), EXCEPTION_FUNC).getValue();</span>
<span class="nc" id="L98">        } catch (BKInterruptedException ie) {</span>
<span class="nc" id="L99">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L100">            throw ie;</span>
        }
    }

    public Set&lt;BookieSocketAddress&gt; getReadOnlyBookies() throws BKException {
        try {
<span class="nc" id="L106">            return FutureUtils.result(registrationClient.getReadOnlyBookies(), EXCEPTION_FUNC).getValue();</span>
<span class="nc" id="L107">        } catch (BKInterruptedException ie) {</span>
<span class="nc" id="L108">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L109">            throw ie;</span>
        }
    }

    // this callback is already not executed in zookeeper thread
    private synchronized void processWritableBookiesChanged(Set&lt;BookieSocketAddress&gt; newBookieAddrs) {
        // Update watcher outside ZK callback thread, to avoid deadlock in case some other
        // component is trying to do a blocking ZK operation
<span class="fc" id="L117">        this.writableBookies = newBookieAddrs;</span>
<span class="fc" id="L118">        placementPolicy.onClusterChanged(newBookieAddrs, readOnlyBookies);</span>
        // we don't need to close clients here, because:
        // a. the dead bookies will be removed from topology, which will not be used in new ensemble.
        // b. the read sequence will be reordered based on znode availability, so most of the reads
        //    will not be sent to them.
        // c. the close here is just to disconnect the channel, which doesn't remove the channel from
        //    from pcbc map. we don't really need to disconnect the channel here, since if a bookie is
        //    really down, PCBC will disconnect itself based on netty callback. if we try to disconnect
        //    here, it actually introduces side-effects on case d.
        // d. closing the client here will affect latency if the bookie is alive but just being flaky
        //    on its znode registration due zookeeper session expire.
        // e. if we want to permanently remove a bookkeeper client, we should watch on the cookies' list.
        // if (bk.getBookieClient() != null) {
        //     bk.getBookieClient().closeClients(deadBookies);
        // }
<span class="fc" id="L133">    }</span>

    private synchronized void processReadOnlyBookiesChanged(Set&lt;BookieSocketAddress&gt; readOnlyBookies) {
<span class="fc" id="L136">        this.readOnlyBookies = readOnlyBookies;</span>
<span class="fc" id="L137">        placementPolicy.onClusterChanged(writableBookies, readOnlyBookies);</span>
<span class="fc" id="L138">    }</span>

    /**
     * Blocks until bookies are read from zookeeper, used in the {@link BookKeeper} constructor.
     *
     * @throws BKException when failed to read bookies
     */
    public void initialBlockingBookieRead() throws BKException {
        CompletableFuture&lt;?&gt; writable;
        CompletableFuture&lt;?&gt; readonly;
<span class="fc" id="L148">        synchronized (this) {</span>
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">            if (initialReadonlyBookiesFuture == null) {</span>
<span class="pc bpc" id="L150" title="2 of 4 branches missed.">                assert initialWritableBookiesFuture == null;</span>

<span class="fc" id="L152">                writable = this.registrationClient.watchWritableBookies(</span>
<span class="fc" id="L153">                            bookies -&gt; processWritableBookiesChanged(bookies.getValue()));</span>

<span class="fc" id="L155">                readonly = this.registrationClient.watchReadOnlyBookies(</span>
<span class="fc" id="L156">                            bookies -&gt; processReadOnlyBookiesChanged(bookies.getValue()));</span>
<span class="fc" id="L157">                initialWritableBookiesFuture = writable;</span>
<span class="fc" id="L158">                initialReadonlyBookiesFuture = readonly;</span>
            } else {
<span class="nc" id="L160">                writable = initialWritableBookiesFuture;</span>
<span class="nc" id="L161">                readonly = initialReadonlyBookiesFuture;</span>
            }
<span class="fc" id="L163">        }</span>

        try {
<span class="fc" id="L166">            FutureUtils.result(writable, EXCEPTION_FUNC);</span>
<span class="nc" id="L167">        } catch (BKInterruptedException ie) {</span>
<span class="nc" id="L168">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L169">            throw ie;</span>
<span class="fc" id="L170">        }</span>
        try {
<span class="fc" id="L172">            FutureUtils.result(readonly, EXCEPTION_FUNC);</span>
<span class="nc" id="L173">        } catch (BKInterruptedException ie) {</span>
<span class="nc" id="L174">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L175">            throw ie;</span>
<span class="nc" id="L176">        } catch (Exception e) {</span>
<span class="nc" id="L177">            log.error(&quot;Failed getReadOnlyBookies: &quot;, e);</span>
<span class="fc" id="L178">        }</span>
<span class="fc" id="L179">    }</span>

    /**
     * Create an ensemble with given &lt;i&gt;ensembleSize&lt;/i&gt; and &lt;i&gt;writeQuorumSize&lt;/i&gt;.
     *
     * @param ensembleSize
     *          Ensemble Size
     * @param writeQuorumSize
     *          Write Quorum Size
     * @return list of bookies for new ensemble.
     * @throws BKNotEnoughBookiesException
     */
    public ArrayList&lt;BookieSocketAddress&gt; newEnsemble(int ensembleSize, int writeQuorumSize,
        int ackQuorumSize, Map&lt;String, byte[]&gt; customMetadata)
            throws BKNotEnoughBookiesException {
        try {
            // we try to only get from the healthy bookies first
<span class="fc" id="L196">            return placementPolicy.newEnsemble(ensembleSize,</span>
                    writeQuorumSize, ackQuorumSize, customMetadata, new HashSet&lt;BookieSocketAddress&gt;(
<span class="fc" id="L198">                    quarantinedBookies.asMap().keySet()));</span>
<span class="nc" id="L199">        } catch (BKNotEnoughBookiesException e) {</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L201">                log.debug(&quot;Not enough healthy bookies available, using quarantined bookies&quot;);</span>
            }
<span class="nc" id="L203">            return placementPolicy.newEnsemble(</span>
<span class="nc" id="L204">                ensembleSize, writeQuorumSize, ackQuorumSize, customMetadata, Collections.emptySet());</span>
        }
    }

    /**
     * Choose a bookie to replace bookie &lt;i&gt;bookieIdx&lt;/i&gt; in &lt;i&gt;existingBookies&lt;/i&gt;.
     * @param existingBookies
     *          list of existing bookies.
     * @param bookieIdx
     *          index of the bookie in the list to be replaced.
     * @return the bookie to replace.
     * @throws BKNotEnoughBookiesException
     */
    public BookieSocketAddress replaceBookie(int ensembleSize, int writeQuorumSize, int ackQuorumSize,
                                             Map&lt;String, byte[]&gt; customMetadata,
                                             List&lt;BookieSocketAddress&gt; existingBookies, int bookieIdx,
                                             Set&lt;BookieSocketAddress&gt; excludeBookies)
            throws BKNotEnoughBookiesException {
<span class="nc" id="L222">        BookieSocketAddress addr = existingBookies.get(bookieIdx);</span>
        try {
            // we exclude the quarantined bookies also first
<span class="nc" id="L225">            Set&lt;BookieSocketAddress&gt; existingAndQuarantinedBookies = new HashSet&lt;BookieSocketAddress&gt;(existingBookies);</span>
<span class="nc" id="L226">            existingAndQuarantinedBookies.addAll(quarantinedBookies.asMap().keySet());</span>
<span class="nc" id="L227">            return placementPolicy.replaceBookie(ensembleSize, writeQuorumSize, ackQuorumSize, customMetadata,</span>
                    existingAndQuarantinedBookies, addr, excludeBookies);
<span class="nc" id="L229">        } catch (BKNotEnoughBookiesException e) {</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L231">                log.debug(&quot;Not enough healthy bookies available, using quarantined bookies&quot;);</span>
            }
<span class="nc" id="L233">            return placementPolicy.replaceBookie(ensembleSize, writeQuorumSize, ackQuorumSize, customMetadata,</span>
                    new HashSet&lt;BookieSocketAddress&gt;(existingBookies), addr, excludeBookies);
        }
    }

    /**
     * Quarantine &lt;i&gt;bookie&lt;/i&gt; so it will not be preferred to be chosen for new ensembles.
     * @param bookie
     * @return
     */
    public void quarantineBookie(BookieSocketAddress bookie) {
<span class="nc bnc" id="L244" title="All 2 branches missed.">        if (quarantinedBookies.getIfPresent(bookie) == null) {</span>
<span class="nc" id="L245">            quarantinedBookies.put(bookie, Boolean.TRUE);</span>
<span class="nc" id="L246">            log.warn(&quot;Bookie {} has been quarantined because of read/write errors.&quot;, bookie);</span>
        }
<span class="nc" id="L248">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>