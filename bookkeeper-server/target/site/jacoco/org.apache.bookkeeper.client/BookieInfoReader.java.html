<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BookieInfoReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.client</a> &gt; <span class="el_source">BookieInfoReader.java</span></div><h1>BookieInfoReader.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.bookkeeper.client;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import org.apache.bookkeeper.client.WeightedRandomSelection.WeightedObject;
import org.apache.bookkeeper.conf.ClientConfiguration;
import org.apache.bookkeeper.net.BookieSocketAddress;
import org.apache.bookkeeper.proto.BookieClient;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GetBookieInfoCallback;
import org.apache.bookkeeper.proto.BookkeeperProtocol;
import org.apache.commons.collections4.CollectionUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A utility class to read {@link BookieInfo} from bookies.
 *
 * &lt;p&gt;NOTE: This class is tended to be used by this project only. External users should not rely on it directly.
 */
<span class="pc bpc" id="L47" title="1 of 2 branches missed.">public class BookieInfoReader {</span>
<span class="fc" id="L48">    private static final Logger LOG = LoggerFactory.getLogger(BookieInfoReader.class);</span>
    private static final long GET_BOOKIE_INFO_REQUEST_FLAGS
        = BookkeeperProtocol.GetBookieInfoRequest.Flags.TOTAL_DISK_CAPACITY_VALUE |
                               BookkeeperProtocol.GetBookieInfoRequest.Flags.FREE_DISK_SPACE_VALUE;

    private final ScheduledExecutorService scheduler;
    private final BookKeeper bk;
    private final ClientConfiguration conf;

    /**
     * A class represents the information (e.g. disk usage, load) of a bookie.
     *
     * &lt;p&gt;NOTE: This class is tended to be used by this project only. External users should not rely on it directly.
     */
    public static class BookieInfo implements WeightedObject {
        private final long freeDiskSpace;
        private final long totalDiskSpace;
        public BookieInfo() {
<span class="nc" id="L66">            this(0L, 0L);</span>
<span class="nc" id="L67">        }</span>
<span class="nc" id="L68">        public BookieInfo(long totalDiskSpace, long freeDiskSpace) {</span>
<span class="nc" id="L69">            this.totalDiskSpace = totalDiskSpace;</span>
<span class="nc" id="L70">            this.freeDiskSpace = freeDiskSpace;</span>
<span class="nc" id="L71">        }</span>
        public long getFreeDiskSpace() {
<span class="nc" id="L73">            return freeDiskSpace;</span>
        }
        public long getTotalDiskSpace() {
<span class="nc" id="L76">            return totalDiskSpace;</span>
        }
        @Override
        public long getWeight() {
<span class="nc" id="L80">            return freeDiskSpace;</span>
        }
        public String toString() {
<span class="nc" id="L83">            return &quot;FreeDiskSpace: &quot; + this.freeDiskSpace + &quot; TotalDiskCapacity: &quot; + this.totalDiskSpace;</span>
        }
    }


    /**
     * Tracks the most recently reported set of bookies from BookieWatcher as well
     * as current BookieInfo for bookies we've successfully queried.
     */
<span class="fc" id="L92">    private static class BookieInfoMap {</span>
        /**
         * Contains the most recently obtained information on the contained bookies.
         * When an error happens querying a bookie, the entry is removed.
         */
<span class="fc" id="L97">        private final Map&lt;BookieSocketAddress, BookieInfo&gt; infoMap = new HashMap&lt;&gt;();</span>

        /**
         * Contains the most recently reported set of bookies from BookieWatcher
         * A partial query consists of every member of mostRecentlyReportedBookies
         * minus the entries in bookieInfoMap.
         */
<span class="fc" id="L104">        private Collection&lt;BookieSocketAddress&gt; mostRecentlyReportedBookies = new ArrayList&lt;&gt;();</span>

        public void updateBookies(Collection&lt;BookieSocketAddress&gt; updatedBookieSet) {
<span class="nc bnc" id="L107" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L108">                LOG.debug(</span>
                        &quot;updateBookies: current: {}, new: {}&quot;,
                        mostRecentlyReportedBookies, updatedBookieSet);
            }
<span class="nc" id="L112">            infoMap.keySet().retainAll(updatedBookieSet);</span>
<span class="nc" id="L113">            mostRecentlyReportedBookies = updatedBookieSet;</span>
<span class="nc" id="L114">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        public Collection&lt;BookieSocketAddress&gt; getPartialScanTargets() {
<span class="nc" id="L118">            return CollectionUtils.subtract(mostRecentlyReportedBookies, infoMap.keySet());</span>
        }

        public Collection&lt;BookieSocketAddress&gt; getFullScanTargets() {
<span class="nc" id="L122">            return mostRecentlyReportedBookies;</span>
        }

        /**
         * Returns info for bookie, null if not known
         *
         * @param bookie bookie for which to get info
         * @return Info for bookie, null otherwise
         */
        public BookieInfo getInfo(BookieSocketAddress bookie) {
<span class="nc" id="L132">            return infoMap.get(bookie);</span>
        }

        /**
         * Removes bookie from bookieInfoMap
         *
         * @param bookie bookie on which we observed an error
         */
        public void clearInfo(BookieSocketAddress bookie) {
<span class="nc" id="L141">            infoMap.remove(bookie);</span>
<span class="nc" id="L142">        }</span>

        /**
         * Report new info on bookie
         *
         * @param bookie bookie for which we obtained new info
         * @param info the new info
         */
        public void gotInfo(BookieSocketAddress bookie, BookieInfo info) {
<span class="nc" id="L151">            infoMap.put(bookie, info);</span>
<span class="nc" id="L152">        }</span>

        /**
         * Get bookie info map
         */
        public Map&lt;BookieSocketAddress, BookieInfo&gt; getBookieMap() {
<span class="nc" id="L158">            return infoMap;</span>
        }
    }
<span class="fc" id="L161">    private final BookieInfoMap bookieInfoMap = new BookieInfoMap();</span>

    /**
     * Tracks whether there is an execution in progress as well as whether
     * another is pending.
     */
<span class="fc" id="L167">    public enum State { UNQUEUED, PARTIAL, FULL }</span>
<span class="fc" id="L168">    private static class InstanceState {</span>
<span class="fc" id="L169">        private boolean running = false;</span>
<span class="fc" id="L170">        private State queuedType = State.UNQUEUED;</span>

        private boolean shouldStart() {
<span class="nc bnc" id="L173" title="All 2 branches missed.">            if (running) {</span>
<span class="nc" id="L174">                return false;</span>
            } else {
<span class="nc" id="L176">                running = true;</span>
<span class="nc" id="L177">                return true;</span>
            }
        }

        /**
         * Mark pending operation FULL and return true if there is no in-progress operation
         *
         * @return True if we should execute a scan, False if there is already one running
         */
        public boolean tryStartFull() {
<span class="nc" id="L187">            queuedType = State.FULL;</span>
<span class="nc" id="L188">            return shouldStart();</span>
        }

        /**
         * Mark pending operation PARTIAL if not full and return true if there is no in-progress operation
         *
         * @return True if we should execute a scan, False if there is already one running
         */
        public boolean tryStartPartial() {
<span class="nc bnc" id="L197" title="All 2 branches missed.">            if (queuedType == State.UNQUEUED) {</span>
<span class="nc" id="L198">                queuedType = State.PARTIAL;</span>
            }
<span class="nc" id="L200">            return shouldStart();</span>
        }

        /**
         * Gets and clears queuedType
         */
        public State getAndClearQueuedType() {
<span class="nc" id="L207">            State ret = queuedType;</span>
<span class="nc" id="L208">            queuedType = State.UNQUEUED;</span>
<span class="nc" id="L209">            return ret;</span>
        }

        /**
         * If queuedType != UNQUEUED, returns true, leaves running equal to true
         * Otherwise, returns false and sets running to false
         */
        public boolean completeUnlessQueued() {
<span class="nc bnc" id="L217" title="All 2 branches missed.">            if (queuedType == State.UNQUEUED) {</span>
<span class="nc" id="L218">                running = false;</span>
<span class="nc" id="L219">                return false;</span>
            } else {
<span class="nc" id="L221">                return true;</span>
            }
        }
    }
<span class="fc" id="L225">    private final InstanceState instanceState = new InstanceState();</span>

    BookieInfoReader(BookKeeper bk,
                     ClientConfiguration conf,
<span class="fc" id="L229">                     ScheduledExecutorService scheduler) {</span>
<span class="fc" id="L230">        this.bk = bk;</span>
<span class="fc" id="L231">        this.conf = conf;</span>
<span class="fc" id="L232">        this.scheduler = scheduler;</span>
<span class="fc" id="L233">    }</span>

    public void start() {
<span class="nc" id="L236">        this.bk.regClient.watchWritableBookies(bookies -&gt; availableBookiesChanged(bookies.getValue()));</span>
<span class="nc" id="L237">        scheduler.scheduleAtFixedRate(new Runnable() {</span>
            @Override
            public void run() {
<span class="nc" id="L240">                synchronized (BookieInfoReader.this) {</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">                    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L242">                        LOG.debug(&quot;Running periodic BookieInfo scan&quot;);</span>
                    }
                    try {
<span class="nc" id="L245">                        Collection&lt;BookieSocketAddress&gt; updatedBookies = bk.bookieWatcher.getBookies();</span>
<span class="nc" id="L246">                        bookieInfoMap.updateBookies(updatedBookies);</span>
<span class="nc" id="L247">                    } catch (BKException e) {</span>
<span class="nc" id="L248">                        LOG.info(&quot;Got exception while querying bookies from watcher, rerunning after {}s&quot;,</span>
<span class="nc" id="L249">                                 conf.getGetBookieInfoRetryIntervalSeconds(), e);</span>
<span class="nc" id="L250">                        scheduler.schedule(this, conf.getGetBookieInfoRetryIntervalSeconds(), TimeUnit.SECONDS);</span>
<span class="nc" id="L251">                        return;</span>
<span class="nc" id="L252">                    }</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">                    if (instanceState.tryStartFull()) {</span>
<span class="nc" id="L254">                        getReadWriteBookieInfo();</span>
                    }
<span class="nc" id="L256">                }</span>
<span class="nc" id="L257">            }</span>
<span class="nc" id="L258">        }, 0, conf.getGetBookieInfoIntervalSeconds(), TimeUnit.SECONDS);</span>
<span class="nc" id="L259">    }</span>

    private void submitTask() {
<span class="nc" id="L262">        scheduler.submit(() -&gt; getReadWriteBookieInfo());</span>
<span class="nc" id="L263">    }</span>

    private void submitTaskWithDelay(int delaySeconds) {
<span class="nc" id="L266">        scheduler.schedule(() -&gt; getReadWriteBookieInfo(), delaySeconds, TimeUnit.SECONDS);</span>
<span class="nc" id="L267">    }</span>

    synchronized void availableBookiesChanged(Set&lt;BookieSocketAddress&gt; updatedBookiesList) {
<span class="nc bnc" id="L270" title="All 2 branches missed.">        if (LOG.isInfoEnabled()) {</span>
<span class="nc" id="L271">            LOG.info(&quot;Scheduling bookie info read due to changes in available bookies.&quot;);</span>
        }
<span class="nc" id="L273">        bookieInfoMap.updateBookies(updatedBookiesList);</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">        if (instanceState.tryStartPartial()) {</span>
<span class="nc" id="L275">            submitTask();</span>
        }
<span class="nc" id="L277">    }</span>

    /**
     * Method to allow tests to block until bookie info is available
     *
     * @param bookie to lookup
     * @return None if absent, free disk space if present
     */
    synchronized Optional&lt;Long&gt; getFreeDiskSpace(BookieSocketAddress bookie) {
<span class="nc" id="L286">        BookieInfo bookieInfo = bookieInfoMap.getInfo(bookie);</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">        if (bookieInfo != null) {</span>
<span class="nc" id="L288">            return Optional.of(bookieInfo.getFreeDiskSpace());</span>
        } else {
<span class="nc" id="L290">            return Optional.empty();</span>
        }
    }

    /* State to track scan execution progress as callbacks come in */
<span class="fc" id="L295">    private int totalSent = 0;</span>
<span class="fc" id="L296">    private int completedCnt = 0;</span>
<span class="fc" id="L297">    private int errorCnt = 0;</span>

    /**
     * Performs scan described by instanceState using the cached bookie information
     * in bookieInfoMap.
     */
    synchronized void getReadWriteBookieInfo() {
<span class="nc" id="L304">        State queuedType = instanceState.getAndClearQueuedType();</span>
        Collection&lt;BookieSocketAddress&gt; toScan;
<span class="nc bnc" id="L306" title="All 2 branches missed.">        if (queuedType == State.FULL) {</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L308">                LOG.debug(&quot;Doing full scan&quot;);</span>
            }
<span class="nc" id="L310">            toScan = bookieInfoMap.getFullScanTargets();</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">        } else if (queuedType == State.PARTIAL) {</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L313">                LOG.debug(&quot;Doing partial scan&quot;);</span>
            }
<span class="nc" id="L315">            toScan = bookieInfoMap.getPartialScanTargets();</span>
        } else {
<span class="nc bnc" id="L317" title="All 2 branches missed.">            if (LOG.isErrorEnabled()) {</span>
<span class="nc" id="L318">                LOG.error(&quot;Invalid state, queuedType cannot be UNQUEUED in getReadWriteBookieInfo&quot;);</span>
            }
<span class="nc bnc" id="L320" title="All 4 branches missed.">            assert(queuedType != State.UNQUEUED);</span>
<span class="nc" id="L321">            return;</span>
        }

<span class="nc" id="L324">        BookieClient bkc = bk.getBookieClient();</span>
<span class="nc" id="L325">        final long requested = BookkeeperProtocol.GetBookieInfoRequest.Flags.TOTAL_DISK_CAPACITY_VALUE |</span>
                               BookkeeperProtocol.GetBookieInfoRequest.Flags.FREE_DISK_SPACE_VALUE;
<span class="nc" id="L327">        totalSent = 0;</span>
<span class="nc" id="L328">        completedCnt = 0;</span>
<span class="nc" id="L329">        errorCnt = 0;</span>

<span class="nc bnc" id="L331" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L332">            LOG.debug(&quot;Getting bookie info for: {}&quot;, toScan);</span>
        }
<span class="nc bnc" id="L334" title="All 2 branches missed.">        for (BookieSocketAddress b : toScan) {</span>
<span class="nc" id="L335">            bkc.getBookieInfo(b, requested,</span>
<span class="nc" id="L336">                    new GetBookieInfoCallback() {</span>
                        void processReadInfoComplete(int rc, BookieInfo bInfo, Object ctx) {
<span class="nc" id="L338">                            synchronized (BookieInfoReader.this) {</span>
<span class="nc" id="L339">                                BookieSocketAddress b = (BookieSocketAddress) ctx;</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">                                if (rc != BKException.Code.OK) {</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">                                    if (LOG.isErrorEnabled()) {</span>
<span class="nc" id="L342">                                        LOG.error(&quot;Reading bookie info from bookie {} failed due to error: {}.&quot;, b, rc);</span>
                                    }
                                    // We reread bookies missing from the map each time, so remove to ensure
                                    // we get to it on the next scan
<span class="nc" id="L346">                                    bookieInfoMap.clearInfo(b);</span>
<span class="nc" id="L347">                                    errorCnt++;</span>
                                } else {
<span class="nc bnc" id="L349" title="All 2 branches missed.">                                    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L350">                                        LOG.debug(&quot;Bookie Info for bookie {} is {}&quot;, b, bInfo);</span>
                                    }
<span class="nc" id="L352">                                    bookieInfoMap.gotInfo(b, bInfo);</span>
                                }
<span class="nc" id="L354">                                completedCnt++;</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">                                if (totalSent == completedCnt) {</span>
<span class="nc" id="L356">                                    onExit();</span>
                                }
<span class="nc" id="L358">                            }</span>
<span class="nc" id="L359">                        }</span>
                        @Override
                        public void getBookieInfoComplete(final int rc, final BookieInfo bInfo, final Object ctx) {
<span class="nc" id="L362">                            scheduler.submit(</span>
<span class="nc" id="L363">                                new Runnable() {</span>
                                    @Override
                                    public void run() {
<span class="nc" id="L366">                                        processReadInfoComplete(rc, bInfo, ctx);</span>
<span class="nc" id="L367">                                    }</span>
                                });
<span class="nc" id="L369">                        }</span>
                    }, b);
<span class="nc" id="L371">            totalSent++;</span>
<span class="nc" id="L372">        }</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">        if (totalSent == 0) {</span>
<span class="nc" id="L374">            onExit();</span>
        }
<span class="nc" id="L376">    }</span>

    void onExit() {
<span class="nc" id="L379">        bk.placementPolicy.updateBookieInfo(bookieInfoMap.getBookieMap());</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">        if (errorCnt &gt; 0) {</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">            if (LOG.isInfoEnabled()) {</span>
<span class="nc" id="L382">                LOG.info(&quot;Rescheduling in {}s due to errors&quot;, conf.getGetBookieInfoIntervalSeconds());</span>
            }
<span class="nc" id="L384">            instanceState.tryStartPartial();</span>
<span class="nc" id="L385">            submitTaskWithDelay(conf.getGetBookieInfoRetryIntervalSeconds());</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">        } else if (instanceState.completeUnlessQueued()) {</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">            if (LOG.isInfoEnabled()) {</span>
<span class="nc" id="L388">                LOG.info(&quot;Rescheduling, another scan is pending&quot;);</span>
            }
<span class="nc" id="L390">            submitTask();</span>
        }
<span class="nc" id="L392">    }</span>

    Map&lt;BookieSocketAddress, BookieInfo&gt; getBookieInfo() throws BKException, InterruptedException {
<span class="nc" id="L395">        BookieClient bkc = bk.getBookieClient();</span>
<span class="nc" id="L396">        final AtomicInteger totalSent = new AtomicInteger();</span>
<span class="nc" id="L397">        final AtomicInteger totalCompleted = new AtomicInteger();</span>
<span class="nc" id="L398">        final ConcurrentMap&lt;BookieSocketAddress, BookieInfo&gt; map = new ConcurrentHashMap&lt;BookieSocketAddress, BookieInfo&gt;();</span>
<span class="nc" id="L399">        final CountDownLatch latch = new CountDownLatch(1);</span>
<span class="nc" id="L400">        long requested = BookkeeperProtocol.GetBookieInfoRequest.Flags.TOTAL_DISK_CAPACITY_VALUE |</span>
                         BookkeeperProtocol.GetBookieInfoRequest.Flags.FREE_DISK_SPACE_VALUE;

        Collection&lt;BookieSocketAddress&gt; bookies;
<span class="nc" id="L404">        bookies = bk.bookieWatcher.getBookies();</span>
<span class="nc" id="L405">        bookies.addAll(bk.bookieWatcher.getReadOnlyBookies());</span>

<span class="nc" id="L407">        totalSent.set(bookies.size());</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">        for (BookieSocketAddress b : bookies) {</span>
<span class="nc" id="L409">            bkc.getBookieInfo(b, requested, new GetBookieInfoCallback() {</span>
                        @Override
                        public void getBookieInfoComplete(int rc, BookieInfo bInfo, Object ctx) {
<span class="nc" id="L412">                            BookieSocketAddress b = (BookieSocketAddress) ctx;</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">                            if (rc != BKException.Code.OK) {</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">                                if (LOG.isErrorEnabled()) {</span>
<span class="nc" id="L415">                                    LOG.error(&quot;Reading bookie info from bookie {} failed due to error: {}.&quot;, b, rc);</span>
                                }
                            } else {
<span class="nc bnc" id="L418" title="All 2 branches missed.">                                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L419">                                    LOG.debug(&quot;Free disk space on bookie {} is {}.&quot;, b, bInfo.getFreeDiskSpace());</span>
                                }
<span class="nc" id="L421">                                map.put(b, bInfo);</span>
                            }
<span class="nc bnc" id="L423" title="All 2 branches missed.">                            if (totalCompleted.incrementAndGet() == totalSent.get()) {</span>
<span class="nc" id="L424">                                latch.countDown();</span>
                            }
<span class="nc" id="L426">                        }</span>
                    }, b);
<span class="nc" id="L428">        }</span>
        try {
<span class="nc" id="L430">            latch.await();</span>
<span class="nc" id="L431">        } catch (InterruptedException e) {</span>
<span class="nc" id="L432">            LOG.error(&quot;Received InterruptedException &quot;, e);</span>
<span class="nc" id="L433">            throw e;</span>
<span class="nc" id="L434">        }</span>
<span class="nc" id="L435">        return map;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>