<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PendingAddOp.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.client</a> &gt; <span class="el_source">PendingAddOp.java</span></div><h1>PendingAddOp.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.bookkeeper.client;

import static com.google.common.base.Preconditions.checkNotNull;
import io.netty.buffer.ByteBuf;
import io.netty.util.Recycler;
import io.netty.util.Recycler.Handle;
import io.netty.util.ReferenceCountUtil;
import io.netty.util.Timeout;
import io.netty.util.TimerTask;

import java.util.Arrays;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import com.google.common.collect.ImmutableMap;
import org.apache.bookkeeper.client.AsyncCallback.AddCallback;
import org.apache.bookkeeper.net.BookieSocketAddress;
import org.apache.bookkeeper.proto.BookieProtocol;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;
import org.apache.bookkeeper.stats.OpStatsLogger;
import org.apache.bookkeeper.util.MathUtils;
import org.apache.bookkeeper.util.SafeRunnable;
import org.apache.commons.lang3.ArrayUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.concurrent.RejectedExecutionException;

/**
 * This represents a pending add operation. When it has got success from all
 * bookies, it sees if its at the head of the pending adds queue, and if yes,
 * sends ack back to the application. If a bookie fails, a replacement is made
 * and placed at the same position in the ensemble. The pending adds are then
 * rereplicated.
 *
 *
 */
class PendingAddOp extends SafeRunnable implements WriteCallback, TimerTask {
<span class="fc" id="L55">    private final static Logger LOG = LoggerFactory.getLogger(PendingAddOp.class);</span>

    ByteBuf payload;
    ByteBuf toSend;
    AddCallback cb;
    Object ctx;
    long entryId;
    int entryLength;

    DistributionSchedule.AckSet ackSet;
<span class="fc" id="L65">    boolean completed = false;</span>

    LedgerHandle lh;
<span class="fc" id="L68">    boolean isRecoveryAdd = false;</span>
    long requestTimeNanos;

    int timeoutSec;
<span class="fc" id="L72">    Timeout timeout = null;</span>

    OpStatsLogger addOpLogger;
    long currentLedgerLength;
    int pendingWriteRequests;
    boolean callbackTriggered;
    boolean hasRun;

    static PendingAddOp create(LedgerHandle lh, ByteBuf payload, AddCallback cb, Object ctx) {
<span class="fc" id="L81">        PendingAddOp op = RECYCLER.get();</span>
<span class="fc" id="L82">        op.lh = lh;</span>
<span class="fc" id="L83">        op.isRecoveryAdd = false;</span>
<span class="fc" id="L84">        op.cb = cb;</span>
<span class="fc" id="L85">        op.ctx = ctx;</span>
<span class="fc" id="L86">        op.entryId = LedgerHandle.INVALID_ENTRY_ID;</span>
<span class="fc" id="L87">        op.currentLedgerLength = -1;</span>
<span class="fc" id="L88">        op.payload = payload;</span>
<span class="fc" id="L89">        op.entryLength = payload.readableBytes();</span>

<span class="fc" id="L91">        op.completed = false;</span>
<span class="fc" id="L92">        op.ackSet = lh.distributionSchedule.getAckSet();</span>
<span class="fc" id="L93">        op.addOpLogger = lh.bk.getAddOpLogger();</span>
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">        if (op.timeout != null) {</span>
<span class="nc" id="L95">            op.timeout.cancel();</span>
        }
<span class="fc" id="L97">        op.timeout = null;</span>
<span class="fc" id="L98">        op.timeoutSec = lh.bk.getConf().getAddEntryQuorumTimeout();</span>
<span class="fc" id="L99">        op.pendingWriteRequests = 0;</span>
<span class="fc" id="L100">        op.callbackTriggered = false;</span>
<span class="fc" id="L101">        op.hasRun = false;</span>
<span class="fc" id="L102">        return op;</span>
    }

    /**
     * Enable the recovery add flag for this operation.
     * @see LedgerHandle#asyncRecoveryAddEntry
     */
    PendingAddOp enableRecoveryAdd() {
<span class="nc" id="L110">        isRecoveryAdd = true;</span>
<span class="nc" id="L111">        return this;</span>
    }

    void setEntryId(long entryId) {
<span class="fc" id="L115">        this.entryId = entryId;</span>
<span class="fc" id="L116">    }</span>

    void setLedgerLength(long ledgerLength) {
<span class="fc" id="L119">        this.currentLedgerLength = ledgerLength;</span>
<span class="fc" id="L120">    }</span>

    long getEntryId() {
<span class="nc" id="L123">        return this.entryId;</span>
    }

    void sendWriteRequest(int bookieIndex) {
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">        int flags = isRecoveryAdd ? BookieProtocol.FLAG_RECOVERY_ADD : BookieProtocol.FLAG_NONE;</span>

<span class="fc" id="L129">        lh.bk.getBookieClient().addEntry(lh.metadata.currentEnsemble.get(bookieIndex), lh.ledgerId, lh.ledgerKey, entryId, toSend,</span>
<span class="fc" id="L130">                this, bookieIndex, flags);</span>
<span class="fc" id="L131">        ++pendingWriteRequests;</span>
<span class="fc" id="L132">    }</span>

    @Override
    public void run(Timeout timeout) {
<span class="nc" id="L136">        timeoutQuorumWait();</span>
<span class="nc" id="L137">    }</span>

    void timeoutQuorumWait() {
        try {
<span class="nc" id="L141">            lh.bk.getMainWorkerPool().submitOrdered(lh.ledgerId, new SafeRunnable() {</span>
                @Override
                public void safeRun() {
<span class="nc bnc" id="L144" title="All 2 branches missed.">                    if (completed) {</span>
<span class="nc" id="L145">                        return;</span>
                    }
<span class="nc" id="L147">                    lh.handleUnrecoverableErrorDuringAdd(BKException.Code.AddEntryQuorumTimeoutException);</span>
<span class="nc" id="L148">                }</span>
                @Override
                public String toString() {
<span class="nc" id="L151">                    return String.format(&quot;AddEntryQuorumTimeout(lid=%d, eid=%d)&quot;, lh.ledgerId, entryId);</span>
                }
            });
<span class="nc" id="L154">        } catch (RejectedExecutionException e) {</span>
<span class="nc" id="L155">            LOG.warn(&quot;Timeout add entry quorum wait failed {} entry: {}&quot;, lh.ledgerId, entryId);</span>
<span class="nc" id="L156">        }</span>
<span class="nc" id="L157">    }</span>

    void unsetSuccessAndSendWriteRequest(int bookieIndex) {
<span class="nc bnc" id="L160" title="All 2 branches missed.">        if (toSend == null) {</span>
            // this addOp hasn't yet had its mac computed. When the mac is
            // computed, its write requests will be sent, so no need to send it
            // now
<span class="nc" id="L164">            return;</span>
        }
        // Suppose that unset doesn't happen on the write set of an entry. In this
        // case we don't need to resend the write request upon an ensemble change.
        // We do need to invoke #sendAddSuccessCallbacks() for such entries because
        // they may have already completed, but they are just waiting for the ensemble
        // to change.
        // E.g.
        // ensemble (A, B, C, D), entry k is written to (A, B, D). An ensemble change
        // happens to replace C with E. Entry k does not complete until C is
        // replaced with E successfully. When the ensemble change completes, it tries
        // to unset entry k. C however is not in k's write set, so no entry is written
        // again, and no one triggers #sendAddSuccessCallbacks. Consequently, k never
        // completes.
        //
        // We call sendAddSuccessCallback when unsetting t cover this case.
<span class="nc" id="L180">        DistributionSchedule.WriteSet writeSet</span>
<span class="nc" id="L181">            = lh.distributionSchedule.getWriteSet(entryId);</span>
        try {
<span class="nc bnc" id="L183" title="All 2 branches missed.">            if (!writeSet.contains(bookieIndex)) {</span>
<span class="nc" id="L184">                lh.sendAddSuccessCallbacks();</span>
<span class="nc" id="L185">                return;</span>
            }
        } finally {
<span class="nc" id="L188">            writeSet.recycle();</span>
        }

<span class="nc bnc" id="L191" title="All 2 branches missed.">        if (callbackTriggered) {</span>
<span class="nc" id="L192">            return;</span>
        }

<span class="nc bnc" id="L195" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L196">            LOG.debug(&quot;Unsetting success for ledger: &quot; + lh.ledgerId + &quot; entry: &quot; + entryId + &quot; bookie index: &quot;</span>
                      + bookieIndex);
        }

        // if we had already heard a success from this array index, need to
        // increment our number of responses that are pending, since we are
        // going to unset this success
<span class="nc bnc" id="L203" title="All 2 branches missed.">        if (!ackSet.removeBookieAndCheck(bookieIndex)) {</span>
            // unset completed if this results in loss of ack quorum
<span class="nc" id="L205">            completed = false;</span>
        }

<span class="nc" id="L208">        sendWriteRequest(bookieIndex);</span>
<span class="nc" id="L209">    }</span>

    /**
     * Initiate the add operation
     */
    public void safeRun() {
<span class="fc" id="L215">        hasRun = true;</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">        if (callbackTriggered) {</span>
            // this should only be true if the request was failed due
            // to another request ahead in the pending queue,
            // so we can just ignore this request
<span class="nc" id="L220">            maybeRecycle();</span>
<span class="nc" id="L221">            return;</span>
        }

<span class="pc bpc" id="L224" title="1 of 2 branches missed.">        if (timeoutSec &gt; -1) {</span>
<span class="nc" id="L225">            this.timeout = lh.bk.getBookieClient().scheduleTimeout(</span>
                    this, timeoutSec, TimeUnit.SECONDS);
        }

<span class="fc" id="L229">        this.requestTimeNanos = MathUtils.nowInNano();</span>
<span class="fc" id="L230">        checkNotNull(lh);</span>
<span class="fc" id="L231">        checkNotNull(lh.macManager);</span>

<span class="fc" id="L233">        this.toSend = lh.macManager.computeDigestAndPackageForSending(</span>
                entryId, lh.lastAddConfirmed, currentLedgerLength,
                payload);

        // Iterate over set and trigger the sendWriteRequests
<span class="fc" id="L238">        DistributionSchedule.WriteSet writeSet</span>
<span class="fc" id="L239">            = lh.distributionSchedule.getWriteSet(entryId);</span>
        try {
<span class="fc bfc" id="L241" title="All 2 branches covered.">            for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="fc" id="L242">                sendWriteRequest(writeSet.get(i));</span>
            }
        } finally {
<span class="fc" id="L245">            writeSet.recycle();</span>
        }
<span class="fc" id="L247">    }</span>

    @Override
    public void writeComplete(int rc, long ledgerId, long entryId, BookieSocketAddress addr, Object ctx) {
<span class="fc" id="L251">        int bookieIndex = (Integer) ctx;</span>
<span class="fc" id="L252">        --pendingWriteRequests;</span>

<span class="pc bpc" id="L254" title="1 of 2 branches missed.">        if (!lh.metadata.currentEnsemble.get(bookieIndex).equals(addr)) {</span>
            // ensemble has already changed, failure of this addr is immaterial
<span class="nc bnc" id="L256" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L257">                LOG.debug(&quot;Write did not succeed: &quot; + ledgerId + &quot;, &quot; + entryId + &quot;. But we have already fixed it.&quot;);</span>
            }
<span class="nc" id="L259">            return;</span>
        }

        // must record all acks, even if complete (completion can be undone by an ensemble change)
<span class="fc" id="L263">        boolean ackQuorum = false;</span>
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">        if (BKException.Code.OK == rc) {</span>
<span class="fc" id="L265">            ackQuorum = ackSet.completeBookieAndCheck(bookieIndex);</span>
        }

<span class="pc bpc" id="L268" title="1 of 2 branches missed.">        if (completed) {</span>
            // even the add operation is completed, but because we don't reset completed flag back to false when
            // #unsetSuccessAndSendWriteRequest doesn't break ack quorum constraint. we still have current pending
            // add op is completed but never callback. so do a check here to complete again.
            //
            // E.g. entry x is going to complete.
            //
            // 1) entry x + k hits a failure. lh.handleBookieFailure increases blockAddCompletions to 1, for ensemble change
            // 2) entry x receives all responses, sets completed to true but fails to send success callback because
            //    blockAddCompletions is 1
            // 3) ensemble change completed. lh unset success starting from x to x+k, but since the unset doesn't break ackSet
            //    constraint. #removeBookieAndCheck doesn't set completed back to false.
            // 4) so when the retry request on new bookie completes, it finds the pending op is already completed.
            //    we have to trigger #sendAddSuccessCallbacks
            //
<span class="nc" id="L283">            sendAddSuccessCallbacks();</span>
            // I am already finished, ignore incoming responses.
            // otherwise, we might hit the following error handling logic, which might cause bad things.
<span class="nc" id="L286">            maybeRecycle();</span>
<span class="nc" id="L287">            return;</span>
        }

<span class="pc bpc" id="L290" title="4 of 5 branches missed.">        switch (rc) {</span>
        case BKException.Code.OK:
            // continue
<span class="fc" id="L293">            break;</span>
        case BKException.Code.ClientClosedException:
            // bookie client is closed.
<span class="nc" id="L296">            lh.errorOutPendingAdds(rc);</span>
<span class="nc" id="L297">            return;</span>
        case BKException.Code.LedgerFencedException:
<span class="nc" id="L299">            LOG.warn(&quot;Fencing exception on write: L{} E{} on {}&quot;,</span>
<span class="nc" id="L300">                     new Object[] { ledgerId, entryId, addr });</span>
<span class="nc" id="L301">            lh.handleUnrecoverableErrorDuringAdd(rc);</span>
<span class="nc" id="L302">            return;</span>
        case BKException.Code.UnauthorizedAccessException:
<span class="nc" id="L304">            LOG.warn(&quot;Unauthorized access exception on write: L{} E{} on {}&quot;,</span>
<span class="nc" id="L305">                     new Object[] { ledgerId, entryId, addr });</span>
<span class="nc" id="L306">            lh.handleUnrecoverableErrorDuringAdd(rc);</span>
<span class="nc" id="L307">            return;</span>
        default:
<span class="nc bnc" id="L309" title="All 2 branches missed.">            if (lh.bk.delayEnsembleChange) {</span>
<span class="nc bnc" id="L310" title="All 4 branches missed.">                if (ackSet.failBookieAndCheck(bookieIndex, addr) || rc == BKException.Code.WriteOnReadOnlyBookieException) {</span>
<span class="nc" id="L311">                    Map&lt;Integer, BookieSocketAddress&gt; failedBookies = ackSet.getFailedBookies();</span>
<span class="nc" id="L312">                    LOG.warn(&quot;Failed to write entry ({}, {}) to bookies {}, handling failures.&quot;,</span>
<span class="nc" id="L313">                             new Object[] { ledgerId, entryId, failedBookies });</span>
                    // we can't meet ack quorum requirement, trigger ensemble change.
<span class="nc" id="L315">                    lh.handleBookieFailure(failedBookies);</span>
<span class="nc" id="L316">                } else {</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">                    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L318">                        LOG.debug(&quot;Failed to write entry ({}, {}) to bookie ({}, {}),&quot; +</span>
                                  &quot; but it didn't break ack quorum, delaying ensemble change : {}&quot;,
<span class="nc" id="L320">                                  new Object[] { ledgerId, entryId, bookieIndex, addr, BKException.getMessage(rc) });</span>
                    }
                }
            } else {
<span class="nc" id="L324">                LOG.warn(&quot;Failed to write entry ({}, {}): {}&quot;,</span>
<span class="nc" id="L325">                         new Object[] { ledgerId, entryId, BKException.getMessage(rc) });</span>
<span class="nc" id="L326">                lh.handleBookieFailure(ImmutableMap.of(bookieIndex, addr));</span>
            }
<span class="nc" id="L328">            return;</span>
        }

<span class="pc bpc" id="L331" title="1 of 4 branches missed.">        if (ackQuorum &amp;&amp; !completed) {</span>
<span class="fc" id="L332">            completed = true;</span>

<span class="fc" id="L334">            sendAddSuccessCallbacks();</span>
        }
<span class="fc" id="L336">    }</span>

    void sendAddSuccessCallbacks() {
<span class="fc" id="L339">        lh.sendAddSuccessCallbacks();</span>
<span class="fc" id="L340">    }</span>

    void submitCallback(final int rc) {
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">        if (null != timeout) {</span>
<span class="nc" id="L344">            timeout.cancel();</span>
        }

<span class="pc bpc" id="L347" title="1 of 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L348">            LOG.debug(&quot;Submit callback (lid:{}, eid: {}). rc:{}&quot;, lh.getId(), entryId, rc);</span>
        }

<span class="fc" id="L351">        long latencyNanos = MathUtils.elapsedNanos(requestTimeNanos);</span>
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">        if (rc != BKException.Code.OK) {</span>
<span class="nc" id="L353">            addOpLogger.registerFailedEvent(latencyNanos, TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L354">            LOG.error(&quot;Write of ledger entry to quorum failed: L{} E{}&quot;,</span>
<span class="nc" id="L355">                      lh.getId(), entryId);</span>
        } else {
<span class="fc" id="L357">            addOpLogger.registerSuccessfulEvent(latencyNanos, TimeUnit.NANOSECONDS);</span>
        }
<span class="fc" id="L359">        cb.addComplete(rc, lh, entryId, ctx);</span>
<span class="fc" id="L360">        callbackTriggered = true;</span>

<span class="fc" id="L362">        maybeRecycle();</span>
<span class="fc" id="L363">    }</span>

    @Override
    public String toString() {
<span class="nc" id="L367">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L368">        sb.append(&quot;PendingAddOp(lid:&quot;).append(lh.ledgerId)</span>
<span class="nc" id="L369">          .append(&quot;, eid:&quot;).append(entryId).append(&quot;, completed:&quot;)</span>
<span class="nc" id="L370">          .append(completed).append(&quot;)&quot;);</span>
<span class="nc" id="L371">        return sb.toString();</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L376">        return (int) entryId;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L381" title="All 2 branches missed.">       if (o instanceof PendingAddOp) {</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">           return (this.entryId == ((PendingAddOp)o).entryId);</span>
       }
<span class="nc bnc" id="L384" title="All 2 branches missed.">       return (this == o);</span>
    }

    private final Handle&lt;PendingAddOp&gt; recyclerHandle;
<span class="fc" id="L388">    private static final Recycler&lt;PendingAddOp&gt; RECYCLER = new Recycler&lt;PendingAddOp&gt;() {</span>
        protected PendingAddOp newObject(Recycler.Handle&lt;PendingAddOp&gt; handle) {
<span class="fc" id="L390">            return new PendingAddOp(handle);</span>
        }
    };

<span class="fc" id="L394">    private PendingAddOp(Handle&lt;PendingAddOp&gt; recyclerHandle) {</span>
<span class="fc" id="L395">        this.recyclerHandle = recyclerHandle;</span>
<span class="fc" id="L396">    }</span>

    private void maybeRecycle() {
        // The reference to PendingAddOp can be held in 3 places
        // - LedgerHandle#pendingAddOp
        //   This reference is released when the callback is run
        // - The executor
        //   Released after safeRun finishes
        // - BookieClient
        //   Holds a reference from the point the addEntry requests are
        //   sent.
        // The object can only be recycled after all references are
        // released, otherwise we could end up recycling twice and all
        // joy that goes along with that.
<span class="pc bpc" id="L410" title="3 of 6 branches missed.">        if (hasRun &amp;&amp; callbackTriggered &amp;&amp; pendingWriteRequests == 0) {</span>
<span class="fc" id="L411">            recycle();</span>
        }
<span class="fc" id="L413">    }</span>

    private void recycle() {
<span class="fc" id="L416">        entryId = LedgerHandle.INVALID_ENTRY_ID;</span>
<span class="fc" id="L417">        currentLedgerLength = -1;</span>
<span class="fc" id="L418">        ReferenceCountUtil.release(toSend);</span>
<span class="fc" id="L419">        payload = null;</span>
<span class="fc" id="L420">        toSend = null;</span>
<span class="fc" id="L421">        cb = null;</span>
<span class="fc" id="L422">        ctx = null;</span>
<span class="fc" id="L423">        ackSet.recycle();</span>
<span class="fc" id="L424">        ackSet = null;</span>
<span class="fc" id="L425">        lh = null;</span>
<span class="fc" id="L426">        isRecoveryAdd = false;</span>
<span class="fc" id="L427">        addOpLogger = null;</span>
<span class="fc" id="L428">        completed = false;</span>
<span class="fc" id="L429">        pendingWriteRequests = 0;</span>
<span class="fc" id="L430">        callbackTriggered = false;</span>
<span class="fc" id="L431">        hasRun = false;</span>
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">        if (timeout != null) {</span>
<span class="nc" id="L433">            timeout.cancel();</span>
        }
<span class="fc" id="L435">        timeout = null;</span>

<span class="fc" id="L437">        recyclerHandle.recycle(this);</span>
<span class="fc" id="L438">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>