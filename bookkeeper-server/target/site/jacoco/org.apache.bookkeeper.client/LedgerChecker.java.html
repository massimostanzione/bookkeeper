<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LedgerChecker.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.client</a> &gt; <span class="el_source">LedgerChecker.java</span></div><h1>LedgerChecker.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.bookkeeper.client;

import io.netty.buffer.ByteBuf;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import org.apache.bookkeeper.net.BookieSocketAddress;
import org.apache.bookkeeper.proto.BookieClient;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A utility class to check the complete ledger and finds the UnderReplicated fragments if any.
 *
 * &lt;p&gt;NOTE: This class is tended to be used by this project only. External users should not rely on it directly.
 */
public class LedgerChecker {
<span class="nc" id="L44">    private final static Logger LOG = LoggerFactory.getLogger(LedgerChecker.class);</span>

    public final BookieClient bookieClient;

<span class="nc" id="L48">    static class InvalidFragmentException extends Exception {</span>
        private static final long serialVersionUID = 1467201276417062353L;
    }

    /**
     * This will collect all the entry read call backs and finally it will give
     * call back to previous call back API which is waiting for it once it meets
     * the expected call backs from down
     */
    private static class ReadManyEntriesCallback implements ReadEntryCallback {
<span class="nc" id="L58">        AtomicBoolean completed = new AtomicBoolean(false);</span>
        final AtomicLong numEntries;
        final LedgerFragment fragment;
        final GenericCallback&lt;LedgerFragment&gt; cb;

        ReadManyEntriesCallback(long numEntries, LedgerFragment fragment,
<span class="nc" id="L64">                GenericCallback&lt;LedgerFragment&gt; cb) {</span>
<span class="nc" id="L65">            this.numEntries = new AtomicLong(numEntries);</span>
<span class="nc" id="L66">            this.fragment = fragment;</span>
<span class="nc" id="L67">            this.cb = cb;</span>
<span class="nc" id="L68">        }</span>

        public void readEntryComplete(int rc, long ledgerId, long entryId,
                ByteBuf buffer, Object ctx) {
<span class="nc bnc" id="L72" title="All 2 branches missed.">            if (rc == BKException.Code.OK) {</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">                if (numEntries.decrementAndGet() == 0</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">                        &amp;&amp; !completed.getAndSet(true)) {</span>
<span class="nc" id="L75">                    cb.operationComplete(rc, fragment);</span>
                }
<span class="nc bnc" id="L77" title="All 2 branches missed.">            } else if (!completed.getAndSet(true)) {</span>
<span class="nc" id="L78">                cb.operationComplete(rc, fragment);</span>
            }
<span class="nc" id="L80">        }</span>
    }

    /**
     * This will collect the bad bookies inside a ledger fragment.
     */
    private static class LedgerFragmentCallback implements GenericCallback&lt;LedgerFragment&gt; {

        private final LedgerFragment fragment;
        private final int bookieIndex;
        // bookie index -&gt; return code
        private final Map&lt;Integer, Integer&gt; badBookies;
        private final AtomicInteger numBookies;
        private final GenericCallback&lt;LedgerFragment&gt; cb;

        LedgerFragmentCallback(LedgerFragment lf,
                               int bookieIndex,
                               GenericCallback&lt;LedgerFragment&gt; cb,
                               Map&lt;Integer, Integer&gt; badBookies,
<span class="nc" id="L99">                               AtomicInteger numBookies) {</span>
<span class="nc" id="L100">            this.fragment = lf;</span>
<span class="nc" id="L101">            this.bookieIndex = bookieIndex;</span>
<span class="nc" id="L102">            this.cb = cb;</span>
<span class="nc" id="L103">            this.badBookies = badBookies;</span>
<span class="nc" id="L104">            this.numBookies = numBookies;</span>
<span class="nc" id="L105">        }</span>

        @Override
        public void operationComplete(int rc, LedgerFragment lf) {
<span class="nc bnc" id="L109" title="All 2 branches missed.">            if (BKException.Code.OK != rc) {</span>
<span class="nc" id="L110">                synchronized (badBookies) {</span>
<span class="nc" id="L111">                    badBookies.put(bookieIndex, rc);</span>
<span class="nc" id="L112">                }</span>
            }
<span class="nc bnc" id="L114" title="All 2 branches missed.">            if (numBookies.decrementAndGet() == 0) {</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">                if (badBookies.isEmpty()) {</span>
<span class="nc" id="L116">                    cb.operationComplete(BKException.Code.OK, fragment);</span>
                } else {
<span class="nc" id="L118">                    int rcToReturn = BKException.Code.NoBookieAvailableException;</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">                    for (Map.Entry&lt;Integer, Integer&gt; entry : badBookies.entrySet()) {</span>
<span class="nc" id="L120">                        rcToReturn = entry.getValue();</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">                        if (entry.getValue() == BKException.Code.ClientClosedException) {</span>
<span class="nc" id="L122">                            break;</span>
                        }
<span class="nc" id="L124">                    }</span>
<span class="nc" id="L125">                    cb.operationComplete(rcToReturn,</span>
<span class="nc" id="L126">                            fragment.subset(badBookies.keySet()));</span>
                }
            }
<span class="nc" id="L129">        }</span>
    }

<span class="nc" id="L132">    public LedgerChecker(BookKeeper bkc) {</span>
<span class="nc" id="L133">        bookieClient = bkc.getBookieClient();</span>
<span class="nc" id="L134">    }</span>

    /**
     * Verify a ledger fragment to collect bad bookies
     *
     * @param fragment
     *          fragment to verify
     * @param cb
     *          callback
     * @throws InvalidFragmentException
     */
    private void verifyLedgerFragment(LedgerFragment fragment,
                                      GenericCallback&lt;LedgerFragment&gt; cb)
            throws InvalidFragmentException, BKException {
<span class="nc" id="L148">        Set&lt;Integer&gt; bookiesToCheck = fragment.getBookiesIndexes();</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">        if (bookiesToCheck.isEmpty()) {</span>
<span class="nc" id="L150">            cb.operationComplete(BKException.Code.OK, fragment);</span>
<span class="nc" id="L151">            return;</span>
        }

<span class="nc" id="L154">        AtomicInteger numBookies = new AtomicInteger(bookiesToCheck.size());</span>
<span class="nc" id="L155">        Map&lt;Integer, Integer&gt; badBookies = new HashMap&lt;Integer, Integer&gt;();</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">        for (Integer bookieIndex : bookiesToCheck) {</span>
<span class="nc" id="L157">            LedgerFragmentCallback lfCb = new LedgerFragmentCallback(</span>
<span class="nc" id="L158">                    fragment, bookieIndex, cb, badBookies, numBookies);</span>
<span class="nc" id="L159">            verifyLedgerFragment(fragment, bookieIndex, lfCb);</span>
<span class="nc" id="L160">        }</span>
<span class="nc" id="L161">    }</span>

    /**
     * Verify a bookie inside a ledger fragment.
     *
     * @param fragment
     *          ledger fragment
     * @param bookieIndex
     *          bookie index in the fragment
     * @param cb
     *          callback
     * @throws InvalidFragmentException
     */
    private void verifyLedgerFragment(LedgerFragment fragment,
                                      int bookieIndex,
                                      GenericCallback&lt;LedgerFragment&gt; cb)
            throws InvalidFragmentException {
<span class="nc" id="L178">        long firstStored = fragment.getFirstStoredEntryId(bookieIndex);</span>
<span class="nc" id="L179">        long lastStored = fragment.getLastStoredEntryId(bookieIndex);</span>

<span class="nc" id="L181">        BookieSocketAddress bookie = fragment.getAddress(bookieIndex);</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">        if (null == bookie) {</span>
<span class="nc" id="L183">            throw new InvalidFragmentException();</span>
        }

<span class="nc bnc" id="L186" title="All 2 branches missed.">        if (firstStored == LedgerHandle.INVALID_ENTRY_ID) {</span>
            // this fragment is not on this bookie
<span class="nc bnc" id="L188" title="All 2 branches missed.">            if (lastStored != LedgerHandle.INVALID_ENTRY_ID) {</span>
<span class="nc" id="L189">                throw new InvalidFragmentException();</span>
            }
<span class="nc" id="L191">            cb.operationComplete(BKException.Code.OK, fragment);</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">        } else if (firstStored == lastStored) {</span>
<span class="nc" id="L193">            ReadManyEntriesCallback manycb = new ReadManyEntriesCallback(1,</span>
                    fragment, cb);
<span class="nc" id="L195">            bookieClient.readEntry(bookie, fragment</span>
<span class="nc" id="L196">                    .getLedgerId(), firstStored, manycb, null);</span>
<span class="nc" id="L197">        } else {</span>
<span class="nc" id="L198">            ReadManyEntriesCallback manycb = new ReadManyEntriesCallback(2,</span>
                    fragment, cb);
<span class="nc" id="L200">            bookieClient.readEntry(bookie, fragment.getLedgerId(), firstStored, manycb, null);</span>
<span class="nc" id="L201">            bookieClient.readEntry(bookie, fragment.getLedgerId(), lastStored, manycb, null);</span>
        }
<span class="nc" id="L203">    }</span>

    /**
     * Callback for checking whether an entry exists or not.
     * It is used to differentiate the cases where it has been written
     * but now cannot be read, and where it never has been written.
     */
    private static class EntryExistsCallback implements ReadEntryCallback {
<span class="nc" id="L211">        AtomicBoolean entryMayExist = new AtomicBoolean(false);</span>
        final AtomicInteger numReads;
        final GenericCallback&lt;Boolean&gt; cb;

        EntryExistsCallback(int numReads,
<span class="nc" id="L216">                            GenericCallback&lt;Boolean&gt; cb) {</span>
<span class="nc" id="L217">            this.numReads = new AtomicInteger(numReads);</span>
<span class="nc" id="L218">            this.cb = cb;</span>
<span class="nc" id="L219">        }</span>

        public void readEntryComplete(int rc, long ledgerId, long entryId,
                                      ByteBuf buffer, Object ctx) {
<span class="nc bnc" id="L223" title="All 4 branches missed.">            if (BKException.Code.NoSuchEntryException != rc &amp;&amp;</span>
                BKException.Code.NoSuchLedgerExistsException != rc) {
<span class="nc" id="L225">                entryMayExist.set(true);</span>
            }

<span class="nc bnc" id="L228" title="All 2 branches missed.">            if (numReads.decrementAndGet() == 0) {</span>
<span class="nc" id="L229">                cb.operationComplete(rc, entryMayExist.get());</span>
            }
<span class="nc" id="L231">        }</span>
    }

    /**
     * This will collect all the fragment read call backs and finally it will
     * give call back to above call back API which is waiting for it once it
     * meets the expected call backs from down
     */
    private static class FullLedgerCallback implements
            GenericCallback&lt;LedgerFragment&gt; {
        final Set&lt;LedgerFragment&gt; badFragments;
        final AtomicLong numFragments;
        final GenericCallback&lt;Set&lt;LedgerFragment&gt;&gt; cb;

        FullLedgerCallback(long numFragments,
<span class="nc" id="L246">                GenericCallback&lt;Set&lt;LedgerFragment&gt;&gt; cb) {</span>
<span class="nc" id="L247">            badFragments = new HashSet&lt;LedgerFragment&gt;();</span>
<span class="nc" id="L248">            this.numFragments = new AtomicLong(numFragments);</span>
<span class="nc" id="L249">            this.cb = cb;</span>
<span class="nc" id="L250">        }</span>

        public void operationComplete(int rc, LedgerFragment result) {
<span class="nc bnc" id="L253" title="All 2 branches missed.">            if (rc == BKException.Code.ClientClosedException) {</span>
<span class="nc" id="L254">                cb.operationComplete(BKException.Code.ClientClosedException, badFragments);</span>
<span class="nc" id="L255">                return;</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">            } else if (rc != BKException.Code.OK) {</span>
<span class="nc" id="L257">                badFragments.add(result);</span>
            }
<span class="nc bnc" id="L259" title="All 2 branches missed.">            if (numFragments.decrementAndGet() == 0) {</span>
<span class="nc" id="L260">                cb.operationComplete(BKException.Code.OK, badFragments);</span>
            }
<span class="nc" id="L262">        }</span>
    }

    /**
     * Check that all the fragments in the passed in ledger, and report those
     * which are missing.
     */
    public void checkLedger(final LedgerHandle lh,
                            final GenericCallback&lt;Set&lt;LedgerFragment&gt;&gt; cb) {
        // build a set of all fragment replicas
<span class="nc" id="L272">        final Set&lt;LedgerFragment&gt; fragments = new HashSet&lt;LedgerFragment&gt;();</span>

<span class="nc" id="L274">        Long curEntryId = null;</span>
<span class="nc" id="L275">        ArrayList&lt;BookieSocketAddress&gt; curEnsemble = null;</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">        for (Map.Entry&lt;Long, ArrayList&lt;BookieSocketAddress&gt;&gt; e : lh</span>
<span class="nc" id="L277">                .getLedgerMetadata().getEnsembles().entrySet()) {</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">            if (curEntryId != null) {</span>
<span class="nc" id="L279">                Set&lt;Integer&gt; bookieIndexes = new HashSet&lt;Integer&gt;();</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">                for (int i = 0; i &lt; curEnsemble.size(); i++) {</span>
<span class="nc" id="L281">                    bookieIndexes.add(i);</span>
                }
<span class="nc" id="L283">                fragments.add(new LedgerFragment(lh, curEntryId,</span>
<span class="nc" id="L284">                        e.getKey() - 1, bookieIndexes));</span>
            }
<span class="nc" id="L286">            curEntryId = e.getKey();</span>
<span class="nc" id="L287">            curEnsemble = e.getValue();</span>
<span class="nc" id="L288">        }</span>




        /* Checking the last segment of the ledger can be complicated in some cases.
         * In the case that the ledger is closed, we can just check the fragments of
         * the segment as normal even if no data has ever been written to.
         * In the case that the ledger is open, but enough entries have been written,
         * for lastAddConfirmed to be set above the start entry of the segment, we
         * can also check as normal.
         * However, if ledger is open, sometimes lastAddConfirmed cannot be trusted,
         * such as when it's lower than the first entry id, or not set at all,
         * we cannot be sure if there has been data written to the segment.
         * For this reason, we have to send a read request
         * to the bookies which should have the first entry. If they respond with
         * NoSuchEntry we can assume it was never written. If they respond with anything
         * else, we must assume the entry has been written, so we run the check.
         */
<span class="nc bnc" id="L307" title="All 2 branches missed.">        if (curEntryId != null) {</span>
<span class="nc" id="L308">            long lastEntry = lh.getLastAddConfirmed();</span>

<span class="nc bnc" id="L310" title="All 4 branches missed.">            if (!lh.isClosed() &amp;&amp; lastEntry &lt; curEntryId) {</span>
<span class="nc" id="L311">                lastEntry = curEntryId;</span>
            }

<span class="nc" id="L314">            Set&lt;Integer&gt; bookieIndexes = new HashSet&lt;Integer&gt;();</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">            for (int i = 0; i &lt; curEnsemble.size(); i++) {</span>
<span class="nc" id="L316">                bookieIndexes.add(i);</span>
            }
<span class="nc" id="L318">            final LedgerFragment lastLedgerFragment = new LedgerFragment(lh, curEntryId,</span>
                    lastEntry, bookieIndexes);

            // Check for the case that no last confirmed entry has been set
<span class="nc bnc" id="L322" title="All 2 branches missed.">            if (curEntryId == lastEntry) {</span>
<span class="nc" id="L323">                final long entryToRead = curEntryId;</span>

<span class="nc" id="L325">                final EntryExistsCallback eecb</span>
<span class="nc" id="L326">                    = new EntryExistsCallback(lh.getLedgerMetadata().getWriteQuorumSize(),</span>
<span class="nc" id="L327">                                              new GenericCallback&lt;Boolean&gt;() {</span>
                                                  public void operationComplete(int rc, Boolean result) {
<span class="nc bnc" id="L329" title="All 2 branches missed.">                                                      if (result) {</span>
<span class="nc" id="L330">                                                          fragments.add(lastLedgerFragment);</span>
                                                      }
<span class="nc" id="L332">                                                      checkFragments(fragments, cb);</span>
<span class="nc" id="L333">                                                  }</span>
                                              });

<span class="nc" id="L336">                DistributionSchedule.WriteSet writeSet</span>
<span class="nc" id="L337">                    = lh.getDistributionSchedule().getWriteSet(entryToRead);</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">                for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L339">                    BookieSocketAddress addr = curEnsemble.get(writeSet.get(i));</span>
<span class="nc" id="L340">                    bookieClient.readEntry(addr, lh.getId(), entryToRead, eecb, null);</span>
                }
<span class="nc" id="L342">                writeSet.recycle();</span>
<span class="nc" id="L343">                return;</span>
            } else {
<span class="nc" id="L345">                fragments.add(lastLedgerFragment);</span>
            }
        }

<span class="nc" id="L349">        checkFragments(fragments, cb);</span>
<span class="nc" id="L350">    }</span>

    private void checkFragments(Set&lt;LedgerFragment&gt; fragments,
                                GenericCallback&lt;Set&lt;LedgerFragment&gt;&gt; cb) {
<span class="nc bnc" id="L354" title="All 2 branches missed.">        if (fragments.size() == 0) { // no fragments to verify</span>
<span class="nc" id="L355">            cb.operationComplete(BKException.Code.OK, fragments);</span>
<span class="nc" id="L356">            return;</span>
        }

        // verify all the collected fragment replicas
<span class="nc" id="L360">        FullLedgerCallback allFragmentsCb = new FullLedgerCallback(fragments</span>
<span class="nc" id="L361">                .size(), cb);</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">        for (LedgerFragment r : fragments) {</span>
<span class="nc" id="L363">            LOG.debug(&quot;Checking fragment {}&quot;, r);</span>
            try {
<span class="nc" id="L365">                verifyLedgerFragment(r, allFragmentsCb);</span>
<span class="nc" id="L366">            } catch (InvalidFragmentException ife) {</span>
<span class="nc" id="L367">                LOG.error(&quot;Invalid fragment found : {}&quot;, r);</span>
<span class="nc" id="L368">                allFragmentsCb.operationComplete(</span>
                        BKException.Code.IncorrectParameterException, r);
<span class="nc" id="L370">            } catch (BKException e) {</span>
<span class="nc" id="L371">                LOG.error(&quot;BKException when checking fragment : {}&quot;, r, e);</span>
<span class="nc" id="L372">            }</span>
<span class="nc" id="L373">        }</span>
<span class="nc" id="L374">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>