<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LedgerDirsManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.bookie</a> &gt; <span class="el_source">LedgerDirsManager.java</span></div><h1>LedgerDirsManager.java</h1><pre class="source lang-java linenums">/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.bookkeeper.bookie;

import static org.apache.bookkeeper.bookie.BookKeeperServerStats.LD_WRITABLE_DIRS;

import com.google.common.annotations.VisibleForTesting;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import org.apache.bookkeeper.conf.ServerConfiguration;
import org.apache.bookkeeper.stats.Gauge;
import org.apache.bookkeeper.stats.NullStatsLogger;
import org.apache.bookkeeper.stats.StatsLogger;
import org.apache.bookkeeper.util.DiskChecker;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This class manages ledger directories used by the bookie.
 */
public class LedgerDirsManager {
<span class="fc" id="L46">    private static final Logger LOG = LoggerFactory.getLogger(LedgerDirsManager.class);</span>

    private volatile List&lt;File&gt; filledDirs;
    private final List&lt;File&gt; ledgerDirectories;
    private volatile List&lt;File&gt; writableLedgerDirectories;
    private final List&lt;LedgerDirsListener&gt; listeners;
<span class="fc" id="L52">    private final Random rand = new Random();</span>
<span class="fc" id="L53">    private final ConcurrentMap&lt;File, Float&gt; diskUsages =</span>
            new ConcurrentHashMap&lt;File, Float&gt;();
    private final long entryLogSize;
    private boolean forceGCAllowWhenNoSpace;
    private long minUsableSizeForIndexFileCreation;

    private final DiskChecker diskChecker;

    public LedgerDirsManager(ServerConfiguration conf, File[] dirs, DiskChecker diskChecker) {
<span class="nc" id="L62">        this(conf, dirs, diskChecker, NullStatsLogger.INSTANCE);</span>
<span class="nc" id="L63">    }</span>

    @VisibleForTesting
<span class="fc" id="L66">    LedgerDirsManager(ServerConfiguration conf, File[] dirs, DiskChecker diskChecker, StatsLogger statsLogger) {</span>
<span class="fc" id="L67">        this.ledgerDirectories = Arrays.asList(Bookie</span>
<span class="fc" id="L68">                .getCurrentDirectories(dirs));</span>
<span class="fc" id="L69">        this.writableLedgerDirectories = new ArrayList&lt;File&gt;(ledgerDirectories);</span>
<span class="fc" id="L70">        this.filledDirs = new ArrayList&lt;File&gt;();</span>
<span class="fc" id="L71">        this.listeners = new ArrayList&lt;LedgerDirsListener&gt;();</span>
<span class="fc" id="L72">        this.forceGCAllowWhenNoSpace = conf.getIsForceGCAllowWhenNoSpace();</span>
<span class="fc" id="L73">        this.entryLogSize = conf.getEntryLogSizeLimit();</span>
<span class="fc" id="L74">        this.minUsableSizeForIndexFileCreation = conf.getMinUsableSizeForIndexFileCreation();</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">        for (File dir : dirs) {</span>
<span class="fc" id="L76">            diskUsages.put(dir, 0f);</span>
<span class="fc" id="L77">            String statName = &quot;dir_&quot; + dir.getPath().replace('/', '_') + &quot;_usage&quot;;</span>
<span class="fc" id="L78">            final File targetDir = dir;</span>
<span class="fc" id="L79">            statsLogger.registerGauge(statName, new Gauge&lt;Number&gt;() {</span>
                @Override
                public Number getDefaultValue() {
<span class="nc" id="L82">                    return 0;</span>
                }

                @Override
                public Number getSample() {
<span class="nc" id="L87">                    return diskUsages.get(targetDir) * 100;</span>
                }
            });
        }

<span class="fc" id="L92">        this.diskChecker = diskChecker;</span>
<span class="fc" id="L93">        statsLogger.registerGauge(LD_WRITABLE_DIRS, new Gauge&lt;Number&gt;() {</span>

            @Override
            public Number getDefaultValue() {
<span class="nc" id="L97">                return 0;</span>
            }

            @Override
            public Number getSample() {
<span class="nc" id="L102">                return writableLedgerDirectories.size();</span>
            }
        });
<span class="fc" id="L105">    }</span>

    /**
     * Get all ledger dirs configured.
     */
    public List&lt;File&gt; getAllLedgerDirs() {
<span class="fc" id="L111">        return ledgerDirectories;</span>
    }

    /**
     * Get all dir listeners.
     *
     * @return list of listeners
     */
    public List&lt;LedgerDirsListener&gt; getListeners() {
<span class="nc" id="L120">        return listeners;</span>
    }

    /**
     * Calculate the total amount of free space available in all of the ledger directories put together.
     *
     * @return totalDiskSpace in bytes
     * @throws IOException
     */
    public long getTotalFreeSpace(List&lt;File&gt; dirs) throws IOException {
<span class="nc" id="L130">        return diskChecker.getTotalFreeSpace(dirs);</span>
    }

    /**
     * Calculate the total amount of free space available in all of the ledger directories put together.
     *
     * @return freeDiskSpace in bytes
     * @throws IOException
     */
    public long getTotalDiskSpace(List&lt;File&gt; dirs) throws IOException {
<span class="nc" id="L140">        return diskChecker.getTotalDiskSpace(dirs);</span>
    }

    /**
     * Get disk usages map.
     *
     * @return disk usages map
     */
    public ConcurrentMap&lt;File, Float&gt; getDiskUsages() {
<span class="fc" id="L149">        return diskUsages;</span>
    }

    /**
     * Get only writable ledger dirs.
     */
    public List&lt;File&gt; getWritableLedgerDirs()
            throws NoWritableLedgerDirException {
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">        if (writableLedgerDirectories.isEmpty()) {</span>
<span class="nc" id="L158">            String errMsg = &quot;All ledger directories are non writable&quot;;</span>
<span class="nc" id="L159">            NoWritableLedgerDirException e = new NoWritableLedgerDirException(</span>
                    errMsg);
<span class="nc" id="L161">            LOG.error(errMsg, e);</span>
<span class="nc" id="L162">            throw e;</span>
        }
<span class="fc" id="L164">        return writableLedgerDirectories;</span>
    }

    /**
     * @return true if the writableLedgerDirs list has entries
     */
    public boolean hasWritableLedgerDirs() {
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">        return !writableLedgerDirectories.isEmpty();</span>
    }

    public List&lt;File&gt; getWritableLedgerDirsForNewLog() throws NoWritableLedgerDirException {
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">        if (!writableLedgerDirectories.isEmpty()) {</span>
<span class="fc" id="L176">            return writableLedgerDirectories;</span>
        }

        // If Force GC is not allowed under no space
<span class="nc bnc" id="L180" title="All 2 branches missed.">        if (!forceGCAllowWhenNoSpace) {</span>
<span class="nc" id="L181">            String errMsg = &quot;All ledger directories are non writable and force GC is not enabled.&quot;;</span>
<span class="nc" id="L182">            NoWritableLedgerDirException e = new NoWritableLedgerDirException(errMsg);</span>
<span class="nc" id="L183">            LOG.error(errMsg, e);</span>
<span class="nc" id="L184">            throw e;</span>
        }

        // We don't have writable Ledger Dirs.
        // That means we must have turned readonly but the compaction
        // must have started running and it needs to allocate
        // a new log file to move forward with the compaction.
<span class="nc" id="L191">        return getDirsAboveUsableThresholdSize((long) (this.entryLogSize * 1.2));</span>
    }

    List&lt;File&gt; getDirsAboveUsableThresholdSize(long thresholdSize) throws NoWritableLedgerDirException {
<span class="nc" id="L195">        List&lt;File&gt; fullLedgerDirsToAccomodate = new ArrayList&lt;File&gt;();</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">        for (File dir: this.ledgerDirectories) {</span>
            // Pick dirs which can accommodate little more than thresholdSize
<span class="nc bnc" id="L198" title="All 2 branches missed.">            if (dir.getUsableSpace() &gt; thresholdSize) {</span>
<span class="nc" id="L199">                fullLedgerDirsToAccomodate.add(dir);</span>
            }
<span class="nc" id="L201">        }</span>

<span class="nc bnc" id="L203" title="All 2 branches missed.">        if (!fullLedgerDirsToAccomodate.isEmpty()) {</span>
<span class="nc" id="L204">            LOG.info(&quot;No writable ledger dirs below diskUsageThreshold. &quot;</span>
<span class="nc" id="L205">                    + &quot;But Dirs that can accomodate {} are: {}&quot;, thresholdSize, fullLedgerDirsToAccomodate);</span>
<span class="nc" id="L206">            return fullLedgerDirsToAccomodate;</span>
        }

        // We will reach here when we find no ledgerDir which has atleast
        // thresholdSize usable space
<span class="nc" id="L211">        String errMsg = &quot;All ledger directories are non writable and no reserved space (&quot; + thresholdSize + &quot;) left.&quot;;</span>
<span class="nc" id="L212">        NoWritableLedgerDirException e = new NoWritableLedgerDirException(errMsg);</span>
<span class="nc" id="L213">        LOG.error(errMsg, e);</span>
<span class="nc" id="L214">        throw e;</span>
    }

    /**
     * @return full-filled ledger dirs.
     */
    public List&lt;File&gt; getFullFilledLedgerDirs() {
<span class="fc" id="L221">        return filledDirs;</span>
    }

    /**
     * Get dirs, which are full more than threshold.
     */
    public boolean isDirFull(File dir) {
<span class="fc" id="L228">        return filledDirs.contains(dir);</span>
    }

    /**
     * Add the dir to filled dirs list.
     */
    @VisibleForTesting
    public void addToFilledDirs(File dir) {
<span class="nc bnc" id="L236" title="All 2 branches missed.">        if (!filledDirs.contains(dir)) {</span>
<span class="nc" id="L237">            LOG.warn(dir + &quot; is out of space. Adding it to filled dirs list&quot;);</span>
            // Update filled dirs list
<span class="nc" id="L239">            List&lt;File&gt; updatedFilledDirs = new ArrayList&lt;File&gt;(filledDirs);</span>
<span class="nc" id="L240">            updatedFilledDirs.add(dir);</span>
<span class="nc" id="L241">            filledDirs = updatedFilledDirs;</span>
            // Update the writable ledgers list
<span class="nc" id="L243">            List&lt;File&gt; newDirs = new ArrayList&lt;File&gt;(writableLedgerDirectories);</span>
<span class="nc" id="L244">            newDirs.removeAll(filledDirs);</span>
<span class="nc" id="L245">            writableLedgerDirectories = newDirs;</span>
            // Notify listeners about disk full
<span class="nc bnc" id="L247" title="All 2 branches missed.">            for (LedgerDirsListener listener : listeners) {</span>
<span class="nc" id="L248">                listener.diskFull(dir);</span>
<span class="nc" id="L249">            }</span>
        }
<span class="nc" id="L251">    }</span>

    /**
     * Add the dir to writable dirs list.
     *
     * @param dir Dir
     */
    public void addToWritableDirs(File dir, boolean underWarnThreshold) {
<span class="nc bnc" id="L259" title="All 2 branches missed.">        if (writableLedgerDirectories.contains(dir)) {</span>
<span class="nc" id="L260">            return;</span>
        }
<span class="nc" id="L262">        LOG.info(&quot;{} becomes writable. Adding it to writable dirs list.&quot;, dir);</span>
        // Update writable dirs list
<span class="nc" id="L264">        List&lt;File&gt; updatedWritableDirs = new ArrayList&lt;File&gt;(writableLedgerDirectories);</span>
<span class="nc" id="L265">        updatedWritableDirs.add(dir);</span>
<span class="nc" id="L266">        writableLedgerDirectories = updatedWritableDirs;</span>
        // Update the filled dirs list
<span class="nc" id="L268">        List&lt;File&gt; newDirs = new ArrayList&lt;File&gt;(filledDirs);</span>
<span class="nc" id="L269">        newDirs.removeAll(writableLedgerDirectories);</span>
<span class="nc" id="L270">        filledDirs = newDirs;</span>
        // Notify listeners about disk writable
<span class="nc bnc" id="L272" title="All 2 branches missed.">        for (LedgerDirsListener listener : listeners) {</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">            if (underWarnThreshold) {</span>
<span class="nc" id="L274">                listener.diskWritable(dir);</span>
            } else {
<span class="nc" id="L276">                listener.diskJustWritable(dir);</span>
            }
<span class="nc" id="L278">        }</span>
<span class="nc" id="L279">    }</span>

    /**
     * Returns one of the ledger dir from writable dirs list randomly.
     */
    File pickRandomWritableDir() throws NoWritableLedgerDirException {
<span class="nc" id="L285">        return pickRandomWritableDir(null);</span>
    }

    /**
     * Pick up a writable dir from available dirs list randomly. The &lt;code&gt;excludedDir&lt;/code&gt;
     * will not be pickedup.
     *
     * @param excludedDir
     *          The directory to exclude during pickup.
     * @throws NoWritableLedgerDirException if there is no writable dir available.
     */
    File pickRandomWritableDir(File excludedDir) throws NoWritableLedgerDirException {
<span class="nc" id="L297">        List&lt;File&gt; writableDirs = getWritableLedgerDirs();</span>
<span class="nc" id="L298">        return pickRandomDir(writableDirs, excludedDir);</span>
    }

    /**
     * Pick up a dir randomly from writableLedgerDirectories. If writableLedgerDirectories is empty
     * then pick up a dir randomly from the ledger/indexdirs which have usable space more than
     * minUsableSizeForIndexFileCreation.
     *
     * @param excludedDir The directory to exclude during pickup.
     * @return
     * @throws NoWritableLedgerDirException if there is no dir available.
     */
    File pickRandomWritableDirForNewIndexFile(File excludedDir) throws NoWritableLedgerDirException {
        final List&lt;File&gt; writableDirsForNewIndexFile;
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">        if (!writableLedgerDirectories.isEmpty()) {</span>
<span class="fc" id="L313">            writableDirsForNewIndexFile = writableLedgerDirectories;</span>
        } else {
            // We don't have writable Index Dirs.
            // That means we must have turned readonly. But
            // during the Bookie restart, while replaying the journal there might be a need
            // to create new Index file and it should proceed.
<span class="nc" id="L319">            writableDirsForNewIndexFile = getDirsAboveUsableThresholdSize(minUsableSizeForIndexFileCreation);</span>
        }
<span class="fc" id="L321">        return pickRandomDir(writableDirsForNewIndexFile, excludedDir);</span>
    }

    /**
     * Return one dir from all dirs, regardless writable or not.
     */
    File pickRandomDir(File excludedDir) throws NoWritableLedgerDirException {
<span class="nc" id="L328">        return pickRandomDir(getAllLedgerDirs(), excludedDir);</span>
    }

    File pickRandomDir(List&lt;File&gt; dirs, File excludedDir) throws NoWritableLedgerDirException {
<span class="fc" id="L332">        final int start = rand.nextInt(dirs.size());</span>
<span class="fc" id="L333">        int idx = start;</span>
<span class="fc" id="L334">        File candidate = dirs.get(idx);</span>
<span class="pc bpc" id="L335" title="3 of 4 branches missed.">        while (null != excludedDir &amp;&amp; excludedDir.equals(candidate)) {</span>
<span class="nc" id="L336">            idx = (idx + 1) % dirs.size();</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">            if (idx == start) {</span>
                // after searching all available dirs,
                // no writable dir is found
<span class="nc" id="L340">                throw new NoWritableLedgerDirException(&quot;No writable directories found from &quot;</span>
                        + &quot; available writable dirs (&quot; + dirs + &quot;) : exclude dir &quot;
                        + excludedDir);
            }
<span class="nc" id="L344">            candidate = dirs.get(idx);</span>
        }
<span class="fc" id="L346">        return candidate;</span>
    }

    public void addLedgerDirsListener(LedgerDirsListener listener) {
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">        if (listener != null) {</span>
<span class="fc" id="L351">            listeners.add(listener);</span>
        }
<span class="fc" id="L353">    }</span>

    /**
     * Indicates All configured ledger directories are full.
     */
    public static class NoWritableLedgerDirException extends IOException {
        private static final long serialVersionUID = -8696901285061448421L;

        public NoWritableLedgerDirException(String errMsg) {
<span class="nc" id="L362">            super(errMsg);</span>
<span class="nc" id="L363">        }</span>
    }

    /**
     * Listener for the disk check events will be notified from the
     * {@link LedgerDirsManager} whenever disk full/failure detected.
     */
    public interface LedgerDirsListener {
        /**
         * This will be notified on disk failure/disk error.
         *
         * @param disk Failed disk
         */
        void diskFailed(File disk);

        /**
         * Notified when the disk usage warn threshold is exceeded on the drive.
         * @param disk
         */
        void diskAlmostFull(File disk);

        /**
         * This will be notified on disk detected as full.
         *
         * @param disk Filled disk
         */
        void diskFull(File disk);

        /**
         * This will be notified on disk detected as writable and under warn threshold.
         *
         * @param disk Writable disk
         */
        void diskWritable(File disk);

        /**
         * This will be notified on disk detected as writable but still in warn threshold.
         *
         * @param disk Writable disk
         */
        void diskJustWritable(File disk);

        /**
         * This will be notified whenever all disks are detected as full.
         */
        void allDisksFull();

        /**
         * This will notify the fatal errors.
         */
        void fatalError();
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>