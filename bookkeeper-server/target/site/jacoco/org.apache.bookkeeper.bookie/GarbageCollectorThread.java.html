<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GarbageCollectorThread.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.bookie</a> &gt; <span class="el_source">GarbageCollectorThread.java</span></div><h1>GarbageCollectorThread.java</h1><pre class="source lang-java linenums">/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

package org.apache.bookkeeper.bookie;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.util.concurrent.ThreadFactoryBuilder;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

import org.apache.bookkeeper.bookie.GarbageCollector.GarbageCleaner;
import org.apache.bookkeeper.conf.ServerConfiguration;
import org.apache.bookkeeper.meta.LedgerManager;
import org.apache.bookkeeper.util.MathUtils;
import org.apache.bookkeeper.util.SafeRunnable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This is the garbage collector thread that runs in the background to
 * remove any entry log files that no longer contains any active ledger.
 */
public class GarbageCollectorThread extends SafeRunnable {
<span class="fc" id="L52">    private static final Logger LOG = LoggerFactory.getLogger(GarbageCollectorThread.class);</span>
    private static final int SECOND = 1000;

    // Maps entry log files to the set of ledgers that comprise the file and the size usage per ledger
<span class="fc" id="L56">    private Map&lt;Long, EntryLogMetadata&gt; entryLogMetaMap = new ConcurrentHashMap&lt;Long, EntryLogMetadata&gt;();</span>

    private final ScheduledExecutorService gcExecutor;
<span class="fc" id="L59">    Future&lt;?&gt; scheduledFuture = null;</span>

    // This is how often we want to run the Garbage Collector Thread (in milliseconds).
    final long gcWaitTime;

    // Compaction parameters
<span class="fc" id="L65">    boolean enableMinorCompaction = false;</span>
    final double minorCompactionThreshold;
    final long minorCompactionInterval;
    long lastMinorCompactionTime;

<span class="fc" id="L70">    boolean enableMajorCompaction = false;</span>
    final double majorCompactionThreshold;
    final long majorCompactionInterval;
    long lastMajorCompactionTime;

    final boolean isForceGCAllowWhenNoSpace;

    // Entry Logger Handle
    final EntryLogger entryLogger;
    final AbstractLogCompactor compactor;
    final CompactableLedgerStorage ledgerStorage;

    // flag to ensure gc thread will not be interrupted during compaction
    // to reduce the risk getting entry log corrupted
<span class="fc" id="L84">    final AtomicBoolean compacting = new AtomicBoolean(false);</span>

<span class="fc" id="L86">    volatile boolean running = true;</span>

    // track the last scanned successfully log id
<span class="fc" id="L89">    long scannedLogId = 0;</span>

    // Boolean to trigger a forced GC.
<span class="fc" id="L92">    final AtomicBoolean forceGarbageCollection = new AtomicBoolean(false);</span>
    // Boolean to disable major compaction, when disk is almost full
<span class="fc" id="L94">    final AtomicBoolean suspendMajorCompaction = new AtomicBoolean(false);</span>
    // Boolean to disable minor compaction, when disk is full
<span class="fc" id="L96">    final AtomicBoolean suspendMinorCompaction = new AtomicBoolean(false);</span>

    final GarbageCollector garbageCollector;
    final GarbageCleaner garbageCleaner;

    final ServerConfiguration conf;


    /**
     * Create a garbage collector thread.
     *
     * @param conf
     *          Server Configuration Object.
     * @throws IOException
     */
    public GarbageCollectorThread(ServerConfiguration conf,
                                  LedgerManager ledgerManager,
                                  final CompactableLedgerStorage ledgerStorage)
<span class="fc" id="L114">        throws IOException {</span>
<span class="fc" id="L115">        gcExecutor = Executors.newSingleThreadScheduledExecutor(</span>
<span class="fc" id="L116">                new ThreadFactoryBuilder().setNameFormat(&quot;GarbageCollectorThread-%d&quot;).build()</span>
        );
<span class="fc" id="L118">        this.conf = conf;</span>
<span class="fc" id="L119">        this.entryLogger = ledgerStorage.getEntryLogger();</span>
<span class="fc" id="L120">        this.ledgerStorage = ledgerStorage;</span>
<span class="fc" id="L121">        this.gcWaitTime = conf.getGcWaitTime();</span>

<span class="fc" id="L123">        this.garbageCleaner = ledgerId -&gt; {</span>
            try {
<span class="nc bnc" id="L125" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L126">                    LOG.debug(&quot;delete ledger : &quot; + ledgerId);</span>
                }
<span class="nc" id="L128">                ledgerStorage.deleteLedger(ledgerId);</span>
<span class="nc" id="L129">            } catch (IOException e) {</span>
<span class="nc" id="L130">                LOG.error(&quot;Exception when deleting the ledger index file on the Bookie: &quot;, e);</span>
<span class="nc" id="L131">            }</span>
<span class="nc" id="L132">        };</span>

<span class="fc" id="L134">        this.garbageCollector = new ScanAndCompareGarbageCollector(ledgerManager, ledgerStorage, conf);</span>
        // compaction parameters
<span class="fc" id="L136">        minorCompactionThreshold = conf.getMinorCompactionThreshold();</span>
<span class="fc" id="L137">        minorCompactionInterval = conf.getMinorCompactionInterval() * SECOND;</span>
<span class="fc" id="L138">        majorCompactionThreshold = conf.getMajorCompactionThreshold();</span>
<span class="fc" id="L139">        majorCompactionInterval = conf.getMajorCompactionInterval() * SECOND;</span>
<span class="fc" id="L140">        isForceGCAllowWhenNoSpace = conf.getIsForceGCAllowWhenNoSpace();</span>
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">        if (conf.getUseTransactionalCompaction()) {</span>
<span class="nc" id="L142">            this.compactor = new TransactionalEntryLogCompactor(this);</span>
        } else {
<span class="fc" id="L144">            this.compactor = new EntryLogCompactor(this);</span>
        }

<span class="pc bpc" id="L147" title="2 of 4 branches missed.">        if (minorCompactionInterval &gt; 0 &amp;&amp; minorCompactionThreshold &gt; 0) {</span>
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">            if (minorCompactionThreshold &gt; 1.0f) {</span>
<span class="nc" id="L149">                throw new IOException(&quot;Invalid minor compaction threshold &quot;</span>
                                    + minorCompactionThreshold);
            }
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">            if (minorCompactionInterval &lt;= gcWaitTime) {</span>
<span class="nc" id="L153">                throw new IOException(&quot;Too short minor compaction interval : &quot;</span>
                                    + minorCompactionInterval);
            }
<span class="fc" id="L156">            enableMinorCompaction = true;</span>
        }

<span class="pc bpc" id="L159" title="2 of 4 branches missed.">        if (majorCompactionInterval &gt; 0 &amp;&amp; majorCompactionThreshold &gt; 0) {</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">            if (majorCompactionThreshold &gt; 1.0f) {</span>
<span class="nc" id="L161">                throw new IOException(&quot;Invalid major compaction threshold &quot;</span>
                                    + majorCompactionThreshold);
            }
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">            if (majorCompactionInterval &lt;= gcWaitTime) {</span>
<span class="nc" id="L165">                throw new IOException(&quot;Too short major compaction interval : &quot;</span>
                                    + majorCompactionInterval);
            }
<span class="fc" id="L168">            enableMajorCompaction = true;</span>
        }

<span class="pc bpc" id="L171" title="2 of 4 branches missed.">        if (enableMinorCompaction &amp;&amp; enableMajorCompaction) {</span>
<span class="pc bpc" id="L172" title="2 of 4 branches missed.">            if (minorCompactionInterval &gt;= majorCompactionInterval</span>
                || minorCompactionThreshold &gt;= majorCompactionThreshold) {
<span class="nc" id="L174">                throw new IOException(&quot;Invalid minor/major compaction settings : minor (&quot;</span>
                                    + minorCompactionThreshold + &quot;, &quot; + minorCompactionInterval
                                    + &quot;), major (&quot; + majorCompactionThreshold + &quot;, &quot;
                                    + majorCompactionInterval + &quot;)&quot;);
            }
        }

<span class="fc" id="L181">        LOG.info(&quot;Minor Compaction : enabled=&quot; + enableMinorCompaction + &quot;, threshold=&quot;</span>
               + minorCompactionThreshold + &quot;, interval=&quot; + minorCompactionInterval);
<span class="fc" id="L183">        LOG.info(&quot;Major Compaction : enabled=&quot; + enableMajorCompaction + &quot;, threshold=&quot;</span>
               + majorCompactionThreshold + &quot;, interval=&quot; + majorCompactionInterval);

<span class="fc" id="L186">        lastMinorCompactionTime = lastMajorCompactionTime = MathUtils.now();</span>
<span class="fc" id="L187">    }</span>

    public void enableForceGC() {
<span class="nc bnc" id="L190" title="All 2 branches missed.">        if (forceGarbageCollection.compareAndSet(false, true)) {</span>
<span class="nc" id="L191">            LOG.info(&quot;Forced garbage collection triggered by thread: {}&quot;, Thread.currentThread().getName());</span>
<span class="nc" id="L192">            triggerGC(true, suspendMajorCompaction.get(),</span>
<span class="nc" id="L193">                      suspendMinorCompaction.get());</span>
        }
<span class="nc" id="L195">    }</span>

    public void disableForceGC() {
<span class="nc bnc" id="L198" title="All 2 branches missed.">        if (forceGarbageCollection.compareAndSet(true, false)) {</span>
<span class="nc" id="L199">            LOG.info(&quot;{} disabled force garbage collection since bookie has enough space now.&quot;, Thread</span>
<span class="nc" id="L200">                    .currentThread().getName());</span>
        }
<span class="nc" id="L202">    }</span>

    Future&lt;?&gt; triggerGC(final boolean force,
                        final boolean suspendMajor,
                        final boolean suspendMinor) {
<span class="nc" id="L207">        return gcExecutor.submit(() -&gt; {</span>
<span class="nc" id="L208">                runWithFlags(force, suspendMajor, suspendMinor);</span>
<span class="nc" id="L209">            });</span>
    }

    Future&lt;?&gt; triggerGC() {
<span class="nc" id="L213">        final boolean force = forceGarbageCollection.get();</span>
<span class="nc" id="L214">        final boolean suspendMajor = suspendMajorCompaction.get();</span>
<span class="nc" id="L215">        final boolean suspendMinor = suspendMinorCompaction.get();</span>

<span class="nc" id="L217">        return gcExecutor.submit(() -&gt; {</span>
<span class="nc" id="L218">                runWithFlags(force, suspendMajor, suspendMinor);</span>
<span class="nc" id="L219">            });</span>
    }

    public void suspendMajorGC() {
<span class="nc bnc" id="L223" title="All 2 branches missed.">        if (suspendMajorCompaction.compareAndSet(false, true)) {</span>
<span class="nc" id="L224">            LOG.info(&quot;Suspend Major Compaction triggered by thread: {}&quot;, Thread.currentThread().getName());</span>
        }
<span class="nc" id="L226">    }</span>

    public void resumeMajorGC() {
<span class="nc bnc" id="L229" title="All 2 branches missed.">        if (suspendMajorCompaction.compareAndSet(true, false)) {</span>
<span class="nc" id="L230">            LOG.info(&quot;{} Major Compaction back to normal since bookie has enough space now.&quot;,</span>
<span class="nc" id="L231">                    Thread.currentThread().getName());</span>
        }
<span class="nc" id="L233">    }</span>

    public void suspendMinorGC() {
<span class="nc bnc" id="L236" title="All 2 branches missed.">        if (suspendMinorCompaction.compareAndSet(false, true)) {</span>
<span class="nc" id="L237">            LOG.info(&quot;Suspend Minor Compaction triggered by thread: {}&quot;, Thread.currentThread().getName());</span>
        }
<span class="nc" id="L239">    }</span>

    public void resumeMinorGC() {
<span class="nc bnc" id="L242" title="All 2 branches missed.">        if (suspendMinorCompaction.compareAndSet(true, false)) {</span>
<span class="nc" id="L243">            LOG.info(&quot;{} Minor Compaction back to normal since bookie has enough space now.&quot;,</span>
<span class="nc" id="L244">                    Thread.currentThread().getName());</span>
        }
<span class="nc" id="L246">    }</span>

    public void start() {
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">        if (scheduledFuture != null) {</span>
<span class="nc" id="L250">            scheduledFuture.cancel(false);</span>
        }
<span class="fc" id="L252">        scheduledFuture = gcExecutor.scheduleAtFixedRate(this, gcWaitTime, gcWaitTime, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L253">    }</span>

    @Override
    public void safeRun() {
<span class="fc" id="L257">        boolean force = forceGarbageCollection.get();</span>
<span class="fc" id="L258">        boolean suspendMajor = suspendMajorCompaction.get();</span>
<span class="fc" id="L259">        boolean suspendMinor = suspendMinorCompaction.get();</span>

<span class="fc" id="L261">        runWithFlags(force, suspendMajor, suspendMinor);</span>

<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        if (force) {</span>
            // only set force to false if it had been true when the garbage
            // collection cycle started
<span class="nc" id="L266">            forceGarbageCollection.set(false);</span>
        }
<span class="fc" id="L268">    }</span>

    public void runWithFlags(boolean force, boolean suspendMajor, boolean suspendMinor) {
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">        if (force) {</span>
<span class="nc" id="L272">            LOG.info(&quot;Garbage collector thread forced to perform GC before expiry of wait time.&quot;);</span>
        }
        // Recover and clean up previous state if using transactional compaction
<span class="fc" id="L275">        compactor.cleanUpAndRecover();</span>

        // Extract all of the ledger ID's that comprise all of the entry logs
        // (except for the current new one which is still being written to).
<span class="fc" id="L279">        entryLogMetaMap = extractMetaFromEntryLogs(entryLogMetaMap);</span>

        // gc inactive/deleted ledgers
<span class="fc" id="L282">        doGcLedgers();</span>

        // gc entry logs
<span class="fc" id="L285">        doGcEntryLogs();</span>

<span class="pc bpc" id="L287" title="1 of 2 branches missed.">        if (suspendMajor) {</span>
<span class="nc" id="L288">            LOG.info(&quot;Disk almost full, suspend major compaction to slow down filling disk.&quot;);</span>
        }
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">        if (suspendMinor) {</span>
<span class="nc" id="L291">            LOG.info(&quot;Disk full, suspend minor compaction to slow down filling disk.&quot;);</span>
        }

<span class="fc" id="L294">        long curTime = MathUtils.now();</span>
<span class="pc bpc" id="L295" title="4 of 8 branches missed.">        if (enableMajorCompaction &amp;&amp; (!suspendMajor)</span>
            &amp;&amp; (force || curTime - lastMajorCompactionTime &gt; majorCompactionInterval)) {
            // enter major compaction
<span class="nc" id="L298">            LOG.info(&quot;Enter major compaction, suspendMajor {}&quot;, suspendMajor);</span>
<span class="nc" id="L299">            doCompactEntryLogs(majorCompactionThreshold);</span>
<span class="nc" id="L300">            lastMajorCompactionTime = MathUtils.now();</span>
            // and also move minor compaction time
<span class="nc" id="L302">            lastMinorCompactionTime = lastMajorCompactionTime;</span>
<span class="nc" id="L303">            return;</span>
        }

<span class="pc bpc" id="L306" title="4 of 8 branches missed.">        if (enableMinorCompaction &amp;&amp; (!suspendMinor)</span>
            &amp;&amp; (force || curTime - lastMinorCompactionTime &gt; minorCompactionInterval)) {
            // enter minor compaction
<span class="nc" id="L309">            LOG.info(&quot;Enter minor compaction, suspendMinor {}&quot;, suspendMinor);</span>
<span class="nc" id="L310">            doCompactEntryLogs(minorCompactionThreshold);</span>
<span class="nc" id="L311">            lastMinorCompactionTime = MathUtils.now();</span>
        }
<span class="fc" id="L313">    }</span>

    /**
     * Do garbage collection ledger index files.
     */
    private void doGcLedgers() {
<span class="fc" id="L319">        garbageCollector.gc(garbageCleaner);</span>
<span class="fc" id="L320">    }</span>

    /**
     * Garbage collect those entry loggers which are not associated with any active ledgers.
     */
    private void doGcEntryLogs() {
        // Loop through all of the entry logs and remove the non-active ledgers.
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">        for (Map.Entry&lt;Long, EntryLogMetadata&gt; entry :  entryLogMetaMap.entrySet()) {</span>
<span class="nc" id="L328">            long entryLogId = entry.getKey();</span>
<span class="nc" id="L329">            EntryLogMetadata meta = entry.getValue();</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">            for (Long entryLogLedger : meta.getLedgersMap().keySet()) {</span>
                // Remove the entry log ledger from the set if it isn't active.
                try {
<span class="nc bnc" id="L333" title="All 2 branches missed.">                    if (!ledgerStorage.ledgerExists(entryLogLedger)) {</span>
<span class="nc" id="L334">                        meta.removeLedger(entryLogLedger);</span>
                    }
<span class="nc" id="L336">                } catch (IOException e) {</span>
<span class="nc" id="L337">                    LOG.error(&quot;Error reading from ledger storage&quot;, e);</span>
<span class="nc" id="L338">                }</span>
<span class="nc" id="L339">            }</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">            if (meta.isEmpty()) {</span>
                // This means the entry log is not associated with any active ledgers anymore.
                // We can remove this entry log file now.
<span class="nc" id="L343">                LOG.info(&quot;Deleting entryLogId &quot; + entryLogId + &quot; as it has no active ledgers!&quot;);</span>
<span class="nc" id="L344">                removeEntryLog(entryLogId);</span>
            }
<span class="nc" id="L346">        }</span>
<span class="fc" id="L347">    }</span>

    /**
     * Compact entry logs if necessary.
     *
     * &lt;p&gt;
     * Compaction will be executed from low unused space to high unused space.
     * Those entry log files whose remaining size percentage is higher than threshold
     * would not be compacted.
     * &lt;/p&gt;
     */
    @VisibleForTesting
    void doCompactEntryLogs(double threshold) {
<span class="nc" id="L360">        LOG.info(&quot;Do compaction to compact those files lower than {}&quot;, threshold);</span>

        // sort the ledger meta by usage in ascending order.
<span class="nc" id="L363">        List&lt;EntryLogMetadata&gt; logsToCompact = new ArrayList&lt;EntryLogMetadata&gt;();</span>
<span class="nc" id="L364">        logsToCompact.addAll(entryLogMetaMap.values());</span>
<span class="nc" id="L365">        logsToCompact.sort(Comparator.comparing(EntryLogMetadata::getUsage));</span>

<span class="nc bnc" id="L367" title="All 2 branches missed.">        for (EntryLogMetadata meta : logsToCompact) {</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">            if (meta.getUsage() &gt;= threshold) {</span>
<span class="nc" id="L369">                break;</span>
            }
<span class="nc bnc" id="L371" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L372">                LOG.debug(&quot;Compacting entry log {} below threshold {}&quot;, meta.getEntryLogId(), threshold);</span>
            }
<span class="nc" id="L374">            compactEntryLog(meta);</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">            if (!running) { // if gc thread is not running, stop compaction</span>
<span class="nc" id="L376">                return;</span>
            }
<span class="nc" id="L378">        }</span>
<span class="nc" id="L379">    }</span>

    /**
     * Shutdown the garbage collector thread.
     *
     * @throws InterruptedException if there is an exception stopping gc thread.
     */
    public void shutdown() throws InterruptedException {
<span class="fc" id="L387">        this.running = false;</span>
<span class="fc" id="L388">        LOG.info(&quot;Shutting down GarbageCollectorThread&quot;);</span>

<span class="pc bpc" id="L390" title="1 of 2 branches missed.">        while (!compacting.compareAndSet(false, true)) {</span>
            // Wait till the thread stops compacting
<span class="nc" id="L392">            Thread.sleep(100);</span>
        }

        // Interrupt GC executor thread
<span class="fc" id="L396">        gcExecutor.shutdownNow();</span>
<span class="fc" id="L397">    }</span>

    /**
     * Remove entry log.
     *
     * @param entryLogId
     *          Entry Log File Id
     */
    protected void removeEntryLog(long entryLogId) {
        // remove entry log file successfully
<span class="nc bnc" id="L407" title="All 2 branches missed.">        if (entryLogger.removeEntryLog(entryLogId)) {</span>
<span class="nc" id="L408">            LOG.info(&quot;Removing entry log metadata for {}&quot;, entryLogId);</span>
<span class="nc" id="L409">            entryLogMetaMap.remove(entryLogId);</span>
        }
<span class="nc" id="L411">    }</span>

    /**
     * Compact an entry log.
     *
     * @param entryLogMeta
     */
    protected void compactEntryLog(EntryLogMetadata entryLogMeta) {
        // Similar with Sync Thread
        // try to mark compacting flag to make sure it would not be interrupted
        // by shutdown during compaction. otherwise it will receive
        // ClosedByInterruptException which may cause index file &amp; entry logger
        // closed and corrupted.
<span class="nc bnc" id="L424" title="All 2 branches missed.">        if (!compacting.compareAndSet(false, true)) {</span>
            // set compacting flag failed, means compacting is true now
            // indicates that compaction is in progress for this EntryLogId.
<span class="nc" id="L427">            return;</span>
        }
        // Do the actual compaction
<span class="nc" id="L430">        compactor.compact(entryLogMeta);</span>
        // Mark compaction done
<span class="nc" id="L432">        compacting.set(false);</span>
<span class="nc" id="L433">    }</span>

    /**
     * Method to read in all of the entry logs (those that we haven't done so yet),
     * and find the set of ledger ID's that make up each entry log file.
     *
     * @param entryLogMetaMap
     *          Existing EntryLogs to Meta
     * @throws IOException
     */
    protected Map&lt;Long, EntryLogMetadata&gt; extractMetaFromEntryLogs(Map&lt;Long, EntryLogMetadata&gt; entryLogMetaMap) {
        // Extract it for every entry log except for the current one.
        // Entry Log ID's are just a long value that starts at 0 and increments
        // by 1 when the log fills up and we roll to a new one.
<span class="fc" id="L447">        long curLogId = entryLogger.getLeastUnflushedLogId();</span>
<span class="fc" id="L448">        boolean hasExceptionWhenScan = false;</span>
<span class="pc bpc" id="L449" title="1 of 2 branches missed.">        for (long entryLogId = scannedLogId; entryLogId &lt; curLogId; entryLogId++) {</span>
            // Comb the current entry log file if it has not already been extracted.
<span class="nc bnc" id="L451" title="All 2 branches missed.">            if (entryLogMetaMap.containsKey(entryLogId)) {</span>
<span class="nc" id="L452">                continue;</span>
            }

            // check whether log file exists or not
            // if it doesn't exist, this log file might have been garbage collected.
<span class="nc bnc" id="L457" title="All 2 branches missed.">            if (!entryLogger.logExists(entryLogId)) {</span>
<span class="nc" id="L458">                continue;</span>
            }

<span class="nc" id="L461">            LOG.info(&quot;Extracting entry log meta from entryLogId: {}&quot;, entryLogId);</span>

            try {
                // Read through the entry log file and extract the entry log meta
<span class="nc" id="L465">                EntryLogMetadata entryLogMeta = entryLogger.getEntryLogMetadata(entryLogId);</span>
<span class="nc" id="L466">                entryLogMetaMap.put(entryLogId, entryLogMeta);</span>
<span class="nc" id="L467">            } catch (IOException e) {</span>
<span class="nc" id="L468">                hasExceptionWhenScan = true;</span>
<span class="nc" id="L469">                LOG.warn(&quot;Premature exception when processing &quot; + entryLogId</span>
                         + &quot; recovery will take care of the problem&quot;, e);
<span class="nc" id="L471">            }</span>

            // if scan failed on some entry log, we don't move 'scannedLogId' to next id
            // if scan succeed, we don't need to scan it again during next gc run,
            // we move 'scannedLogId' to next id
<span class="nc bnc" id="L476" title="All 2 branches missed.">            if (!hasExceptionWhenScan) {</span>
<span class="nc" id="L477">                ++scannedLogId;</span>
            }
        }
<span class="fc" id="L480">        return entryLogMetaMap;</span>
    }

    EntryLogger getEntryLogger() {
<span class="fc" id="L484">        return entryLogger;</span>
    }

    CompactableLedgerStorage getLedgerStorage() {
<span class="fc" id="L488">        return ledgerStorage;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>