<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IndexPersistenceMgr.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.bookie</a> &gt; <span class="el_source">IndexPersistenceMgr.java</span></div><h1>IndexPersistenceMgr.java</h1><pre class="source lang-java linenums">/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.bookkeeper.bookie;

import static org.apache.bookkeeper.bookie.BookKeeperServerStats.LEDGER_CACHE_NUM_EVICTED_LEDGERS;
import static org.apache.bookkeeper.bookie.BookKeeperServerStats.PENDING_GET_FILE_INFO;
import static org.apache.bookkeeper.bookie.BookKeeperServerStats.READ_FILE_INFO_CACHE_SIZE;
import static org.apache.bookkeeper.bookie.BookKeeperServerStats.WRITE_FILE_INFO_CACHE_SIZE;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.RemovalListener;
import com.google.common.cache.RemovalNotification;
import com.google.common.util.concurrent.UncheckedExecutionException;

import io.netty.buffer.ByteBuf;
import java.io.File;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Observable;
import java.util.Observer;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import org.apache.bookkeeper.bookie.LedgerDirsManager.LedgerDirsListener;
import org.apache.bookkeeper.bookie.LedgerDirsManager.NoWritableLedgerDirException;
import org.apache.bookkeeper.conf.ServerConfiguration;
import org.apache.bookkeeper.stats.Counter;
import org.apache.bookkeeper.stats.Gauge;
import org.apache.bookkeeper.stats.StatsLogger;
import org.apache.bookkeeper.util.SnapshotMap;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A {@code IndexPersistenceMgr} is responsible for managing the persistence state for the index in a bookie.
 */
public class IndexPersistenceMgr {
<span class="fc" id="L66">    private static final Logger LOG = LoggerFactory.getLogger(IndexPersistenceMgr.class);</span>

    private static final String IDX = &quot;.idx&quot;;
    static final String RLOC = &quot;.rloc&quot;;

    @VisibleForTesting
    public static final String getLedgerName(long ledgerId) {
<span class="fc" id="L73">        int parent = (int) (ledgerId &amp; 0xff);</span>
<span class="fc" id="L74">        int grandParent = (int) ((ledgerId &amp; 0xff00) &gt;&gt; 8);</span>
<span class="fc" id="L75">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L76">        sb.append(Integer.toHexString(grandParent));</span>
<span class="fc" id="L77">        sb.append('/');</span>
<span class="fc" id="L78">        sb.append(Integer.toHexString(parent));</span>
<span class="fc" id="L79">        sb.append('/');</span>
<span class="fc" id="L80">        sb.append(Long.toHexString(ledgerId));</span>
<span class="fc" id="L81">        sb.append(IDX);</span>
<span class="fc" id="L82">        return sb.toString();</span>
    }

    // use two separate cache for write and read
    final Cache&lt;Long, FileInfo&gt; writeFileInfoCache;
    final Cache&lt;Long, FileInfo&gt; readFileInfoCache;
    final int openFileLimit;
    final int pageSize;
    final int entriesPerPage;
    // Lock
<span class="fc" id="L92">    final ReentrantReadWriteLock fileInfoLock = new ReentrantReadWriteLock();</span>
    // ThreadPool
<span class="fc" id="L94">    final ScheduledExecutorService evictionThreadPool = Executors.newSingleThreadScheduledExecutor();</span>

    // Manage all active ledgers in LedgerManager
    // so LedgerManager has knowledge to garbage collect inactive/deleted ledgers
    final SnapshotMap&lt;Long, Boolean&gt; activeLedgers;
    final LedgerDirsManager ledgerDirsManager;

    // Stats
    private final Counter evictedLedgersCounter;
    private final Counter pendingGetFileInfoCounter;

    public IndexPersistenceMgr(int pageSize,
                               int entriesPerPage,
                               ServerConfiguration conf,
                               SnapshotMap&lt;Long, Boolean&gt; activeLedgers,
                               LedgerDirsManager ledgerDirsManager,
<span class="fc" id="L110">                               StatsLogger statsLogger) throws IOException {</span>
<span class="fc" id="L111">        this.openFileLimit = conf.getOpenFileLimit();</span>
<span class="fc" id="L112">        this.activeLedgers = activeLedgers;</span>
<span class="fc" id="L113">        this.ledgerDirsManager = ledgerDirsManager;</span>
<span class="fc" id="L114">        this.pageSize = pageSize;</span>
<span class="fc" id="L115">        this.entriesPerPage = entriesPerPage;</span>
<span class="fc" id="L116">        LOG.info(&quot;openFileLimit = {}&quot;, openFileLimit);</span>
        // Retrieve all of the active ledgers.
<span class="fc" id="L118">        getActiveLedgers();</span>
<span class="fc" id="L119">        ledgerDirsManager.addLedgerDirsListener(getLedgerDirsListener());</span>

        // build the file info cache
<span class="fc" id="L122">        int concurrencyLevel = Math.max(1, Math.max(conf.getNumAddWorkerThreads(), conf.getNumReadWorkerThreads()));</span>
<span class="fc" id="L123">        RemovalListener&lt;Long, FileInfo&gt; fileInfoEvictionListener = this::handleLedgerEviction;</span>
<span class="fc" id="L124">        writeFileInfoCache = buildCache(</span>
            concurrencyLevel,
<span class="fc" id="L126">            conf.getFileInfoCacheInitialCapacity(),</span>
            openFileLimit,
<span class="fc" id="L128">            conf.getFileInfoMaxIdleTime(),</span>
            fileInfoEvictionListener);
<span class="fc" id="L130">        readFileInfoCache = buildCache(</span>
            concurrencyLevel,
<span class="fc" id="L132">            2 * conf.getFileInfoCacheInitialCapacity(),</span>
            2 * openFileLimit,
<span class="fc" id="L134">            conf.getFileInfoMaxIdleTime(),</span>
            fileInfoEvictionListener);

        // Expose Stats
<span class="fc" id="L138">        evictedLedgersCounter = statsLogger.getCounter(LEDGER_CACHE_NUM_EVICTED_LEDGERS);</span>
<span class="fc" id="L139">        pendingGetFileInfoCounter = statsLogger.getCounter(PENDING_GET_FILE_INFO);</span>
<span class="fc" id="L140">        statsLogger.registerGauge(WRITE_FILE_INFO_CACHE_SIZE, new Gauge&lt;Number&gt;() {</span>
            @Override
            public Number getDefaultValue() {
<span class="nc" id="L143">                return 0;</span>
            }

            @Override
            public Number getSample() {
<span class="nc" id="L148">                return writeFileInfoCache.size();</span>
            }
        });
<span class="fc" id="L151">        statsLogger.registerGauge(READ_FILE_INFO_CACHE_SIZE, new Gauge&lt;Number&gt;() {</span>
            @Override
            public Number getDefaultValue() {
<span class="nc" id="L154">                return 0;</span>
            }

            @Override
            public Number getSample() {
<span class="nc" id="L159">                return readFileInfoCache.size();</span>
            }
        });
<span class="fc" id="L162">    }</span>

    private static Cache&lt;Long, FileInfo&gt; buildCache(int concurrencyLevel,
                                            int initialCapacity,
                                            int maximumSize,
                                            long expireAfterAccessSeconds,
                                            RemovalListener&lt;Long, FileInfo&gt; removalListener) {
<span class="fc" id="L169">        CacheBuilder&lt;Long, FileInfo&gt; builder = CacheBuilder.newBuilder()</span>
<span class="fc" id="L170">            .concurrencyLevel(concurrencyLevel)</span>
<span class="fc" id="L171">            .initialCapacity(initialCapacity)</span>
<span class="fc" id="L172">            .maximumSize(maximumSize)</span>
<span class="fc" id="L173">            .removalListener(removalListener);</span>
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">        if (expireAfterAccessSeconds &gt; 0) {</span>
<span class="nc" id="L175">            builder.expireAfterAccess(expireAfterAccessSeconds, TimeUnit.SECONDS);</span>
        }
<span class="fc" id="L177">        return builder.build();</span>
    }

    /**
     * When a ledger is evicted, we need to make sure there's no other thread
     * trying to get FileInfo for that ledger at the same time when we close
     * the FileInfo.
     */
    private void handleLedgerEviction(RemovalNotification&lt;Long, FileInfo&gt; notification) {
<span class="fc" id="L186">        FileInfo fileInfo = notification.getValue();</span>
<span class="fc" id="L187">        Long ledgerId = notification.getKey();</span>
<span class="pc bpc" id="L188" title="2 of 4 branches missed.">        if (null == fileInfo || null == notification.getKey()) {</span>
<span class="nc" id="L189">            return;</span>
        }
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">        if (notification.wasEvicted()) {</span>
<span class="nc" id="L192">            evictedLedgersCounter.inc();</span>
            // we need to acquire the write lock in another thread,
            // otherwise there could be dead lock happening.
<span class="nc" id="L195">            evictionThreadPool.execute(() -&gt; {</span>
<span class="nc" id="L196">                fileInfoLock.writeLock().lock();</span>
                try {
                    // We only close the fileInfo when we evict the FileInfo from both cache
<span class="nc bnc" id="L199" title="All 2 branches missed.">                    if (!readFileInfoCache.asMap().containsKey(ledgerId)</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">                            &amp;&amp; !writeFileInfoCache.asMap().containsKey(ledgerId)) {</span>
<span class="nc" id="L201">                        fileInfo.close(true);</span>
                    }
<span class="nc" id="L203">                } catch (IOException e) {</span>
<span class="nc" id="L204">                    LOG.error(&quot;Exception closing file info when ledger {} is evicted from file info cache.&quot;,</span>
                        ledgerId, e);
                } finally {
<span class="nc" id="L207">                    fileInfoLock.writeLock().unlock();</span>
                }
<span class="nc" id="L209">            });</span>
        }
<span class="fc" id="L211">        fileInfo.release();</span>
<span class="fc" id="L212">    }</span>

    class FileInfoLoader implements Callable&lt;FileInfo&gt; {

        final long ledger;
        final byte[] masterKey;

<span class="fc" id="L219">        FileInfoLoader(long ledger, byte[] masterKey) {</span>
<span class="fc" id="L220">            this.ledger = ledger;</span>
<span class="fc" id="L221">            this.masterKey = masterKey;</span>
<span class="fc" id="L222">        }</span>

        @Override
        public FileInfo call() throws IOException {
<span class="fc" id="L226">            File lf = findIndexFile(ledger);</span>
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">            if (null == lf) {</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">                if (null == masterKey) {</span>
<span class="nc" id="L229">                    throw new Bookie.NoLedgerException(ledger);</span>
                }
                // We don't have a ledger index file on disk or in cache, so create it.
<span class="fc" id="L232">                lf = getNewLedgerIndexFile(ledger, null);</span>
<span class="fc" id="L233">                activeLedgers.put(ledger, true);</span>
            }
<span class="fc" id="L235">            FileInfo fi = new FileInfo(lf, masterKey);</span>
<span class="fc" id="L236">            fi.use();</span>
<span class="fc" id="L237">            return fi;</span>
        }
    }

    /**
     * Get the FileInfo and increase reference count.
     * When we get FileInfo from cache, we need to make sure it is synchronized
     * with eviction, otherwise there might be a race condition as we get
     * the FileInfo from cache, that FileInfo is then evicted and closed before we
     * could even increase the reference counter.
     */
    FileInfo getFileInfo(final Long ledger, final byte masterKey[]) throws IOException {
        try {
            FileInfo fi;
<span class="fc" id="L251">            pendingGetFileInfoCounter.inc();</span>
<span class="fc" id="L252">            fileInfoLock.readLock().lock();</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">            if (null != masterKey) {</span>
<span class="fc" id="L254">                fi = writeFileInfoCache.get(ledger,</span>
<span class="fc" id="L255">                    new FileInfoLoader(ledger, masterKey));</span>
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">                if (null == readFileInfoCache.asMap().putIfAbsent(ledger, fi)) {</span>
<span class="fc" id="L257">                    fi.use();</span>
                }
            } else {
<span class="fc" id="L260">                fi = readFileInfoCache.get(ledger,</span>
<span class="fc" id="L261">                    new FileInfoLoader(ledger, null));</span>
            }
<span class="fc" id="L263">            fi.use();</span>
<span class="fc" id="L264">            return fi;</span>
<span class="nc" id="L265">        } catch (ExecutionException | UncheckedExecutionException ee) {</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">            if (ee.getCause() instanceof IOException) {</span>
<span class="nc" id="L267">                throw (IOException) ee.getCause();</span>
            } else {
<span class="nc" id="L269">                throw new IOException(&quot;Failed to load file info for ledger &quot; + ledger, ee);</span>
            }
        } finally {
<span class="fc" id="L272">            pendingGetFileInfoCounter.dec();</span>
<span class="fc" id="L273">            fileInfoLock.readLock().unlock();</span>
        }
    }

    /**
     * Get a new index file for ledger excluding directory &lt;code&gt;excludedDir&lt;/code&gt;.
     *
     * @param ledger
     *          Ledger id.
     * @param excludedDir
     *          The ledger directory to exclude.
     * @return new index file object.
     * @throws NoWritableLedgerDirException if there is no writable dir available.
     */
    private File getNewLedgerIndexFile(Long ledger, File excludedDir)
                    throws NoWritableLedgerDirException {
<span class="fc" id="L289">        File dir = ledgerDirsManager.pickRandomWritableDirForNewIndexFile(excludedDir);</span>
<span class="fc" id="L290">        String ledgerName = getLedgerName(ledger);</span>
<span class="fc" id="L291">        return new File(dir, ledgerName);</span>
    }

    /**
     * This method will look within the ledger directories for the ledger index
     * files. That will comprise the set of active ledgers this particular
     * BookieServer knows about that have not yet been deleted by the BookKeeper
     * Client. This is called only once during initialization.
     */
    private void getActiveLedgers() throws IOException {
        // Ledger index files are stored in a file hierarchy with a parent and
        // grandParent directory. We'll have to go two levels deep into these
        // directories to find the index files.
<span class="fc bfc" id="L304" title="All 2 branches covered.">        for (File ledgerDirectory : ledgerDirsManager.getAllLedgerDirs()) {</span>
<span class="fc" id="L305">            File[] grandParents = ledgerDirectory.listFiles();</span>
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">            if (grandParents == null) {</span>
<span class="nc" id="L307">                continue;</span>
            }
<span class="fc bfc" id="L309" title="All 2 branches covered.">            for (File grandParent : grandParents) {</span>
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">                if (grandParent.isDirectory()) {</span>
<span class="nc" id="L311">                    File[] parents = grandParent.listFiles();</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">                    if (parents == null) {</span>
<span class="nc" id="L313">                        continue;</span>
                    }
<span class="nc bnc" id="L315" title="All 2 branches missed.">                    for (File parent : parents) {</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">                        if (parent.isDirectory()) {</span>
<span class="nc" id="L317">                            File[] indexFiles = parent.listFiles();</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">                            if (indexFiles == null) {</span>
<span class="nc" id="L319">                                continue;</span>
                            }
<span class="nc bnc" id="L321" title="All 2 branches missed.">                            for (File index : indexFiles) {</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">                                if (!index.isFile()</span>
<span class="nc bnc" id="L323" title="All 4 branches missed.">                                        || (!index.getName().endsWith(IDX) &amp;&amp; !index.getName().endsWith(RLOC))) {</span>
<span class="nc" id="L324">                                    continue;</span>
                                }

                                // We've found a ledger index file. The file
                                // name is the HexString representation of the
                                // ledgerId.
<span class="nc" id="L330">                                String ledgerIdInHex = index.getName().replace(RLOC, &quot;&quot;).replace(IDX, &quot;&quot;);</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">                                if (index.getName().endsWith(RLOC)) {</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">                                    if (findIndexFile(Long.parseLong(ledgerIdInHex)) != null) {</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">                                        if (!index.delete()) {</span>
<span class="nc" id="L334">                                            LOG.warn(&quot;Deleting the rloc file &quot; + index + &quot; failed&quot;);</span>
                                        }
                                        continue;
                                    } else {
<span class="nc" id="L338">                                        File dest = new File(index.getParentFile(), ledgerIdInHex + IDX);</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">                                        if (!index.renameTo(dest)) {</span>
<span class="nc" id="L340">                                            throw new IOException(&quot;Renaming rloc file &quot; + index</span>
                                                    + &quot; to index file has failed&quot;);
                                        }
                                    }
                                }
<span class="nc" id="L345">                                activeLedgers.put(Long.parseLong(ledgerIdInHex, 16), true);</span>
                            }
                        }
                    }
                }
            }
<span class="fc" id="L351">        }</span>
<span class="fc" id="L352">    }</span>

    /**
     * This method is called whenever a ledger is deleted by the BookKeeper Client
     * and we want to remove all relevant data for it stored in the LedgerCache.
     */
    void removeLedger(Long ledgerId) throws IOException {
        // Delete the ledger's index file and close the FileInfo
<span class="nc" id="L360">        FileInfo fi = null;</span>
<span class="nc" id="L361">        fileInfoLock.writeLock().lock();</span>
        try {
<span class="nc" id="L363">            fi = getFileInfo(ledgerId, null);</span>
            // Don't force flush. There's no need since we're deleting the ledger
            // anyway, and recreating the file at this point, although safe, will
            // force the garbage collector to do more work later.
<span class="nc" id="L367">            fi.close(false);</span>
<span class="nc" id="L368">            fi.delete();</span>
        } finally {
            try {
<span class="nc bnc" id="L371" title="All 2 branches missed.">                if (fi != null) {</span>
                    // should release use count
<span class="nc" id="L373">                    fi.release();</span>
                    // Remove it from the active ledger manager
<span class="nc" id="L375">                    activeLedgers.remove(ledgerId);</span>
                    // Now remove it from cache
<span class="nc" id="L377">                    writeFileInfoCache.invalidate(ledgerId);</span>
<span class="nc" id="L378">                    readFileInfoCache.invalidate(ledgerId);</span>
                }
            } finally {
<span class="nc" id="L381">                fileInfoLock.writeLock().unlock();</span>
            }
        }
<span class="nc" id="L384">    }</span>

    private File findIndexFile(long ledgerId) throws IOException {
<span class="fc" id="L387">        String ledgerName = getLedgerName(ledgerId);</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">        for (File d : ledgerDirsManager.getAllLedgerDirs()) {</span>
<span class="fc" id="L389">            File lf = new File(d, ledgerName);</span>
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">            if (lf.exists()) {</span>
<span class="nc" id="L391">                return lf;</span>
            }
<span class="fc" id="L393">        }</span>
<span class="fc" id="L394">        return null;</span>
    }

    boolean ledgerExists(long ledgerId) throws IOException {
<span class="fc" id="L398">        return activeLedgers.containsKey(ledgerId);</span>
    }

    void close() throws IOException {
        // Don't force create the file. We may have many dirty ledgers and file create/flush
        // can be quite expensive as a result. We can use this optimization in this case
        // because metadata will be recovered from the journal when we restart anyway.
        try {
<span class="fc" id="L406">            fileInfoLock.writeLock().lock();</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">            for (Map.Entry&lt;Long, FileInfo&gt; entry : writeFileInfoCache.asMap().entrySet()) {</span>
<span class="fc" id="L408">                entry.getValue().close(false);</span>
<span class="fc" id="L409">            }</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">            for (Map.Entry&lt;Long, FileInfo&gt; entry : readFileInfoCache.asMap().entrySet()) {</span>
<span class="fc" id="L411">                entry.getValue().close(false);</span>
<span class="fc" id="L412">            }</span>
<span class="fc" id="L413">            writeFileInfoCache.invalidateAll();</span>
<span class="fc" id="L414">            readFileInfoCache.invalidateAll();</span>
        } finally {
<span class="fc" id="L416">            fileInfoLock.writeLock().unlock();</span>
        }
<span class="fc" id="L418">        evictionThreadPool.shutdown();</span>
        try {
<span class="fc" id="L420">            evictionThreadPool.awaitTermination(5, TimeUnit.SECONDS);</span>
<span class="nc" id="L421">        } catch (InterruptedException e) {</span>
            //ignore
<span class="fc" id="L423">        }</span>
<span class="fc" id="L424">    }</span>

    Long getLastAddConfirmed(long ledgerId) throws IOException {
<span class="fc" id="L427">        FileInfo fi = null;</span>
        try {
<span class="fc" id="L429">            fi = getFileInfo(ledgerId, null);</span>
<span class="fc" id="L430">            return fi.getLastAddConfirmed();</span>
        } finally {
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">            if (null != fi) {</span>
<span class="fc" id="L433">                fi.release();</span>
            }
        }
    }

    Observable waitForLastAddConfirmedUpdate(long ledgerId, long previoisLAC, Observer observer) throws IOException {
<span class="nc" id="L439">        FileInfo fi = null;</span>
        try {
<span class="nc" id="L441">            fi = getFileInfo(ledgerId, null);</span>
<span class="nc" id="L442">            return fi.waitForLastAddConfirmedUpdate(previoisLAC, observer);</span>
        } finally {
<span class="nc bnc" id="L444" title="All 2 branches missed.">            if (null != fi) {</span>
<span class="nc" id="L445">                fi.release();</span>
            }
        }
    }

    long updateLastAddConfirmed(long ledgerId, long lac) throws IOException {
<span class="fc" id="L451">        FileInfo fi = null;</span>
        try {
<span class="fc" id="L453">            fi = getFileInfo(ledgerId, null);</span>
<span class="fc" id="L454">            return fi.setLastAddConfirmed(lac);</span>
        } finally {
<span class="pc bpc" id="L456" title="1 of 2 branches missed.">            if (null != fi) {</span>
<span class="fc" id="L457">                fi.release();</span>
            }
        }
    }

    byte[] readMasterKey(long ledgerId) throws IOException, BookieException {
<span class="nc" id="L463">        FileInfo fi = null;</span>
        try {
<span class="nc" id="L465">            fi = getFileInfo(ledgerId, null);</span>
<span class="nc" id="L466">            return fi.getMasterKey();</span>
        } finally {
<span class="nc bnc" id="L468" title="All 2 branches missed.">            if (null != fi) {</span>
<span class="nc" id="L469">                fi.release();</span>
            }
        }
    }

    void setMasterKey(long ledgerId, byte[] masterKey) throws IOException {
<span class="fc" id="L475">        FileInfo fi = null;</span>
        try {
<span class="fc" id="L477">            fi = getFileInfo(ledgerId, masterKey);</span>
        } finally {
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">            if (null != fi) {</span>
<span class="fc" id="L480">                fi.release();</span>
            }
        }
<span class="fc" id="L483">    }</span>

    boolean setFenced(long ledgerId) throws IOException {
<span class="nc" id="L486">        FileInfo fi = null;</span>
        try {
<span class="nc" id="L488">            fi = getFileInfo(ledgerId, null);</span>
<span class="nc" id="L489">            return fi.setFenced();</span>
        } finally {
<span class="nc bnc" id="L491" title="All 2 branches missed.">            if (null != fi) {</span>
<span class="nc" id="L492">                fi.release();</span>
            }
        }
    }

    boolean isFenced(long ledgerId) throws IOException {
<span class="fc" id="L498">        FileInfo fi = null;</span>
        try {
<span class="fc" id="L500">            fi = getFileInfo(ledgerId, null);</span>
<span class="fc" id="L501">            return fi.isFenced();</span>
        } finally {
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">            if (null != fi) {</span>
<span class="fc" id="L504">                fi.release();</span>
            }
        }
    }

    void setExplicitLac(long ledgerId, ByteBuf lac) throws IOException {
<span class="nc" id="L510">        FileInfo fi = null;</span>
        try {
<span class="nc" id="L512">            fi = getFileInfo(ledgerId, null);</span>
<span class="nc" id="L513">            fi.setExplicitLac(lac);</span>
<span class="nc" id="L514">            return;</span>
        } finally {
<span class="nc bnc" id="L516" title="All 2 branches missed.">            if (null != fi) {</span>
<span class="nc" id="L517">                fi.release();</span>
            }
        }
    }

    public ByteBuf getExplicitLac(long ledgerId) {
<span class="nc" id="L523">        FileInfo fi = null;</span>
        try {
<span class="nc" id="L525">            fi = getFileInfo(ledgerId, null);</span>
<span class="nc" id="L526">            return fi.getExplicitLac();</span>
<span class="nc" id="L527">        } catch (IOException e) {</span>
<span class="nc" id="L528">            LOG.error(&quot;Exception during getLastAddConfirmed: {}&quot;, e);</span>
<span class="nc" id="L529">            return null;</span>
        } finally {
<span class="nc bnc" id="L531" title="All 2 branches missed.">            if (null != fi) {</span>
<span class="nc" id="L532">                fi.release();</span>
            }
        }
    }

    int getOpenFileLimit() {
<span class="nc" id="L538">        return openFileLimit;</span>
    }

    private LedgerDirsListener getLedgerDirsListener() {
<span class="fc" id="L542">        return new LedgerDirsListener() {</span>
            @Override
            public void diskFull(File disk) {
                // Nothing to handle here. Will be handled in Bookie
<span class="nc" id="L546">            }</span>

            @Override
            public void diskAlmostFull(File disk) {
                // Nothing to handle here. Will be handled in Bookie
<span class="nc" id="L551">            }</span>

            @Override
            public void diskFailed(File disk) {
                // Nothing to handle here. Will be handled in Bookie
<span class="nc" id="L556">            }</span>

            @Override
            public void allDisksFull() {
                // Nothing to handle here. Will be handled in Bookie
<span class="nc" id="L561">            }</span>

            @Override
            public void fatalError() {
                // Nothing to handle here. Will be handled in Bookie
<span class="nc" id="L566">            }</span>

            @Override
            public void diskWritable(File disk) {
                // Nothing to handle here. Will be handled in Bookie
<span class="nc" id="L571">            }</span>

            @Override
            public void diskJustWritable(File disk) {
                // Nothing to handle here. Will be handled in Bookie
<span class="nc" id="L576">            }</span>
        };
    }

    private void relocateIndexFileAndFlushHeader(long ledger, FileInfo fi) throws IOException {
<span class="fc" id="L581">        File currentDir = getLedgerDirForLedger(fi);</span>
<span class="pc bpc" id="L582" title="1 of 2 branches missed.">        if (ledgerDirsManager.isDirFull(currentDir)) {</span>
<span class="nc" id="L583">            moveLedgerIndexFile(ledger, fi);</span>
        }
<span class="fc" id="L585">        fi.flushHeader();</span>
<span class="fc" id="L586">    }</span>

    /**
     * Get the ledger directory that the ledger index belongs to.
     *
     * @param fi File info of a ledger
     * @return ledger directory that the ledger belongs to.
     */
    private File getLedgerDirForLedger(FileInfo fi) {
<span class="fc" id="L595">        return fi.getLf().getParentFile().getParentFile().getParentFile();</span>
    }

    private void moveLedgerIndexFile(Long l, FileInfo fi) throws NoWritableLedgerDirException, IOException {
<span class="nc" id="L599">        File newLedgerIndexFile = getNewLedgerIndexFile(l, getLedgerDirForLedger(fi));</span>
<span class="nc" id="L600">        fi.moveToNewLocation(newLedgerIndexFile, fi.getSizeSinceLastwrite());</span>
<span class="nc" id="L601">    }</span>

    void flushLedgerHeader(long ledger) throws IOException {
<span class="fc" id="L604">        FileInfo fi = null;</span>
        try {
<span class="fc" id="L606">            fi = getFileInfo(ledger, null);</span>
<span class="fc" id="L607">            relocateIndexFileAndFlushHeader(ledger, fi);</span>
<span class="nc" id="L608">        } catch (Bookie.NoLedgerException nle) {</span>
            // ledger has been deleted
<span class="nc" id="L610">            LOG.info(&quot;No ledger {} found when flushing header.&quot;, ledger);</span>
<span class="nc" id="L611">            return;</span>
        } finally {
<span class="pc bpc" id="L613" title="1 of 2 branches missed.">            if (null != fi) {</span>
<span class="fc" id="L614">                fi.release();</span>
            }
        }
<span class="fc" id="L617">    }</span>

    void flushLedgerEntries(long l, List&lt;LedgerEntryPage&gt; entries) throws IOException {
<span class="fc" id="L620">        FileInfo fi = null;</span>
        try {
<span class="fc" id="L622">            Collections.sort(entries, new Comparator&lt;LedgerEntryPage&gt;() {</span>
                @Override
                public int compare(LedgerEntryPage o1, LedgerEntryPage o2) {
<span class="nc" id="L625">                    return (int) (o1.getFirstEntry() - o2.getFirstEntry());</span>
                }
            });
<span class="fc" id="L628">            int[] versions = new int[entries.size()];</span>
            try {
<span class="fc" id="L630">                fi = getFileInfo(l, null);</span>
<span class="nc" id="L631">            } catch (Bookie.NoLedgerException nle) {</span>
                // ledger has been deleted
<span class="nc" id="L633">                LOG.info(&quot;No ledger {} found when flushing entries.&quot;, l);</span>
<span class="nc" id="L634">                return;</span>
<span class="fc" id="L635">            }</span>

            // flush the header if necessary
<span class="fc" id="L638">            relocateIndexFileAndFlushHeader(l, fi);</span>
<span class="fc" id="L639">            int start = 0;</span>
<span class="fc" id="L640">            long lastOffset = -1;</span>
<span class="fc bfc" id="L641" title="All 2 branches covered.">            for (int i = 0; i &lt; entries.size(); i++) {</span>
<span class="fc" id="L642">                versions[i] = entries.get(i).getVersion();</span>
<span class="pc bpc" id="L643" title="3 of 4 branches missed.">                if (lastOffset != -1 &amp;&amp; (entries.get(i).getFirstEntry() - lastOffset) != entriesPerPage) {</span>
                    // send up a sequential list
<span class="nc" id="L645">                    int count = i - start;</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">                    if (count == 0) {</span>
<span class="nc" id="L647">                        LOG.warn(&quot;Count cannot possibly be zero!&quot;);</span>
                    }
<span class="nc" id="L649">                    writeBuffers(l, entries, fi, start, count);</span>
<span class="nc" id="L650">                    start = i;</span>
                }
<span class="fc" id="L652">                lastOffset = entries.get(i).getFirstEntry();</span>
            }
<span class="pc bpc" id="L654" title="3 of 4 branches missed.">            if (entries.size() - start == 0 &amp;&amp; entries.size() != 0) {</span>
<span class="nc" id="L655">                LOG.warn(&quot;Nothing to write, but there were entries!&quot;);</span>
            }
<span class="fc" id="L657">            writeBuffers(l, entries, fi, start, entries.size() - start);</span>
<span class="fc bfc" id="L658" title="All 2 branches covered.">            for (int i = 0; i &lt; entries.size(); i++) {</span>
<span class="fc" id="L659">                LedgerEntryPage lep = entries.get(i);</span>
<span class="fc" id="L660">                lep.setClean(versions[i]);</span>
            }
<span class="pc bpc" id="L662" title="1 of 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L663">                LOG.debug(&quot;Flushed ledger {} with {} pages.&quot;, l, entries.size());</span>
            }
        } finally {
<span class="pc bpc" id="L666" title="1 of 2 branches missed.">            if (fi != null) {</span>
<span class="fc" id="L667">                fi.release();</span>
            }
        }
<span class="fc" id="L670">    }</span>

    private void writeBuffers(Long ledger,
                              List&lt;LedgerEntryPage&gt; entries, FileInfo fi,
                              int start, int count) throws IOException {
<span class="pc bpc" id="L675" title="1 of 2 branches missed.">        if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L676">            LOG.trace(&quot;Writing {} buffers of {}&quot;, count, Long.toHexString(ledger));</span>
        }
<span class="pc bpc" id="L678" title="1 of 2 branches missed.">        if (count == 0) {</span>
<span class="nc" id="L679">            return;</span>
        }
<span class="fc" id="L681">        ByteBuffer buffs[] = new ByteBuffer[count];</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">        for (int j = 0; j &lt; count; j++) {</span>
<span class="fc" id="L683">            buffs[j] = entries.get(start + j).getPageToWrite();</span>
<span class="pc bpc" id="L684" title="1 of 2 branches missed.">            if (entries.get(start + j).getLedger() != ledger) {</span>
<span class="nc" id="L685">                throw new IOException(&quot;Writing to &quot; + ledger + &quot; but page belongs to &quot;</span>
<span class="nc" id="L686">                                + entries.get(start + j).getLedger());</span>
            }
        }
<span class="fc" id="L689">        long totalWritten = 0;</span>
<span class="fc bfc" id="L690" title="All 2 branches covered.">        while (buffs[buffs.length - 1].remaining() &gt; 0) {</span>
<span class="fc" id="L691">            long rc = fi.write(buffs, entries.get(start + 0).getFirstEntryPosition());</span>
<span class="pc bpc" id="L692" title="1 of 2 branches missed.">            if (rc &lt;= 0) {</span>
<span class="nc" id="L693">                throw new IOException(&quot;Short write to ledger &quot; + ledger + &quot; rc = &quot; + rc);</span>
            }
<span class="fc" id="L695">            totalWritten += rc;</span>
<span class="fc" id="L696">        }</span>
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">        if (totalWritten != (long) count * (long) pageSize) {</span>
<span class="nc" id="L698">            throw new IOException(&quot;Short write to ledger &quot; + ledger + &quot; wrote &quot; + totalWritten</span>
                            + &quot; expected &quot; + count * pageSize);
        }
<span class="fc" id="L701">    }</span>

    /**
     * Update the ledger entry page.
     *
     * @param lep
     *          ledger entry page
     * @return true if it is a new page, otherwise false.
     * @throws IOException
     */
    boolean updatePage(LedgerEntryPage lep) throws IOException {
<span class="pc bpc" id="L712" title="1 of 2 branches missed.">        if (!lep.isClean()) {</span>
<span class="nc" id="L713">            throw new IOException(&quot;Trying to update a dirty page&quot;);</span>
        }
<span class="fc" id="L715">        FileInfo fi = null;</span>
        try {
<span class="fc" id="L717">            fi = getFileInfo(lep.getLedger(), null);</span>
<span class="fc" id="L718">            long pos = lep.getFirstEntryPosition();</span>
<span class="pc bpc" id="L719" title="1 of 2 branches missed.">            if (pos &gt;= fi.size()) {</span>
<span class="fc" id="L720">                lep.zeroPage();</span>
<span class="fc" id="L721">                return true;</span>
            } else {
<span class="nc" id="L723">                lep.readPage(fi);</span>
<span class="nc" id="L724">                return false;</span>
            }
        } finally {
<span class="pc bpc" id="L727" title="1 of 2 branches missed.">            if (fi != null) {</span>
<span class="fc" id="L728">                fi.release();</span>
            }
        }
    }

    long getPersistEntryBeyondInMem(long ledgerId, long lastEntryInMem) throws IOException {
<span class="nc" id="L734">        FileInfo fi = null;</span>
<span class="nc" id="L735">        long lastEntry = lastEntryInMem;</span>
        try {
<span class="nc" id="L737">            fi = getFileInfo(ledgerId, null);</span>
<span class="nc" id="L738">            long size = fi.size();</span>
            // make sure the file size is aligned with index entry size
            // otherwise we may read incorret data
<span class="nc bnc" id="L741" title="All 2 branches missed.">            if (0 != size % LedgerEntryPage.getIndexEntrySize()) {</span>
<span class="nc" id="L742">                LOG.warn(&quot;Index file of ledger {} is not aligned with index entry size.&quot;, ledgerId);</span>
<span class="nc" id="L743">                size = size - size % LedgerEntryPage.getIndexEntrySize();</span>
            }
            // we may not have the last entry in the cache
<span class="nc bnc" id="L746" title="All 2 branches missed.">            if (size &gt; lastEntry * LedgerEntryPage.getIndexEntrySize()) {</span>
<span class="nc" id="L747">                ByteBuffer bb = ByteBuffer.allocate(pageSize);</span>
<span class="nc" id="L748">                long position = size - pageSize;</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">                if (position &lt; 0) {</span>
<span class="nc" id="L750">                    position = 0;</span>
                }
                // we read the last page from file size minus page size, so it should not encounter short read
                // exception. if it does, it is an unexpected situation, then throw the exception and fail it
                // immediately.
                try {
<span class="nc" id="L756">                    fi.read(bb, position, false);</span>
<span class="nc" id="L757">                } catch (ShortReadException sre) {</span>
                    // throw a more meaningful exception with ledger id
<span class="nc" id="L759">                    throw new ShortReadException(&quot;Short read on ledger &quot; + ledgerId + &quot; : &quot;, sre);</span>
<span class="nc" id="L760">                }</span>
<span class="nc" id="L761">                bb.flip();</span>
<span class="nc" id="L762">                long startingEntryId = position / LedgerEntryPage.getIndexEntrySize();</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">                for (int i = entriesPerPage - 1; i &gt;= 0; i--) {</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">                    if (bb.getLong(i * LedgerEntryPage.getIndexEntrySize()) != 0) {</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">                        if (lastEntry &lt; startingEntryId + i) {</span>
<span class="nc" id="L766">                            lastEntry = startingEntryId + i;</span>
                        }
                        break;
                    }
                }
            }
        } finally {
<span class="nc bnc" id="L773" title="All 2 branches missed.">            if (fi != null) {</span>
<span class="nc" id="L774">                fi.release();</span>
            }
        }
<span class="nc" id="L777">        return lastEntry;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>