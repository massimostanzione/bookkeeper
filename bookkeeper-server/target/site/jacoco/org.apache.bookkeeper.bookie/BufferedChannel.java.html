<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BufferedChannel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.bookie</a> &gt; <span class="el_source">BufferedChannel.java</span></div><h1>BufferedChannel.java</h1><pre class="source lang-java linenums">/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

package org.apache.bookkeeper.bookie;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.util.concurrent.atomic.AtomicLong;
import org.apache.bookkeeper.util.ZeroBuffer;

/**
 * Provides a buffering layer in front of a FileChannel.
 */
public class BufferedChannel extends BufferedReadChannel {
    // The capacity of the write buffer.
    protected final int writeCapacity;
    // The position of the file channel's write pointer.
<span class="fc" id="L37">    protected AtomicLong writeBufferStartPosition = new AtomicLong(0);</span>
    // The buffer used to write operations.
    protected final ByteBuffer writeBuffer;
    // The absolute position of the next write operation.
    protected volatile long position;

    // make constructor to be public for unit test
    public BufferedChannel(FileChannel fc, int capacity) throws IOException {
        // Use the same capacity for read and write buffers.
<span class="fc" id="L46">        this(fc, capacity, capacity);</span>
<span class="fc" id="L47">    }</span>

    public BufferedChannel(FileChannel fc, int writeCapacity, int readCapacity) throws IOException {
<span class="fc" id="L50">        super(fc, readCapacity);</span>
        // Set the read buffer's limit to readCapacity.
<span class="fc" id="L52">        this.readBuffer.limit(readCapacity);</span>
<span class="fc" id="L53">        this.writeCapacity = writeCapacity;</span>
<span class="fc" id="L54">        this.position = fc.position();</span>
<span class="fc" id="L55">        this.writeBufferStartPosition.set(position);</span>
<span class="fc" id="L56">        this.writeBuffer = ByteBuffer.allocateDirect(writeCapacity);</span>
<span class="fc" id="L57">    }</span>

    /**
     * Write all the data in src to the {@link FileChannel}. Note that this function can
     * buffer or re-order writes based on the implementation. These writes will be flushed
     * to the disk only when flush() is invoked.
     *
     * @param src The source ByteBuffer which contains the data to be written.
     * @throws IOException if a write operation fails.
     */
    public synchronized void write(ByteBuffer src) throws IOException {
<span class="fc" id="L68">        int copied = 0;</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">        while (src.remaining() &gt; 0) {</span>
<span class="fc" id="L70">            int truncated = 0;</span>
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">            if (writeBuffer.remaining() &lt; src.remaining()) {</span>
<span class="nc" id="L72">                truncated = src.remaining() - writeBuffer.remaining();</span>
<span class="nc" id="L73">                src.limit(src.limit() - truncated);</span>
            }
<span class="fc" id="L75">            copied += src.remaining();</span>
<span class="fc" id="L76">            writeBuffer.put(src);</span>
<span class="fc" id="L77">            src.limit(src.limit() + truncated);</span>
            // if we have run out of buffer space, we should flush to the file
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">            if (writeBuffer.remaining() == 0) {</span>
<span class="nc" id="L80">                flushInternal();</span>
            }
<span class="fc" id="L82">        }</span>
<span class="fc" id="L83">        position += copied;</span>
<span class="fc" id="L84">    }</span>

    /**
     * Get the position where the next write operation will begin writing from.
     * @return
     */
    public long position() {
<span class="fc" id="L91">        return position;</span>
    }

    /**
     * Get the position of the file channel's write pointer.
     * @return
     */
    public long getFileChannelPosition() {
<span class="nc" id="L99">        return writeBufferStartPosition.get();</span>
    }


    /**
     * Write any data in the buffer to the file. If sync is set to true, force a sync operation so that
     * data is persisted to the disk.
     * @param shouldForceWrite
     * @throws IOException if the write or sync operation fails.
     */
    public void flush(boolean shouldForceWrite) throws IOException {
<span class="fc" id="L110">        synchronized (this) {</span>
<span class="fc" id="L111">            flushInternal();</span>
<span class="fc" id="L112">        }</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">        if (shouldForceWrite) {</span>
<span class="fc" id="L114">            forceWrite(false);</span>
        }
<span class="fc" id="L116">    }</span>

    /**
     * Write any data in the buffer to the file and advance the writeBufferPosition.
     * Callers are expected to synchronize appropriately
     * @throws IOException if the write fails.
     */
    private void flushInternal() throws IOException {
<span class="fc" id="L124">        writeBuffer.flip();</span>
        do {
<span class="fc" id="L126">            fileChannel.write(writeBuffer);</span>
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">        } while (writeBuffer.hasRemaining());</span>
<span class="fc" id="L128">        writeBuffer.clear();</span>
<span class="fc" id="L129">        writeBufferStartPosition.set(fileChannel.position());</span>
<span class="fc" id="L130">    }</span>

    public long forceWrite(boolean forceMetadata) throws IOException {
        // This is the point up to which we had flushed to the file system page cache
        // before issuing this force write hence is guaranteed to be made durable by
        // the force write, any flush that happens after this may or may
        // not be flushed
<span class="fc" id="L137">        long positionForceWrite = writeBufferStartPosition.get();</span>
<span class="fc" id="L138">        fileChannel.force(forceMetadata);</span>
<span class="fc" id="L139">        return positionForceWrite;</span>
    }

    @Override
    public synchronized int read(ByteBuffer dest, long pos) throws IOException {
<span class="nc" id="L144">        long prevPos = pos;</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">        while (dest.remaining() &gt; 0) {</span>
            // check if it is in the write buffer
<span class="nc bnc" id="L147" title="All 4 branches missed.">            if (writeBuffer != null &amp;&amp; writeBufferStartPosition.get() &lt;= pos) {</span>
<span class="nc" id="L148">                long positionInBuffer = pos - writeBufferStartPosition.get();</span>
<span class="nc" id="L149">                long bytesToCopy = writeBuffer.position() - positionInBuffer;</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">                if (bytesToCopy &gt; dest.remaining()) {</span>
<span class="nc" id="L151">                    bytesToCopy = dest.remaining();</span>
                }
<span class="nc bnc" id="L153" title="All 2 branches missed.">                if (bytesToCopy == 0) {</span>
<span class="nc" id="L154">                    throw new IOException(&quot;Read past EOF&quot;);</span>
                }
<span class="nc" id="L156">                ByteBuffer src = writeBuffer.duplicate();</span>
<span class="nc" id="L157">                src.position((int) positionInBuffer);</span>
<span class="nc" id="L158">                src.limit((int) (positionInBuffer + bytesToCopy));</span>
<span class="nc" id="L159">                dest.put(src);</span>
<span class="nc" id="L160">                pos += bytesToCopy;</span>
<span class="nc bnc" id="L161" title="All 4 branches missed.">            } else if (writeBuffer == null &amp;&amp; writeBufferStartPosition.get() &lt;= pos) {</span>
                // here we reach the end
<span class="nc" id="L163">                break;</span>
                // first check if there is anything we can grab from the readBuffer
<span class="nc bnc" id="L165" title="All 4 branches missed.">            } else if (readBufferStartPosition &lt;= pos &amp;&amp; pos &lt; readBufferStartPosition + readBuffer.capacity()) {</span>
<span class="nc" id="L166">                long positionInBuffer = pos - readBufferStartPosition;</span>
<span class="nc" id="L167">                long bytesToCopy = readBuffer.capacity() - positionInBuffer;</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">                if (bytesToCopy &gt; dest.remaining()) {</span>
<span class="nc" id="L169">                    bytesToCopy = dest.remaining();</span>
                }
<span class="nc" id="L171">                ByteBuffer src = readBuffer.duplicate();</span>
<span class="nc" id="L172">                src.position((int) positionInBuffer);</span>
<span class="nc" id="L173">                src.limit((int) (positionInBuffer + bytesToCopy));</span>
<span class="nc" id="L174">                dest.put(src);</span>
<span class="nc" id="L175">                pos += bytesToCopy;</span>
                // let's read it
<span class="nc" id="L177">            } else {</span>
<span class="nc" id="L178">                readBufferStartPosition = pos;</span>
<span class="nc" id="L179">                readBuffer.clear();</span>
                // make sure that we don't overlap with the write buffer
<span class="nc bnc" id="L181" title="All 2 branches missed.">                if (readBufferStartPosition + readBuffer.capacity() &gt;= writeBufferStartPosition.get()) {</span>
<span class="nc" id="L182">                    readBufferStartPosition = writeBufferStartPosition.get() - readBuffer.capacity();</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">                    if (readBufferStartPosition &lt; 0) {</span>
<span class="nc" id="L184">                        ZeroBuffer.put(readBuffer, (int) -readBufferStartPosition);</span>
                    }
                }
<span class="nc bnc" id="L187" title="All 2 branches missed.">                while (readBuffer.remaining() &gt; 0) {</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">                    if (fileChannel.read(readBuffer, readBufferStartPosition + readBuffer.position()) &lt;= 0) {</span>
<span class="nc" id="L189">                        throw new IOException(&quot;Short read&quot;);</span>
                    }
                }
<span class="nc" id="L192">                ZeroBuffer.put(readBuffer);</span>
<span class="nc" id="L193">                readBuffer.clear();</span>
            }
        }
<span class="nc" id="L196">        return (int) (pos - prevPos);</span>
    }

    @Override
    public synchronized void clear() {
<span class="nc" id="L201">        super.clear();</span>
<span class="nc" id="L202">        writeBuffer.clear();</span>
<span class="nc" id="L203">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>