<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClientConfiguration.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.conf</a> &gt; <span class="el_source">ClientConfiguration.java</span></div><h1>ClientConfiguration.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.bookkeeper.conf;

import static com.google.common.base.Charsets.UTF_8;
import static org.apache.bookkeeper.util.BookKeeperConstants.FEATURE_DISABLE_ENSEMBLE_CHANGE;

import io.netty.buffer.ByteBuf;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import org.apache.bookkeeper.client.BookKeeper.DigestType;
import org.apache.bookkeeper.client.EnsemblePlacementPolicy;
import org.apache.bookkeeper.client.LedgerHandle;
import org.apache.bookkeeper.client.RackawareEnsemblePlacementPolicy;
import org.apache.bookkeeper.discover.RegistrationClient;
import org.apache.bookkeeper.discover.ZKRegistrationClient;
import org.apache.bookkeeper.replication.Auditor;
import org.apache.bookkeeper.util.ReflectionUtils;
import org.apache.commons.configuration.ConfigurationException;
import org.apache.commons.lang.StringUtils;


/**
 * Configuration settings for client side.
 */
public class ClientConfiguration extends AbstractConfiguration {

    // Zookeeper Parameters
    protected final static String ZK_TIMEOUT = &quot;zkTimeout&quot;;
    protected final static String ZK_SERVERS = &quot;zkServers&quot;;

    // Throttle value
    protected final static String THROTTLE = &quot;throttle&quot;;

    // Digest Type
    protected final static String DIGEST_TYPE = &quot;digestType&quot;;
    protected final static String ENABLE_DIGEST_TYPE_AUTODETECTION = &quot;enableDigestTypeAutodetection&quot;;

    // Passwd
    protected final static String PASSWD = &quot;passwd&quot;;

    // NIO Parameters
    protected final static String CLIENT_TCP_NODELAY = &quot;clientTcpNoDelay&quot;;
    protected final static String CLIENT_SOCK_KEEPALIVE = &quot;clientSockKeepalive&quot;;
    protected final static String CLIENT_SENDBUFFER_SIZE = &quot;clientSendBufferSize&quot;;
    protected final static String CLIENT_RECEIVEBUFFER_SIZE = &quot;clientReceiveBufferSize&quot;;
    protected final static String CLIENT_WRITEBUFFER_LOW_WATER_MARK = &quot;clientWriteBufferLowWaterMark&quot;;
    protected final static String CLIENT_WRITEBUFFER_HIGH_WATER_MARK = &quot;clientWriteBufferHighWaterMark&quot;;
    protected final static String CLIENT_CONNECT_TIMEOUT_MILLIS = &quot;clientConnectTimeoutMillis&quot;;
    protected final static String NUM_CHANNELS_PER_BOOKIE = &quot;numChannelsPerBookie&quot;;
    protected final static String USE_V2_WIRE_PROTOCOL = &quot;useV2WireProtocol&quot;;
    protected final static String NETTY_USE_POOLED_BUFFERS = &quot;nettyUsePooledBuffers&quot;;

    // Read Parameters
    protected final static String READ_TIMEOUT = &quot;readTimeout&quot;;
    protected final static String SPECULATIVE_READ_TIMEOUT = &quot;speculativeReadTimeout&quot;;
    protected final static String FIRST_SPECULATIVE_READ_TIMEOUT = &quot;firstSpeculativeReadTimeout&quot;;
    protected final static String MAX_SPECULATIVE_READ_TIMEOUT = &quot;maxSpeculativeReadTimeout&quot;;
    protected final static String SPECULATIVE_READ_TIMEOUT_BACKOFF_MULTIPLIER = &quot;speculativeReadTimeoutBackoffMultiplier&quot;;
    protected final static String FIRST_SPECULATIVE_READ_LAC_TIMEOUT = &quot;firstSpeculativeReadLACTimeout&quot;;
    protected final static String MAX_SPECULATIVE_READ_LAC_TIMEOUT = &quot;maxSpeculativeReadLACTimeout&quot;;
    protected final static String SPECULATIVE_READ_LAC_TIMEOUT_BACKOFF_MULTIPLIER = &quot;speculativeReadLACTimeoutBackoffMultiplier&quot;;
    protected final static String ENABLE_PARALLEL_RECOVERY_READ = &quot;enableParallelRecoveryRead&quot;;
    protected final static String RECOVERY_READ_BATCH_SIZE = &quot;recoveryReadBatchSize&quot;;
    protected final static String REORDER_READ_SEQUENCE_ENABLED = &quot;reorderReadSequenceEnabled&quot;;
    // Add Parameters
    protected final static String DELAY_ENSEMBLE_CHANGE = &quot;delayEnsembleChange&quot;;
    // Timeout Setting
    protected final static String ADD_ENTRY_TIMEOUT_SEC = &quot;addEntryTimeoutSec&quot;;
    protected final static String ADD_ENTRY_QUORUM_TIMEOUT_SEC = &quot;addEntryQuorumTimeoutSec&quot;;
    protected final static String READ_ENTRY_TIMEOUT_SEC = &quot;readEntryTimeoutSec&quot;;
    protected final static String TIMEOUT_TASK_INTERVAL_MILLIS = &quot;timeoutTaskIntervalMillis&quot;;
    protected final static String EXPLICIT_LAC_INTERVAL = &quot;explicitLacInterval&quot;;
    protected final static String PCBC_TIMEOUT_TIMER_TICK_DURATION_MS = &quot;pcbcTimeoutTimerTickDurationMs&quot;;
    protected final static String PCBC_TIMEOUT_TIMER_NUM_TICKS = &quot;pcbcTimeoutTimerNumTicks&quot;;
    protected final static String TIMEOUT_TIMER_TICK_DURATION_MS = &quot;timeoutTimerTickDurationMs&quot;;
    protected final static String TIMEOUT_TIMER_NUM_TICKS = &quot;timeoutTimerNumTicks&quot;;

    // Bookie health check settings
    protected final static String BOOKIE_HEALTH_CHECK_ENABLED = &quot;bookieHealthCheckEnabled&quot;;
    protected final static String BOOKIE_HEALTH_CHECK_INTERVAL_SECONDS = &quot;bookieHealthCheckIntervalSeconds&quot;;
    protected final static String BOOKIE_ERROR_THRESHOLD_PER_INTERVAL = &quot;bookieErrorThresholdPerInterval&quot;;
    protected final static String BOOKIE_QUARANTINE_TIME_SECONDS = &quot;bookieQuarantineTimeSeconds&quot;;

    // Bookie info poll interval
    protected final static String DISK_WEIGHT_BASED_PLACEMENT_ENABLED = &quot;diskWeightBasedPlacementEnabled&quot;;
    protected final static String GET_BOOKIE_INFO_INTERVAL_SECONDS = &quot;getBookieInfoIntervalSeconds&quot;;
    protected final static String GET_BOOKIE_INFO_RETRY_INTERVAL_SECONDS = &quot;getBookieInfoRetryIntervalSeconds&quot;;
    protected final static String BOOKIE_MAX_MULTIPLE_FOR_WEIGHTED_PLACEMENT = &quot;bookieMaxMultipleForWeightBasedPlacement&quot;;
    protected final static String GET_BOOKIE_INFO_TIMEOUT_SECS = &quot;getBookieInfoTimeoutSecs&quot;;
    protected final static String START_TLS_TIMEOUT_SECS = &quot;startTLSTimeoutSecs&quot;;

    // Number Woker Threads
    protected final static String NUM_WORKER_THREADS = &quot;numWorkerThreads&quot;;

    // Ensemble Placement Policy
    protected final static String ENSEMBLE_PLACEMENT_POLICY = &quot;ensemblePlacementPolicy&quot;;
    protected final static String NETWORK_TOPOLOGY_STABILIZE_PERIOD_SECONDS = &quot;networkTopologyStabilizePeriodSeconds&quot;;

    // Ledger Metadata Parameters
    protected static final String STORE_SYSTEMTIME_AS_LEDGER_CREATION_TIME = &quot;storeSystemTimeAsLedgerCreationTime&quot;;

    // Stats
    protected final static String ENABLE_TASK_EXECUTION_STATS = &quot;enableTaskExecutionStats&quot;;
    protected final static String TASK_EXECUTION_WARN_TIME_MICROS = &quot;taskExecutionWarnTimeMicros&quot;;

    // Failure History Settings
    protected final static String ENABLE_BOOKIE_FAILURE_TRACKING = &quot;enableBookieFailureTracking&quot;;
    protected final static String BOOKIE_FAILURE_HISTORY_EXPIRATION_MS = &quot;bookieFailureHistoryExpirationMSec&quot;;

    // Names of dynamic features
    protected final static String DISABLE_ENSEMBLE_CHANGE_FEATURE_NAME = &quot;disableEnsembleChangeFeatureName&quot;;

    // Role of the client
    protected final static String CLIENT_ROLE = &quot;clientRole&quot;;

    /**
     * This client will act as a standard client
     */
    public final static String CLIENT_ROLE_STANDARD = &quot;standard&quot;;

    /**
     * This client will act as a system client, like the {@link Auditor}
     */
    public final static String CLIENT_ROLE_SYSTEM = &quot;system&quot;;

    // Client auth provider factory class name. It must be configured on Bookies to for the Auditor
    protected final static String CLIENT_AUTH_PROVIDER_FACTORY_CLASS = &quot;clientAuthProviderFactoryClass&quot;;

    // Client TLS
    protected final static String TLS_KEYSTORE_TYPE = &quot;clientKeyStoreType&quot;;
    protected final static String TLS_KEYSTORE = &quot;clientKeyStore&quot;;
    protected final static String TLS_KEYSTORE_PASSWORD_PATH = &quot;clientKeyStorePasswordPath&quot;;
    protected final static String TLS_TRUSTSTORE_TYPE = &quot;clientTrustStoreType&quot;;
    protected final static String TLS_TRUSTSTORE = &quot;clientTrustStore&quot;;
    protected final static String TLS_TRUSTSTORE_PASSWORD_PATH = &quot;clientTrustStorePasswordPath&quot;;

    // Registration Client
    protected final static String REGISTRATION_CLIENT_CLASS = &quot;registrationClientClass&quot;;

    /**
     * Construct a default client-side configuration
     */
    public ClientConfiguration() {
<span class="fc" id="L162">        super();</span>
<span class="fc" id="L163">    }</span>

    /**
     * Construct a client-side configuration using a base configuration
     *
     * @param conf
     *          Base configuration
     */
    public ClientConfiguration(AbstractConfiguration conf) {
<span class="nc" id="L172">        super();</span>
<span class="nc" id="L173">        loadConf(conf);</span>
<span class="nc" id="L174">    }</span>

    /**
     * Get throttle value
     *
     * @return throttle value
     * @see #setThrottleValue
     */
    public int getThrottleValue() {
<span class="fc" id="L183">        return this.getInt(THROTTLE, 5000);</span>
    }

    /**
     * Set throttle value.
     *
     * Since BookKeeper process requests in asynchronous way, it will holds
     * those pending request in queue. You may easily run it out of memory
     * if producing too many requests than the capability of bookie servers can handle.
     * To prevent that from happening, you can set a throttle value here.
     *
     * Setting the throttle value to 0, will disable any throttling.
     *
     * @param throttle
     *          Throttle Value
     * @return client configuration
     */
    public ClientConfiguration setThrottleValue(int throttle) {
<span class="nc" id="L201">        this.setProperty(THROTTLE, Integer.toString(throttle));</span>
<span class="nc" id="L202">        return this;</span>
    }

    /**
     * Get autodetection of digest type.
     * Ignores provided digestType, if enabled and uses one from ledger metadata instead.
     * Incompatible with ledger created by bookie versions &lt; 4.2
     *
     * @return flag to enable/disable autodetection of digest type.
     */
    public boolean getEnableDigestTypeAutodetection() {
<span class="nc" id="L213">        return getBoolean(ENABLE_DIGEST_TYPE_AUTODETECTION, false);</span>
    }

    /**
     * Enable autodetection of digest type.
     * Ignores provided digestType, if enabled and uses one from ledger metadata instead.
     * Incompatible with ledger created by bookie versions &lt; 4.2
     *
     * @return client configuration.
     */
    public ClientConfiguration setEnableDigestTypeAutodetection(boolean enable) {
<span class="nc" id="L224">        this.setProperty(ENABLE_DIGEST_TYPE_AUTODETECTION, enable);</span>
<span class="nc" id="L225">        return this;</span>
    }
    
    /**
     * Get digest type used in bookkeeper admin
     *
     * @return digest type
     * @see #setBookieRecoveryDigestType
     */
    public DigestType getBookieRecoveryDigestType() {
<span class="nc" id="L235">        return DigestType.valueOf(this.getString(DIGEST_TYPE, DigestType.CRC32.toString()));</span>
    }

    /**
     * Set digest type used in bookkeeper admin.
     *
     * Digest Type and Passwd used to open ledgers for admin tool
     * For now, assume that all ledgers were created with the same DigestType
     * and password. In the future, this admin tool will need to know for each
     * ledger, what was the DigestType and password used to create it before it
     * can open it. These values will come from System properties, though fixed
     * defaults are defined here.
     *
     * @param digestType
     *          Digest Type
     * @return client configuration
     */
    public ClientConfiguration setBookieRecoveryDigestType(DigestType digestType) {
<span class="nc" id="L253">        this.setProperty(DIGEST_TYPE, digestType.toString());</span>
<span class="nc" id="L254">        return this;</span>
    }

    /**
     * Get passwd used in bookkeeper admin
     *
     * @return password
     * @see #setBookieRecoveryPasswd
     */
    public byte[] getBookieRecoveryPasswd() {
<span class="nc" id="L264">        return this.getString(PASSWD, &quot;&quot;).getBytes(UTF_8);</span>
    }

    /**
     * Set passwd used in bookkeeper admin.
     *
     * Digest Type and Passwd used to open ledgers for admin tool
     * For now, assume that all ledgers were created with the same DigestType
     * and password. In the future, this admin tool will need to know for each
     * ledger, what was the DigestType and password used to create it before it
     * can open it. These values will come from System properties, though fixed
     * defaults are defined here.
     *
     * @param passwd
     *          Password
     * @return client configuration
     */
    public ClientConfiguration setBookieRecoveryPasswd(byte[] passwd) {
<span class="nc" id="L282">        setProperty(PASSWD, new String(passwd, UTF_8));</span>
<span class="nc" id="L283">        return this;</span>
    }

    /**
     * Is tcp connection no delay.
     *
     * @return tcp socket nodelay setting
     * @see #setClientTcpNoDelay
     */
    public boolean getClientTcpNoDelay() {
<span class="fc" id="L293">        return getBoolean(CLIENT_TCP_NODELAY, true);</span>
    }

    /**
     * Set socket nodelay setting.
     *
     * This settings is used to enabled/disabled Nagle's algorithm, which is a means of
     * improving the efficiency of TCP/IP networks by reducing the number of packets
     * that need to be sent over the network. If you are sending many small messages,
     * such that more than one can fit in a single IP packet, setting client.tcpnodelay
     * to false to enable Nagle algorithm can provide better performance.
     * &lt;br&gt;
     * Default value is true.
     *
     * @param noDelay
     *          NoDelay setting
     * @return client configuration
     */
    public ClientConfiguration setClientTcpNoDelay(boolean noDelay) {
<span class="nc" id="L312">        setProperty(CLIENT_TCP_NODELAY, Boolean.toString(noDelay));</span>
<span class="nc" id="L313">        return this;</span>
    }

    /**
     * get socket keepalive
     * 
     * @return socket keepalive setting
     */
    public boolean getClientSockKeepalive() {
<span class="fc" id="L322">        return getBoolean(CLIENT_SOCK_KEEPALIVE, true);</span>
    }

    /**
     * Set socket keepalive setting.
     * 
     * This setting is used to send keep-alive messages on connection-oriented sockets.
     * 
     * @param keepalive
     *            KeepAlive setting
     * @return client configuration
     */
    public ClientConfiguration setClientSockKeepalive(boolean keepalive) {
<span class="nc" id="L335">        setProperty(CLIENT_SOCK_KEEPALIVE, Boolean.toString(keepalive));</span>
<span class="nc" id="L336">        return this;</span>
    }

    /**
     * Get client netty channel send buffer size.
     *
     * @return client netty channel send buffer size
     */
    public int getClientSendBufferSize() {
<span class="fc" id="L345">        return getInt(CLIENT_SENDBUFFER_SIZE, 1 * 1024 * 1024);</span>
    }

    /**
     * Set client netty channel send buffer size.
     *
     * @param bufferSize
     *          client netty channel send buffer size.
     * @return client configuration.
     */
    public ClientConfiguration setClientSendBufferSize(int bufferSize) {
<span class="nc" id="L356">        setProperty(CLIENT_SENDBUFFER_SIZE, bufferSize);</span>
<span class="nc" id="L357">        return this;</span>
    }

    /**
     * Get client netty channel receive buffer size.
     *
     * @return client netty channel receive buffer size.
     */
    public int getClientReceiveBufferSize() {
<span class="fc" id="L366">        return getInt(CLIENT_RECEIVEBUFFER_SIZE, 1 * 1024 * 1024);</span>
    }

    /**
     * Set client netty channel receive buffer size.
     *
     * @param bufferSize
     *          netty channel receive buffer size.
     * @return client configuration.
     */
    public ClientConfiguration setClientReceiveBufferSize(int bufferSize) {
<span class="nc" id="L377">        setProperty(CLIENT_RECEIVEBUFFER_SIZE, bufferSize);</span>
<span class="nc" id="L378">        return this;</span>
    }

    /**
     * Get client netty channel write buffer low water mark.
     *
     * @return netty channel write buffer low water mark.
     */
    public int getClientWriteBufferLowWaterMark() {
<span class="fc" id="L387">        return getInt(CLIENT_WRITEBUFFER_LOW_WATER_MARK, 32 * 1024);</span>
    }

    /**
     * Set client netty channel write buffer low water mark.
     *
     * @param waterMark
     *          netty channel write buffer low water mark.
     * @return client configuration.
     */
    public ClientConfiguration setClientWriteBufferLowWaterMark(int waterMark) {
<span class="nc" id="L398">        setProperty(CLIENT_WRITEBUFFER_LOW_WATER_MARK, waterMark);</span>
<span class="nc" id="L399">        return this;</span>
    }

    /**
     * Get client netty channel write buffer high water mark.
     *
     * @return netty channel write buffer high water mark.
     */
    public int getClientWriteBufferHighWaterMark() {
<span class="fc" id="L408">        return getInt(CLIENT_WRITEBUFFER_HIGH_WATER_MARK, 64 * 1024);</span>
    }

    /**
     * Set client netty channel write buffer high water mark.
     *
     * @param waterMark
     *          netty channel write buffer high water mark.
     * @return client configuration.
     */
    public ClientConfiguration setClientWriteBufferHighWaterMark(int waterMark) {
<span class="nc" id="L419">        setProperty(CLIENT_WRITEBUFFER_HIGH_WATER_MARK, waterMark);</span>
<span class="nc" id="L420">        return this;</span>
    }

    /**
     * Get the tick duration in milliseconds that used for timeout timer.
     *
     * @return tick duration in milliseconds
     */
    public long getTimeoutTimerTickDurationMs() {
<span class="fc" id="L429">        return getLong(TIMEOUT_TIMER_TICK_DURATION_MS, 100);</span>
    }

    /**
     * Set the tick duration in milliseconds that used for timeout timer.
     *
     * @param tickDuration
     *          tick duration in milliseconds.
     * @return client configuration.
     */
    public ClientConfiguration setTimeoutTimerTickDurationMs(long tickDuration) {
<span class="nc" id="L440">        setProperty(TIMEOUT_TIMER_TICK_DURATION_MS, tickDuration);</span>
<span class="nc" id="L441">        return this;</span>
    }

    /**
     * Get number of ticks that used for timeout timer.
     *
     * @return number of ticks that used for timeout timer.
     */
    public int getTimeoutTimerNumTicks() {
<span class="fc" id="L450">        return getInt(TIMEOUT_TIMER_NUM_TICKS, 1024);</span>
    }

    /**
     * Set number of ticks that used for timeout timer.
     *
     * @param numTicks
     *          number of ticks that used for timeout timer.
     * @return client configuration.
     */
    public ClientConfiguration setTimeoutTimerNumTicks(int numTicks) {
<span class="nc" id="L461">        setProperty(TIMEOUT_TIMER_NUM_TICKS, numTicks);</span>
<span class="nc" id="L462">        return this;</span>
    }

    /**
     * Get client netty connect timeout in millis.
     *
     * @return client netty connect timeout in millis.
     */
    public int getClientConnectTimeoutMillis() {
        // 10 seconds as netty default value.
<span class="fc" id="L472">        return getInt(CLIENT_CONNECT_TIMEOUT_MILLIS, 10000);</span>
    }

    /**
     * Set client netty connect timeout in millis.
     *
     * @param connectTimeoutMillis
     *          client netty connect timeout in millis.
     * @return client configuration.
     */
    public ClientConfiguration setClientConnectTimeoutMillis(int connectTimeoutMillis) {
<span class="nc" id="L483">        setProperty(CLIENT_CONNECT_TIMEOUT_MILLIS, connectTimeoutMillis);</span>
<span class="nc" id="L484">        return this;</span>
    }

    /**
     * Get num channels per bookie.
     *
     * @return num channels per bookie.
     */
    public int getNumChannelsPerBookie() {
<span class="fc" id="L493">        return getInt(NUM_CHANNELS_PER_BOOKIE, 1);</span>
    }

    /**
     * Set num channels per bookie.
     *
     * @param numChannelsPerBookie
     *          num channels per bookie.
     * @return client configuration.
     */
    public ClientConfiguration setNumChannelsPerBookie(int numChannelsPerBookie) {
<span class="nc" id="L504">        setProperty(NUM_CHANNELS_PER_BOOKIE, numChannelsPerBookie);</span>
<span class="nc" id="L505">        return this;</span>
    }

    /**
     * Use older Bookkeeper wire protocol (no protobuf)
     *
     * @return whether or not to use older Bookkeeper wire protocol (no protobuf)
     */
    public boolean getUseV2WireProtocol() {
<span class="fc" id="L514">        return getBoolean(USE_V2_WIRE_PROTOCOL, false);</span>
    }

    /**
     * Set whether or not to use older Bookkeeper wire protocol (no protobuf)
     *
     * @param useV2WireProtocol
     *          whether or not to use older Bookkeeper wire protocol (no protobuf)
     * @return client configuration.
     */
    public ClientConfiguration setUseV2WireProtocol(boolean useV2WireProtocol) {
<span class="nc" id="L525">        setProperty(USE_V2_WIRE_PROTOCOL, useV2WireProtocol);</span>
<span class="nc" id="L526">        return this;</span>
    }

    /**
     * Get zookeeper servers to connect
     *
     * @return zookeeper servers
     */
    public String getZkServers() {
<span class="fc" id="L535">        List servers = getList(ZK_SERVERS, null);</span>
<span class="pc bpc" id="L536" title="2 of 4 branches missed.">        if (null == servers || 0 == servers.size()) {</span>
<span class="nc" id="L537">            return &quot;localhost&quot;;</span>
        }
<span class="fc" id="L539">        return StringUtils.join(servers, &quot;,&quot;);</span>
    }

    /**
     * Set zookeeper servers to connect
     *
     * @param zkServers
     *          ZooKeeper servers to connect
     */
    public ClientConfiguration setZkServers(String zkServers) {
<span class="fc" id="L549">        setProperty(ZK_SERVERS, zkServers);</span>
<span class="fc" id="L550">        return this;</span>
    }

    /**
     * Get zookeeper timeout
     *
     * @return zookeeper client timeout
     */
    public int getZkTimeout() {
<span class="fc" id="L559">        return getInt(ZK_TIMEOUT, 10000);</span>
    }

    /**
     * Set zookeeper timeout
     *
     * @param zkTimeout
     *          ZooKeeper client timeout
     * @return client configuration
     */
    public ClientConfiguration setZkTimeout(int zkTimeout) {
<span class="nc" id="L570">        setProperty(ZK_TIMEOUT, Integer.toString(zkTimeout));</span>
<span class="nc" id="L571">        return this;</span>
    }

    /**
     * Get the socket read timeout. This is the number of
     * seconds we wait without hearing a response from a bookie
     * before we consider it failed.
     *
     * The default is 5 seconds.
     *
     * @return the current read timeout in seconds
     * @deprecated use {@link #getReadEntryTimeout()} or {@link #getAddEntryTimeout()} instead
     */
    @Deprecated
    public int getReadTimeout() {
<span class="fc" id="L586">        return getInt(READ_TIMEOUT, 5);</span>
    }

    /**
     * Set the socket read timeout.
     * @see #getReadTimeout()
     * @param timeout The new read timeout in seconds
     * @return client configuration
     * @deprecated use {@link #setReadEntryTimeout(int)} or {@link #setAddEntryTimeout(int)} instead
     */
    @Deprecated
    public ClientConfiguration setReadTimeout(int timeout) {
<span class="nc" id="L598">        setProperty(READ_TIMEOUT, Integer.toString(timeout));</span>
<span class="nc" id="L599">        return this;</span>
    }

    /**
     * Get the timeout for add request. This is the number of seconds we wait without hearing
     * a response for add request from a bookie before we consider it failed.
     *
     * The default value is 5 second for backwards compatibility.
     *
     * @return add entry timeout.
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    public int getAddEntryTimeout() {
<span class="fc" id="L612">        return getInt(ADD_ENTRY_TIMEOUT_SEC, getReadTimeout());</span>
    }

    /**
     * Set timeout for add entry request.
     * @see #getAddEntryTimeout()
     *
     * @param timeout
     *          The new add entry timeout in seconds.
     * @return client configuration.
     */
    public ClientConfiguration setAddEntryTimeout(int timeout) {
<span class="nc" id="L624">        setProperty(ADD_ENTRY_TIMEOUT_SEC, timeout);</span>
<span class="nc" id="L625">        return this;</span>
    }

    /**
     * Get the timeout for top-level add request. That is, the amount of time we should spend
     * waiting for ack quorum.
     *
     * @return add entry ack quorum timeout.
     */
    public int getAddEntryQuorumTimeout() {
<span class="fc" id="L635">        return getInt(ADD_ENTRY_QUORUM_TIMEOUT_SEC, -1);</span>
    }

    /**
     * Set timeout for top-level add entry request.
     * @see #getAddEntryQuorumTimeout()
     *
     * @param timeout
     *          The new add entry ack quorum timeout in seconds.
     * @return client configuration.
     */
    public ClientConfiguration setAddEntryQuorumTimeout(int timeout) {
<span class="nc" id="L647">        setProperty(ADD_ENTRY_QUORUM_TIMEOUT_SEC, timeout);</span>
<span class="nc" id="L648">        return this;</span>
    }

    /**
     * Get the timeout for read entry. This is the number of seconds we wait without hearing
     * a response for read entry request from a bookie before we consider it failed. By default,
     * we use socket timeout specified at {@link #getReadTimeout()}.
     *
     * @return read entry timeout.
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    public int getReadEntryTimeout() {
<span class="fc" id="L660">        return getInt(READ_ENTRY_TIMEOUT_SEC, getReadTimeout());</span>
    }

    /**
     * Set the timeout for read entry request.
     * @see #getReadEntryTimeout()
     *
     * @param timeout
     *          The new read entry timeout in seconds.
     * @return client configuration.
     */
    public ClientConfiguration setReadEntryTimeout(int timeout) {
<span class="nc" id="L672">        setProperty(READ_ENTRY_TIMEOUT_SEC, timeout);</span>
<span class="nc" id="L673">        return this;</span>
    }

    /**
     * Get the interval between successive executions of the PerChannelBookieClient's
     * TimeoutTask. This value is in milliseconds. Every X milliseconds, the timeout task
     * will be executed and it will error out entries that have timed out.
     *
     * We do it more aggressive to not accumulate pending requests due to slow responses.
     * @return the interval at which request timeouts will be checked
     */
    @Deprecated
    public long getTimeoutTaskIntervalMillis() {
<span class="nc" id="L686">        return getLong(TIMEOUT_TASK_INTERVAL_MILLIS,</span>
<span class="nc" id="L687">                TimeUnit.SECONDS.toMillis(Math.min(getAddEntryTimeout(), getReadEntryTimeout())) / 2);</span>
    }

    @Deprecated
    public ClientConfiguration setTimeoutTaskIntervalMillis(long timeoutMillis) {
<span class="nc" id="L692">        setProperty(TIMEOUT_TASK_INTERVAL_MILLIS, Long.toString(timeoutMillis));</span>
<span class="nc" id="L693">        return this;</span>
    }

    /**
     * Get the configured interval between  explicit LACs to bookies.
     * Generally LACs are piggy-backed on writes, and user can configure
     * the interval between these protocol messages. A value of '0' disables
     * sending any explicit LACs.
     *
     * @return interval between explicit LACs
     */
    public int getExplictLacInterval() {
<span class="fc" id="L705">        return getInt(EXPLICIT_LAC_INTERVAL, 0);</span>
    }

    /**
     * Set the interval to check the need for sending an explicit LAC.
     * @param interval
     *        Number of milli seconds between checking the need for sending an explict LAC.
     * @return Client configuration.
     */
    public ClientConfiguration setExplictLacInterval(int interval) {
<span class="nc" id="L715">        setProperty(EXPLICIT_LAC_INTERVAL, interval);</span>
<span class="nc" id="L716">        return this;</span>
    }

    /**
     * Get the tick duration in milliseconds that used for the
     * {@link org.jboss.netty.util.HashedWheelTimer} that used by PCBC to timeout
     * requests.
     *
     * @see org.jboss.netty.util.HashedWheelTimer
     *
     * @return tick duration in milliseconds
     */
    public long getPCBCTimeoutTimerTickDurationMs() {
<span class="fc" id="L729">        return getLong(PCBC_TIMEOUT_TIMER_TICK_DURATION_MS, 100);</span>
    }

    /**
     * Set the tick duration in milliseconds that used for
     * {@link org.jboss.netty.util.HashedWheelTimer} that used by PCBC to timeout
     * requests. Be aware of {@link org.jboss.netty.util.HashedWheelTimer} if you
     * are going to modify this setting.
     *
     * @see #getPCBCTimeoutTimerTickDurationMs()
     *
     * @param tickDuration
     *          tick duration in milliseconds.
     * @return client configuration.
     */
    public ClientConfiguration setPCBCTimeoutTimerTickDurationMs(long tickDuration) {
<span class="nc" id="L745">        setProperty(PCBC_TIMEOUT_TIMER_TICK_DURATION_MS, tickDuration);</span>
<span class="nc" id="L746">        return this;</span>
    }

    /**
     * Get number of ticks that used for
     * {@link org.jboss.netty.util.HashedWheelTimer} that used by PCBC to timeout
     * requests.
     *
     * @see org.jboss.netty.util.HashedWheelTimer
     *
     * @return number of ticks that used for timeout timer.
     */
    public int getPCBCTimeoutTimerNumTicks() {
<span class="fc" id="L759">        return getInt(PCBC_TIMEOUT_TIMER_NUM_TICKS, 1024);</span>
    }

    /**
     * Set number of ticks that used for
     * {@link org.jboss.netty.util.HashedWheelTimer} that used by PCBC to timeout request.
     * Be aware of {@link org.jboss.netty.util.HashedWheelTimer} if you are going to modify
     * this setting.
     *
     * @see #getPCBCTimeoutTimerNumTicks()
     *
     * @param numTicks
     *          number of ticks that used for timeout timer.
     * @return client configuration.
     */
    public ClientConfiguration setPCBCTimeoutTimerNumTicks(int numTicks) {
<span class="nc" id="L775">        setProperty(PCBC_TIMEOUT_TIMER_NUM_TICKS, numTicks);</span>
<span class="nc" id="L776">        return this;</span>
    }

    /**
     * Get the number of worker threads. This is the number of
     * worker threads used by bookkeeper client to submit operations.
     *
     * @return the number of worker threads
     */
    public int getNumWorkerThreads() {
<span class="fc" id="L786">        return getInt(NUM_WORKER_THREADS, Runtime.getRuntime().availableProcessors());</span>
    }

    /**
     * Set the number of worker threads.
     *
     * &lt;p&gt;
     * NOTE: setting the number of worker threads after BookKeeper object is constructed
     * will not take any effect on the number of threads in the pool.
     * &lt;/p&gt;
     *
     * @see #getNumWorkerThreads()
     * @param numThreads number of worker threads used for bookkeeper
     * @return client configuration
     */
    public ClientConfiguration setNumWorkerThreads(int numThreads) {
<span class="nc" id="L802">        setProperty(NUM_WORKER_THREADS, numThreads);</span>
<span class="nc" id="L803">        return this;</span>
    }

    /**
     * Get the period of time after which a speculative entry read should be triggered.
     * A speculative entry read is sent to the next replica bookie before
     * an error or response has been received for the previous entry read request.
     *
     * A speculative entry read is only sent if we have not heard from the current
     * replica bookie during the entire read operation which may comprise of many entries.
     *
     * Speculative reads allow the client to avoid having to wait for the connect timeout
     * in the case that a bookie has failed. It induces higher load on the network and on
     * bookies. This should be taken into account before changing this configuration value.
     *
     * @see org.apache.bookkeeper.client.LedgerHandle#asyncReadEntries
     * @return the speculative read timeout in milliseconds. Default 2000.
     */
    public int getSpeculativeReadTimeout() {
<span class="fc" id="L822">        return getInt(SPECULATIVE_READ_TIMEOUT, 2000);</span>
    }

    /**
     * Set the speculative read timeout. A lower timeout will reduce read latency in the
     * case of a failed bookie, while increasing the load on bookies and the network.
     *
     * The default is 2000 milliseconds. A value of 0 will disable speculative reads
     * completely.
     *
     * @see #getSpeculativeReadTimeout()
     * @param timeout the timeout value, in milliseconds
     * @return client configuration
     */
    public ClientConfiguration setSpeculativeReadTimeout(int timeout) {
<span class="nc" id="L837">        setProperty(SPECULATIVE_READ_TIMEOUT, timeout);</span>
<span class="nc" id="L838">        return this;</span>
    }

    /**
     * Get the first speculative read timeout.
     *
     * @return first speculative read timeout.
     */
    public int getFirstSpeculativeReadTimeout() {
<span class="fc" id="L847">        return getInt(FIRST_SPECULATIVE_READ_TIMEOUT, getSpeculativeReadTimeout());</span>
    }

    /**
     * Set the first speculative read timeout.
     *
     * @param timeout
     *          first speculative read timeout.
     * @return client configuration.
     */
    public ClientConfiguration setFirstSpeculativeReadTimeout(int timeout) {
<span class="nc" id="L858">        setProperty(FIRST_SPECULATIVE_READ_TIMEOUT, timeout);</span>
<span class="nc" id="L859">        return this;</span>
    }

    /**
     * Multipler to use when determining time between successive speculative read requests
     *
     * @return speculative read timeout backoff multiplier.
     */
    public float getSpeculativeReadTimeoutBackoffMultiplier() {
<span class="fc" id="L868">        return getFloat(SPECULATIVE_READ_TIMEOUT_BACKOFF_MULTIPLIER, 2.0f);</span>
    }

    /**
     * Set the multipler to use when determining time between successive speculative read requests
     *
     * @param speculativeReadTimeoutBackoffMultiplier
     *          multipler to use when determining time between successive speculative read requests.
     * @return client configuration.
     */
    public ClientConfiguration setSpeculativeReadTimeoutBackoffMultiplier(float speculativeReadTimeoutBackoffMultiplier) {
<span class="nc" id="L879">        setProperty(SPECULATIVE_READ_TIMEOUT_BACKOFF_MULTIPLIER, speculativeReadTimeoutBackoffMultiplier);</span>
<span class="nc" id="L880">        return this;</span>
    }

    /**
     * Multipler to use when determining time between successive speculative read LAC requests
     *
     * @return speculative read LAC timeout backoff multiplier.
     */
    public float getSpeculativeReadLACTimeoutBackoffMultiplier() {
<span class="fc" id="L889">        return getFloat(SPECULATIVE_READ_LAC_TIMEOUT_BACKOFF_MULTIPLIER, 2.0f);</span>
    }

    /**
     * Set the multipler to use when determining time between successive speculative read LAC requests
     *
     * @param speculativeReadLACTimeoutBackoffMultiplier
     *          multipler to use when determining time between successive speculative read LAC requests.
     * @return client configuration.
     */
    public ClientConfiguration setSpeculativeReadLACTimeoutBackoffMultiplier(float speculativeReadLACTimeoutBackoffMultiplier) {
<span class="nc" id="L900">        setProperty(SPECULATIVE_READ_LAC_TIMEOUT_BACKOFF_MULTIPLIER, speculativeReadLACTimeoutBackoffMultiplier);</span>
<span class="nc" id="L901">        return this;</span>
    }

    /**
     * Get the max speculative read timeout.
     *
     * @return max speculative read timeout.
     */
    public int getMaxSpeculativeReadTimeout() {
<span class="fc" id="L910">        return getInt(MAX_SPECULATIVE_READ_TIMEOUT, getSpeculativeReadTimeout());</span>
    }

    /**
     * Set the max speculative read timeout.
     *
     * @param timeout
     *          max speculative read timeout.
     * @return client configuration.
     */
    public ClientConfiguration setMaxSpeculativeReadTimeout(int timeout) {
<span class="nc" id="L921">        setProperty(MAX_SPECULATIVE_READ_TIMEOUT, timeout);</span>
<span class="nc" id="L922">        return this;</span>
    }

    /**
     * Get the period of time after which the first speculative read last add confirmed and entry
     * should be triggered.
     * A speculative entry request is sent to the next replica bookie before
     * an error or response has been received for the previous entry read request.
     *
     * A speculative entry read is only sent if we have not heard from the current
     * replica bookie during the entire read operation which may comprise of many entries.
     *
     * Speculative requests allow the client to avoid having to wait for the connect timeout
     * in the case that a bookie has failed. It induces higher load on the network and on
     * bookies. This should be taken into account before changing this configuration value.
     *
     * @return the speculative request timeout in milliseconds. Default 1500.
     */
    public int getFirstSpeculativeReadLACTimeout() {
<span class="fc" id="L941">        return getInt(FIRST_SPECULATIVE_READ_LAC_TIMEOUT, 1500);</span>
    }


    /**
     * Get the maximum interval between successive speculative read last add confirmed and entry
     * requests.
     *
     * @return the max speculative request timeout in milliseconds. Default 5000.
     */
    public int getMaxSpeculativeReadLACTimeout() {
<span class="fc" id="L952">        return getInt(MAX_SPECULATIVE_READ_LAC_TIMEOUT, 5000);</span>
    }

    /**
     * Set the period of time after which the first speculative read last add confirmed and entry
     * should be triggered.
     * A lower timeout will reduce read latency in the case of a failed bookie,
     * while increasing the load on bookies and the network.
     *
     * The default is 1500 milliseconds. A value of 0 will disable speculative reads
     * completely.
     *
     * @see #getSpeculativeReadTimeout()
     * @param timeout the timeout value, in milliseconds
     * @return client configuration
     */
    public ClientConfiguration setFirstSpeculativeReadLACTimeout(int timeout) {
<span class="nc" id="L969">        setProperty(FIRST_SPECULATIVE_READ_LAC_TIMEOUT, timeout);</span>
<span class="nc" id="L970">        return this;</span>
    }

    /**
     * Set the maximum interval between successive speculative read last add confirmed and entry
     * requests.
     *
     * @param timeout the timeout value, in milliseconds
     * @return client configuration
     */
    public ClientConfiguration setMaxSpeculativeReadLACTimeout(int timeout) {
<span class="nc" id="L981">        setProperty(MAX_SPECULATIVE_READ_LAC_TIMEOUT, timeout);</span>
<span class="nc" id="L982">        return this;</span>
    }

    /**
     * Whether to enable parallel reading in recovery read.
     *
     * @return true if enable parallel reading in recovery read. otherwise, return false.
     */
    public boolean getEnableParallelRecoveryRead() {
<span class="fc" id="L991">        return getBoolean(ENABLE_PARALLEL_RECOVERY_READ, false);</span>
    }

    /**
     * Enable/Disable parallel reading in recovery read.
     *
     * @param enabled
     *          flag to enable/disable parallel reading in recovery read.
     * @return client configuration.
     */
    public ClientConfiguration setEnableParallelRecoveryRead(boolean enabled) {
<span class="nc" id="L1002">        setProperty(ENABLE_PARALLEL_RECOVERY_READ, enabled);</span>
<span class="nc" id="L1003">        return this;</span>
    }

    /**
     * Get Recovery Read Batch Size.
     *
     * @return recovery read batch size.
     */
    public int getRecoveryReadBatchSize() {
<span class="fc" id="L1012">        return getInt(RECOVERY_READ_BATCH_SIZE, 1);</span>
    }

    /**
     * Set Recovery Read Batch Size.
     *
     * @param batchSize
     *          recovery read batch size.
     * @return client configuration.
     */
    public ClientConfiguration setRecoveryReadBatchSize(int batchSize) {
<span class="nc" id="L1023">        setProperty(RECOVERY_READ_BATCH_SIZE, batchSize);</span>
<span class="nc" id="L1024">        return this;</span>
    }

    /**
     * If reorder read sequence enabled or not.
     *
     * @return true if reorder read sequence is enabled, otherwise false.
     */
    public boolean isReorderReadSequenceEnabled() {
<span class="fc" id="L1033">        return getBoolean(REORDER_READ_SEQUENCE_ENABLED, false);</span>
    }

    /**
     * Enable/disable reordering read sequence on reading entries.
     *
     * &lt;p&gt;If this flag is enabled, the client will use
     * {@link EnsemblePlacementPolicy#reorderReadSequence(ArrayList, List, Map)}
     * to figure out a better read sequence to attempt reads from replicas and use
     * {@link EnsemblePlacementPolicy#reorderReadLACSequence(ArrayList, List, Map)}
     * to figure out a better read sequence to attempt long poll reads from replicas.
     *
     * &lt;p&gt;The order of read sequence is determined by the placement policy implementations.
     *
     * @param enabled the flag to enable/disable reorder read sequence.
     * @return client configuration instance.
     */
    public ClientConfiguration setReorderReadSequenceEnabled(boolean enabled) {
<span class="nc" id="L1051">        setProperty(REORDER_READ_SEQUENCE_ENABLED, enabled);</span>
<span class="nc" id="L1052">        return this;</span>
    }

    /**
     * Get Ensemble Placement Policy Class.
     *
     * @return ensemble placement policy class.
     */
    public Class&lt;? extends EnsemblePlacementPolicy&gt; getEnsemblePlacementPolicy()
            throws ConfigurationException {
<span class="fc" id="L1062">        return ReflectionUtils.getClass(this, ENSEMBLE_PLACEMENT_POLICY,</span>
                RackawareEnsemblePlacementPolicy.class,
                EnsemblePlacementPolicy.class,
                                        defaultLoader);
    }

    /**
     * Set Ensemble Placement Policy Class.
     *
     * @param policyClass
     *          Ensemble Placement Policy Class.
     */
    public ClientConfiguration setEnsemblePlacementPolicy(Class&lt;? extends EnsemblePlacementPolicy&gt; policyClass) {
<span class="nc" id="L1075">        setProperty(ENSEMBLE_PLACEMENT_POLICY, policyClass.getName());</span>
<span class="nc" id="L1076">        return this;</span>
    }

    /**
     * Get the network topology stabilize period in seconds. if it is zero, this feature is turned off.
     *
     * @return network topology stabilize period in seconds.
     */
    public int getNetworkTopologyStabilizePeriodSeconds() {
<span class="fc" id="L1085">        return getInt(NETWORK_TOPOLOGY_STABILIZE_PERIOD_SECONDS, 0);</span>
    }

    /**
     * Set the network topology stabilize period in seconds.
     *
     * @see #getNetworkTopologyStabilizePeriodSeconds()
     * @param seconds stabilize period in seconds
     * @return client configuration.
     */
    public ClientConfiguration setNetworkTopologyStabilizePeriodSeconds(int seconds) {
<span class="nc" id="L1096">        setProperty(NETWORK_TOPOLOGY_STABILIZE_PERIOD_SECONDS, seconds);</span>
<span class="nc" id="L1097">        return this;</span>
    }

    /**
     * Whether to enable recording task execution stats.
     *
     * @return flag to enable/disable recording task execution stats.
     */
    public boolean getEnableTaskExecutionStats() {
<span class="fc" id="L1106">        return getBoolean(ENABLE_TASK_EXECUTION_STATS, false);</span>
    }

    /**
     * Enable/Disable recording task execution stats.
     *
     * @param enabled
     *          flag to enable/disable recording task execution stats.
     * @return client configuration.
     */
    public ClientConfiguration setEnableTaskExecutionStats(boolean enabled) {
<span class="nc" id="L1117">        setProperty(ENABLE_TASK_EXECUTION_STATS, enabled);</span>
<span class="nc" id="L1118">        return this;</span>
    }

    /**
     * Get task execution duration which triggers a warning.
     *
     * @return time in microseconds which triggers a warning.
     */
    public long getTaskExecutionWarnTimeMicros() {
<span class="fc" id="L1127">        return getLong(TASK_EXECUTION_WARN_TIME_MICROS, TimeUnit.SECONDS.toMicros(1));</span>
    }

    /**
     * Set task execution duration which triggers a warning.
     *
     * @param warnTime
     *          time in microseconds which triggers a warning.
     * @return client configuration.
     */
    public ClientConfiguration setTaskExecutionWarnTimeMicros(long warnTime) {
<span class="nc" id="L1138">        setProperty(TASK_EXECUTION_WARN_TIME_MICROS, warnTime);</span>
<span class="nc" id="L1139">        return this;</span>
    }

    /**
     * Check if bookie health check is enabled.
     *
     * @return
     */
    public boolean isBookieHealthCheckEnabled() {
<span class="fc" id="L1148">        return getBoolean(BOOKIE_HEALTH_CHECK_ENABLED, false);</span>
    }

    /**
     * Enables the bookie health check.
     *
     * &lt;p&gt;
     * If the number of read/write errors for a bookie exceeds {@link #getBookieErrorThresholdPerInterval()} per
     * interval, that bookie is quarantined for {@link #getBookieQuarantineTimeSeconds()} seconds. During this
     * quarantined period, the client will try not to use this bookie when creating new ensembles.
     * &lt;/p&gt;
     *
     * By default, the bookie health check is &lt;b&gt;disabled&lt;/b&gt;.
     *
     * @return client configuration
     */
    public ClientConfiguration enableBookieHealthCheck() {
<span class="nc" id="L1165">        setProperty(BOOKIE_HEALTH_CHECK_ENABLED, true);</span>
<span class="nc" id="L1166">        return this;</span>
    }

    /**
     * Get the bookie health check interval in seconds.
     *
     * @return
     */
    public int getBookieHealthCheckIntervalSeconds() {
<span class="nc" id="L1175">        return getInt(BOOKIE_HEALTH_CHECK_INTERVAL_SECONDS, 60);</span>
    }

    /**
     * Set the bookie health check interval. Default is 60 seconds.
     *
     * &lt;p&gt;
     * Note: Please {@link #enableBookieHealthCheck()} to use this configuration.
     * &lt;/p&gt;
     *
     * @param interval
     * @param unit
     * @return client configuration
     */
    public ClientConfiguration setBookieHealthCheckInterval(int interval, TimeUnit unit) {
<span class="nc" id="L1190">        setProperty(BOOKIE_HEALTH_CHECK_INTERVAL_SECONDS, unit.toSeconds(interval));</span>
<span class="nc" id="L1191">        return this;</span>
    }

    /**
     * Get the error threshold for a bookie to be quarantined.
     *
     * @return
     */
    public long getBookieErrorThresholdPerInterval() {
<span class="fc" id="L1200">        return getLong(BOOKIE_ERROR_THRESHOLD_PER_INTERVAL, 100);</span>
    }

    /**
     * Set the error threshold per interval ({@link #getBookieHealthCheckIntervalSeconds()}) for a bookie before it is
     * quarantined. Default is 100 errors per minute.
     *
     * &lt;p&gt;
     * Note: Please {@link #enableBookieHealthCheck()} to use this configuration.
     * &lt;/p&gt;
     *
     * @param threshold
     * @param unit
     * @return client configuration
     */
    public ClientConfiguration setBookieErrorThresholdPerInterval(long thresholdPerInterval) {
<span class="nc" id="L1216">        setProperty(BOOKIE_ERROR_THRESHOLD_PER_INTERVAL, thresholdPerInterval);</span>
<span class="nc" id="L1217">        return this;</span>
    }

    /**
     * Get the time for which a bookie will be quarantined.
     *
     * @return
     */
    public int getBookieQuarantineTimeSeconds() {
<span class="fc" id="L1226">        return getInt(BOOKIE_QUARANTINE_TIME_SECONDS, 1800);</span>
    }

    /**
     * Set the time for which a bookie will be quarantined. Default is 30 minutes.
     *
     * &lt;p&gt;
     * Note: Please {@link #enableBookieHealthCheck()} to use this configuration.
     * &lt;/p&gt;
     *
     * @param quarantineTime
     * @param unit
     * @return client configuration
     */
    public ClientConfiguration setBookieQuarantineTime(int quarantineTime, TimeUnit unit) {
<span class="nc" id="L1241">        setProperty(BOOKIE_QUARANTINE_TIME_SECONDS, unit.toSeconds(quarantineTime));</span>
<span class="nc" id="L1242">        return this;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ClientConfiguration setNettyMaxFrameSizeBytes(int maxSize) {
<span class="nc" id="L1250">        super.setNettyMaxFrameSizeBytes(maxSize);</span>
<span class="nc" id="L1251">        return this;</span>
    }
 
    /**
     * Get the time interval between successive calls for bookie get info. Default is 24 hours.
     *
     * @return
     */
    public int getGetBookieInfoIntervalSeconds() {
<span class="nc" id="L1260">        return getInt(GET_BOOKIE_INFO_INTERVAL_SECONDS, 24*60*60);</span>
    }

    /**
     * Get the time interval between retries on unsuccessful bookie info request.  Default is
     * 60s.
     *
     * @return
     */
    public int getGetBookieInfoRetryIntervalSeconds() {
<span class="nc" id="L1270">        return getInt(GET_BOOKIE_INFO_RETRY_INTERVAL_SECONDS, 60);</span>
    }

    /**
     * Return whether disk weight based placement policy is enabled
     * @return
     */
    public boolean getDiskWeightBasedPlacementEnabled() {
<span class="fc" id="L1278">        return getBoolean(DISK_WEIGHT_BASED_PLACEMENT_ENABLED, false);</span>
    }

    /**
     * Returns the max multiple to use for nodes with very high weight
     * @return max multiple
     */
    public int getBookieMaxWeightMultipleForWeightBasedPlacement() {
<span class="fc" id="L1286">        return getInt(BOOKIE_MAX_MULTIPLE_FOR_WEIGHTED_PLACEMENT, 3);</span>
    }

    /**
     * Return the timeout value for getBookieInfo request
     * @return
     */
    public int getBookieInfoTimeout() {
<span class="fc" id="L1294">        return getInteger(GET_BOOKIE_INFO_TIMEOUT_SECS, 5);</span>
    }

    /**
     * Return the timeout value for startTLS request
     * @return
     */
    public int getStartTLSTimeout() {
<span class="fc" id="L1302">        return getInteger(START_TLS_TIMEOUT_SECS, 10);</span>
    }

    /**
     * Set whether or not disk weight based placement is enabled.
     *
     * @param isEnabled - boolean indicating enabled or not
     * @return client configuration
     */
    public ClientConfiguration setDiskWeightBasedPlacementEnabled(boolean isEnabled) {
<span class="nc" id="L1312">        setProperty(DISK_WEIGHT_BASED_PLACEMENT_ENABLED, isEnabled);</span>
<span class="nc" id="L1313">        return this;</span>
    }

    /**
     * Set the time interval between successive polls for bookie get info.
     *
     * @param pollInterval
     * @param unit
     * @return client configuration
     */
    public ClientConfiguration setGetBookieInfoIntervalSeconds(int pollInterval, TimeUnit unit) {
<span class="nc" id="L1324">        setProperty(GET_BOOKIE_INFO_INTERVAL_SECONDS, unit.toSeconds(pollInterval));</span>
<span class="nc" id="L1325">        return this;</span>
    }

    /**
     * Set the time interval between retries on unsuccessful GetInfo requests
     *
     *
     * @param interval
     * @param unit
     * @return client configuration
     */
    public ClientConfiguration setGetBookieInfoRetryIntervalSeconds(int interval, TimeUnit unit) {
<span class="nc" id="L1337">        setProperty(GET_BOOKIE_INFO_RETRY_INTERVAL_SECONDS, unit.toSeconds(interval));</span>
<span class="nc" id="L1338">        return this;</span>
    }

    /**
     * Set the max multiple to use for nodes with very high weight
     * @param multiple
     * @return client configuration
     */
    public ClientConfiguration setBookieMaxWeightMultipleForWeightBasedPlacement(int multiple) {
<span class="nc" id="L1347">        setProperty(BOOKIE_MAX_MULTIPLE_FOR_WEIGHTED_PLACEMENT, multiple);</span>
<span class="nc" id="L1348">        return this;</span>
    }

    /**
     * Set the timeout value in secs for the GET_BOOKIE_INFO request
     * @param timeout
     * @return client configuration
     */
    public ClientConfiguration setGetBookieInfoTimeout(int timeoutSecs) {
<span class="nc" id="L1357">        setProperty(GET_BOOKIE_INFO_TIMEOUT_SECS, timeoutSecs);</span>
<span class="nc" id="L1358">        return this;</span>
    }

    /**
     * Set the timeout value in secs for the START_TLS request
     * @param timeout
     * @return client configuration
     */
    public ClientConfiguration setStartTLSTimeout(int timeoutSecs) {
<span class="nc" id="L1367">        setProperty(START_TLS_TIMEOUT_SECS, timeoutSecs);</span>
<span class="nc" id="L1368">        return this;</span>
    }

    /**
     * Set the client role
     *
     * @param role defines how the client will act
     * @return client configuration
     */
    public ClientConfiguration setClientRole(String role) {
<span class="nc bnc" id="L1378" title="All 2 branches missed.">        if (role == null) {</span>
<span class="nc" id="L1379">            throw new NullPointerException();</span>
        }
<span class="nc bnc" id="L1381" title="All 2 branches missed.">        switch (role) {</span>
            case CLIENT_ROLE_STANDARD:
            case CLIENT_ROLE_SYSTEM:
<span class="nc" id="L1384">                break;</span>
            default:
<span class="nc" id="L1386">                throw new IllegalArgumentException(&quot;invalid role &quot;+role);</span>
        }
<span class="nc" id="L1388">        setProperty(CLIENT_ROLE, role);</span>
<span class="nc" id="L1389">        return this;</span>
    }

    /**
     * Get the role of the client
     *
     * @return the type of client
     */
    public String getClientRole() {
<span class="nc" id="L1398">        return getString(CLIENT_ROLE, CLIENT_ROLE_STANDARD);</span>
    }

    /**
     * Get the keystore type for client. Default is JKS.
     * 
     * @return
     */
    public String getTLSKeyStoreType() {
<span class="nc" id="L1407">        return getString(TLS_KEYSTORE_TYPE, &quot;JKS&quot;);</span>
    }


    /**
     * Set the keystore type for client.
     * 
     * @return
     */
    public ClientConfiguration setTLSKeyStoreType(String arg) {
<span class="nc" id="L1417">        setProperty(TLS_KEYSTORE_TYPE, arg);</span>
<span class="nc" id="L1418">        return this;</span>
    }

    /**
     * Get the keystore path for the client.
     * 
     * @return
     */
    public String getTLSKeyStore() {
<span class="nc" id="L1427">        return getString(TLS_KEYSTORE, null);</span>
    }

    /**
     * Set the keystore path for the client.
     * 
     * @return
     */
    public ClientConfiguration setTLSKeyStore(String arg) {
<span class="nc" id="L1436">        setProperty(TLS_KEYSTORE, arg);</span>
<span class="nc" id="L1437">        return this;</span>
    }

    /**
     * Get the path to file containing keystore password, if the client keystore is password protected. Default is null.
     * 
     * @return
     */
    public String getTLSKeyStorePasswordPath() {
<span class="nc" id="L1446">        return getString(TLS_KEYSTORE_PASSWORD_PATH, null);</span>
    }

    /**
     * Set the path to file containing keystore password, if the client keystore is password protected.
     * 
     * @return
     */
    public ClientConfiguration setTLSKeyStorePasswordPath(String arg) {
<span class="nc" id="L1455">        setProperty(TLS_KEYSTORE_PASSWORD_PATH, arg);</span>
<span class="nc" id="L1456">        return this;</span>
    }

    /**
     * Get the truststore type for client. Default is JKS.
     * 
     * @return
     */
    public String getTLSTrustStoreType() {
<span class="nc" id="L1465">        return getString(TLS_TRUSTSTORE_TYPE, &quot;JKS&quot;);</span>
    }

    /**
     * Set the truststore type for client.
     * 
     * @return
     */
    public ClientConfiguration setTLSTrustStoreType(String arg) {
<span class="nc" id="L1474">        setProperty(TLS_TRUSTSTORE_TYPE, arg);</span>
<span class="nc" id="L1475">        return this;</span>
    }

    /**
     * Get the truststore path for the client.
     * 
     * @return
     */
    public String getTLSTrustStore() {
<span class="nc" id="L1484">        return getString(TLS_TRUSTSTORE, null);</span>
    }

    /**
     * Set the truststore path for the client.
     * 
     * @return
     */
    public ClientConfiguration setTLSTrustStore(String arg) {
<span class="nc" id="L1493">        setProperty(TLS_TRUSTSTORE, arg);</span>
<span class="nc" id="L1494">        return this;</span>
    }

    /**
     * Get the path to file containing truststore password, if the client truststore is password protected. Default is
     * null.
     * 
     * @return
     */
    public String getTLSTrustStorePasswordPath() {
<span class="nc" id="L1504">        return getString(TLS_TRUSTSTORE_PASSWORD_PATH, null);</span>
    }

    /**
     * Set the path to file containing truststore password, if the client truststore is password protected.
     * 
     * @return
     */
    public ClientConfiguration setTLSTrustStorePasswordPath(String arg) {
<span class="nc" id="L1513">        setProperty(TLS_TRUSTSTORE_PASSWORD_PATH, arg);</span>
<span class="nc" id="L1514">        return this;</span>
    }

    /**
     * Whether to delay ensemble change or not?
     *
     * @return true if to delay ensemble change, otherwise false.
     */
    public boolean getDelayEnsembleChange() {
<span class="fc" id="L1523">        return getBoolean(DELAY_ENSEMBLE_CHANGE, false);</span>
    }

    /**
     * Enable/Disable delaying ensemble change.
     * &lt;p&gt;
     * If set to true, ensemble change only happens when it can't meet
     * ack quorum requirement. If set to false, ensemble change happens
     * immediately when it received a failed write.
     * &lt;/p&gt;
     *
     * @param enabled
     *          flag to enable/disable delaying ensemble change.
     * @return client configuration.
     */
    public ClientConfiguration setDelayEnsembleChange(boolean enabled) {
<span class="nc" id="L1539">        setProperty(DELAY_ENSEMBLE_CHANGE, enabled);</span>
<span class="nc" id="L1540">        return this;</span>
    }

    /**
     * Whether to enable bookie failure tracking
     *
     * @return flag to enable/disable bookie failure tracking
     */
    public boolean getEnableBookieFailureTracking() {
<span class="nc" id="L1549">        return getBoolean(ENABLE_BOOKIE_FAILURE_TRACKING, true);</span>
    }

    /**
     * Enable/Disable bookie failure tracking.
     *
     * @param enabled
     *          flag to enable/disable bookie failure tracking
     * @return client configuration.
     */
    public ClientConfiguration setEnableBookieFailureTracking(boolean enabled) {
<span class="nc" id="L1560">        setProperty(ENABLE_BOOKIE_FAILURE_TRACKING, enabled);</span>
<span class="nc" id="L1561">        return this;</span>
    }

    /**
     * Get the bookie failure tracking expiration timeout.
     *
     * @return bookie failure tracking expiration timeout.
     */
    public int getBookieFailureHistoryExpirationMSec() {
<span class="fc" id="L1570">        return getInt(BOOKIE_FAILURE_HISTORY_EXPIRATION_MS, 60000);</span>
    }

    /**
     * Set the bookie failure tracking expiration timeout.
     *
     * @param timeout
     *          bookie failure tracking expiration timeout.
     * @return client configuration.
     */
    public ClientConfiguration setBookieFailureHistoryExpirationMSec(int expirationMSec) {
<span class="nc" id="L1581">        setProperty(BOOKIE_FAILURE_HISTORY_EXPIRATION_MS, expirationMSec);</span>
<span class="nc" id="L1582">        return this;</span>
    }

    /**
     * Get the name of the dynamic feature that disables ensemble change
     *
     * @return name of the dynamic feature that disables ensemble change
     */
    public String getDisableEnsembleChangeFeatureName() {
<span class="fc" id="L1591">        return getString(DISABLE_ENSEMBLE_CHANGE_FEATURE_NAME, FEATURE_DISABLE_ENSEMBLE_CHANGE);</span>
    }

    /**
     * Set the name of the dynamic feature that disables ensemble change
     *
     * @param disableEnsembleChangeFeatureName
     *          name of the dynamic feature that disables ensemble change
     * @return client configuration.
     */
    public ClientConfiguration setDisableEnsembleChangeFeatureName(String disableEnsembleChangeFeatureName) {
<span class="nc" id="L1602">        setProperty(DISABLE_ENSEMBLE_CHANGE_FEATURE_NAME, disableEnsembleChangeFeatureName);</span>
<span class="nc" id="L1603">        return this;</span>
    }


    /**
     * Option to use Netty Pooled ByteBufs
     *
     * @return the value of the option
     */
    public boolean isNettyUsePooledBuffers() {
<span class="fc" id="L1613">        return getBoolean(NETTY_USE_POOLED_BUFFERS, true);</span>
    }

    /**
     * Enable/Disable the usage of Pooled Netty buffers. While using v2 wire protocol the application will be
     * responsible for releasing ByteBufs returned by BookKeeper
     *
     * @param enabled
     *          if enabled BookKeeper will use default Pooled Netty Buffer allocator
     *
     * @see #setUseV2WireProtocol(boolean)
     * @see ByteBuf#release()
     * @see LedgerHandle#readEntries(long, long)
     */
    public ClientConfiguration setNettyUsePooledBuffers(boolean enabled) {
<span class="nc" id="L1628">        setProperty(NETTY_USE_POOLED_BUFFERS, enabled);</span>
<span class="nc" id="L1629">        return this;</span>
    }

    /**
     * Set registration manager class
     *
     * @param regClientClass
     *            ClientClass
     */
    public ClientConfiguration setRegistrationClientClass(
            Class&lt;? extends RegistrationClient&gt; regClientClass) {
<span class="nc" id="L1640">        setProperty(REGISTRATION_CLIENT_CLASS, regClientClass);</span>
<span class="nc" id="L1641">        return this;</span>
    }

    /**
     * Get Registration Client Class.
     *
     * @return registration manager class.
     */
    public Class&lt;? extends RegistrationClient&gt; getRegistrationClientClass()
            throws ConfigurationException {
<span class="fc" id="L1651">        return ReflectionUtils.getClass(this, REGISTRATION_CLIENT_CLASS,</span>
                ZKRegistrationClient.class, RegistrationClient.class,
                defaultLoader);
    }

    /**
     * Enable the client to use system time as the ledger creation time.
     *
     * &lt;p&gt;If this is enabled, the client will write a ctime field into the ledger metadata.
     * Otherwise, nothing will be written. The creation time of this ledger will be the ctime
     * of the metadata record in metadata store.
     *
     * @param enabled flag to enable/disable client using system time as the ledger creation time.
     */
    public ClientConfiguration setStoreSystemtimeAsLedgerCreationTime(boolean enabled) {
<span class="nc" id="L1666">        setProperty(STORE_SYSTEMTIME_AS_LEDGER_CREATION_TIME, enabled);</span>
<span class="nc" id="L1667">        return this;</span>
    }

    /**
     * Return the flag that indicates whether client is using system time as the ledger creation time when
     * creating ledgers.
     *
     * @return the flag that indicates whether client is using system time as the ledger creation time when
     *         creating ledgers.
     */
    public boolean getStoreSystemtimeAsLedgerCreationTime() {
<span class="fc" id="L1678">        return getBoolean(STORE_SYSTEMTIME_AS_LEDGER_CREATION_TIME, false);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>