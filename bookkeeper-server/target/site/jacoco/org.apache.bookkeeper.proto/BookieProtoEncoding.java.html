<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BookieProtoEncoding.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.proto</a> &gt; <span class="el_source">BookieProtoEncoding.java</span></div><h1>BookieProtoEncoding.java</h1><pre class="source lang-java linenums">/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.bookkeeper.proto;

import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.util.List;

import org.apache.bookkeeper.client.MacDigestManager;
import org.apache.bookkeeper.proto.BookieProtocol.PacketHeader;
import org.apache.bookkeeper.util.DoubleByteBuf;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.protobuf.CodedOutputStream;
import com.google.protobuf.ExtensionRegistry;
import com.google.protobuf.InvalidProtocolBufferException;
import com.google.protobuf.MessageLite;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufAllocator;
import io.netty.buffer.ByteBufInputStream;
import io.netty.buffer.ByteBufOutputStream;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandler.Sharable;
import io.netty.channel.ChannelHandlerContext;
import io.netty.handler.codec.MessageToMessageDecoder;
import io.netty.handler.codec.MessageToMessageEncoder;

<span class="nc" id="L48">public class BookieProtoEncoding {</span>
<span class="fc" id="L49">    private static final Logger LOG = LoggerFactory.getLogger(BookieProtoEncoding.class);</span>

    public static interface EnDecoder {
        /**
         * Encode a &lt;i&gt;object&lt;/i&gt; into channel buffer.
         *
         * @param object
         *          object.
         * @return encode buffer.
         * @throws Exception
         */
        public Object encode(Object object, ByteBufAllocator allocator) throws Exception;

        /**
         * Decode a &lt;i&gt;packet&lt;/i&gt; into an object.
         *
         * @param packet
         *          received packet.
         * @return parsed object.
         * @throws Exception
         */
        public Object decode(ByteBuf packet) throws Exception;

    }

    public static class RequestEnDeCoderPreV3 implements EnDecoder {
        final ExtensionRegistry extensionRegistry;

        //This empty master key is used when an empty password is provided which is the hash of an empty string
        private final static byte[] emptyPasswordMasterKey;
        static {
            try {
<span class="fc" id="L81">                emptyPasswordMasterKey = MacDigestManager.genDigest(&quot;ledger&quot;, new byte[0]);</span>
<span class="nc" id="L82">            } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L83">                throw new RuntimeException(e);</span>
<span class="fc" id="L84">            }</span>
<span class="fc" id="L85">        }</span>

<span class="fc" id="L87">        public RequestEnDeCoderPreV3(ExtensionRegistry extensionRegistry) {</span>
<span class="fc" id="L88">            this.extensionRegistry = extensionRegistry;</span>
<span class="fc" id="L89">        }</span>

        @Override
        public Object encode(Object msg, ByteBufAllocator allocator)
                throws Exception {
<span class="nc bnc" id="L94" title="All 2 branches missed.">            if (!(msg instanceof BookieProtocol.Request)) {</span>
<span class="nc" id="L95">                return msg;</span>
            }
<span class="nc" id="L97">            BookieProtocol.Request r = (BookieProtocol.Request)msg;</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">            if (r instanceof BookieProtocol.AddRequest) {</span>
<span class="nc" id="L99">                BookieProtocol.AddRequest ar = (BookieProtocol.AddRequest)r;</span>
<span class="nc" id="L100">                int totalHeaderSize = 4 // for the header</span>
                    + BookieProtocol.MASTER_KEY_LENGTH; // for the master key
<span class="nc" id="L102">                ByteBuf buf = allocator.buffer(totalHeaderSize);</span>
<span class="nc" id="L103">                buf.writeInt(PacketHeader.toInt(r.getProtocolVersion(), r.getOpCode(), r.getFlags()));</span>
<span class="nc" id="L104">                buf.writeBytes(r.getMasterKey(), 0, BookieProtocol.MASTER_KEY_LENGTH);</span>
<span class="nc" id="L105">                ByteBuf data = ar.getData();</span>
<span class="nc" id="L106">                ar.recycle();</span>
<span class="nc" id="L107">                return DoubleByteBuf.get(buf, data);</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">            } else if (r instanceof BookieProtocol.ReadRequest) {</span>
<span class="nc" id="L109">                int totalHeaderSize = 4 // for request type</span>
                    + 8 // for ledgerId
                    + 8; // for entryId
<span class="nc bnc" id="L112" title="All 2 branches missed.">                if (r.hasMasterKey()) {</span>
<span class="nc" id="L113">                    totalHeaderSize += BookieProtocol.MASTER_KEY_LENGTH;</span>
                }

<span class="nc" id="L116">                ByteBuf buf = allocator.buffer(totalHeaderSize);</span>
<span class="nc" id="L117">                buf.writeInt(PacketHeader.toInt(r.getProtocolVersion(), r.getOpCode(), r.getFlags()));</span>
<span class="nc" id="L118">                buf.writeLong(r.getLedgerId());</span>
<span class="nc" id="L119">                buf.writeLong(r.getEntryId());</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">                if (r.hasMasterKey()) {</span>
<span class="nc" id="L121">                    buf.writeBytes(r.getMasterKey(), 0, BookieProtocol.MASTER_KEY_LENGTH);</span>
                }

<span class="nc" id="L124">                return buf;</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">            } else if (r instanceof BookieProtocol.AuthRequest) {</span>
<span class="nc" id="L126">                BookkeeperProtocol.AuthMessage am = ((BookieProtocol.AuthRequest)r).getAuthMessage();</span>
<span class="nc" id="L127">                int totalHeaderSize = 4; // for request type</span>
<span class="nc" id="L128">                int totalSize = totalHeaderSize + am.getSerializedSize();</span>
<span class="nc" id="L129">                ByteBuf buf = allocator.buffer(totalSize);</span>
<span class="nc" id="L130">                buf.writeInt(PacketHeader.toInt(r.getProtocolVersion(), r.getOpCode(), r.getFlags()));</span>
<span class="nc" id="L131">                ByteBufOutputStream bufStream = new ByteBufOutputStream(buf);</span>
<span class="nc" id="L132">                am.writeTo(bufStream);</span>
<span class="nc" id="L133">                return buf;</span>
            } else {
<span class="nc" id="L135">                return msg;</span>
            }
        }

        @Override
        public Object decode(ByteBuf packet)
                throws Exception {
<span class="nc" id="L142">            int packetHeader = packet.readInt();</span>
<span class="nc" id="L143">            byte version = PacketHeader.getVersion(packetHeader);</span>
<span class="nc" id="L144">            byte opCode = PacketHeader.getOpCode(packetHeader);</span>
<span class="nc" id="L145">            short flags = PacketHeader.getFlags(packetHeader);</span>

            // packet format is different between ADDENTRY and READENTRY
<span class="nc" id="L148">            long ledgerId = -1;</span>
<span class="nc" id="L149">            long entryId = BookieProtocol.INVALID_ENTRY_ID;</span>

<span class="nc" id="L151">            ServerStats.getInstance().incrementPacketsReceived();</span>

<span class="nc bnc" id="L153" title="All 4 branches missed.">            switch (opCode) {</span>
            case BookieProtocol.ADDENTRY: {
<span class="nc" id="L155">                byte[] masterKey = readMasterKey(packet);</span>

                // Read ledger and entry id without advancing the reader index
<span class="nc" id="L158">                ledgerId = packet.getLong(packet.readerIndex());</span>
<span class="nc" id="L159">                entryId = packet.getLong(packet.readerIndex() + 8);</span>
<span class="nc" id="L160">                return BookieProtocol.AddRequest.create(</span>
                        version, ledgerId, entryId, flags,
<span class="nc" id="L162">                        masterKey, packet.retain());</span>
            }

            case BookieProtocol.READENTRY:
<span class="nc" id="L166">                ledgerId = packet.readLong();</span>
<span class="nc" id="L167">                entryId = packet.readLong();</span>

<span class="nc bnc" id="L169" title="All 4 branches missed.">                if ((flags &amp; BookieProtocol.FLAG_DO_FENCING) == BookieProtocol.FLAG_DO_FENCING</span>
                    &amp;&amp; version &gt;= 2) {
<span class="nc" id="L171">                    byte[] masterKey = readMasterKey(packet);</span>
<span class="nc" id="L172">                    return new BookieProtocol.ReadRequest(version, ledgerId, entryId, flags, masterKey);</span>
                } else {
<span class="nc" id="L174">                    return new BookieProtocol.ReadRequest(version, ledgerId, entryId, flags);</span>
                }
            case BookieProtocol.AUTH:
                BookkeeperProtocol.AuthMessage.Builder builder
<span class="nc" id="L178">                    = BookkeeperProtocol.AuthMessage.newBuilder();</span>
<span class="nc" id="L179">                builder.mergeFrom(new ByteBufInputStream(packet), extensionRegistry);</span>
<span class="nc" id="L180">                return new BookieProtocol.AuthRequest(version, builder.build());</span>
            }

<span class="nc" id="L183">            return packet;</span>
        }

        private static byte[] readMasterKey(ByteBuf packet) {
<span class="nc" id="L187">            byte[] masterKey = null;</span>

            // check if the master key is an empty master key
<span class="nc" id="L190">            boolean isEmptyKey = true;</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">            for (int i = 0; i &lt; BookieProtocol.MASTER_KEY_LENGTH; i++) {</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">                if (packet.getByte(packet.readerIndex() + i) != emptyPasswordMasterKey[i]) {</span>
<span class="nc" id="L193">                    isEmptyKey = false;</span>
<span class="nc" id="L194">                    break;</span>
                }
            }

<span class="nc bnc" id="L198" title="All 2 branches missed.">            if (isEmptyKey) {</span>
                // avoid new allocations if incoming master key is empty and use the static master key
<span class="nc" id="L200">                masterKey = emptyPasswordMasterKey;</span>
<span class="nc" id="L201">                packet.readerIndex(packet.readerIndex() + BookieProtocol.MASTER_KEY_LENGTH);</span>
            } else {
                // Master key is set, we need to copy and check it
<span class="nc" id="L204">                masterKey = new byte[BookieProtocol.MASTER_KEY_LENGTH];</span>
<span class="nc" id="L205">                packet.readBytes(masterKey, 0, BookieProtocol.MASTER_KEY_LENGTH);</span>
            }

<span class="nc" id="L208">            return masterKey;</span>
        }
    }

    public static class ResponseEnDeCoderPreV3 implements EnDecoder {
        final ExtensionRegistry extensionRegistry;

<span class="fc" id="L215">        public ResponseEnDeCoderPreV3(ExtensionRegistry extensionRegistry) {</span>
<span class="fc" id="L216">            this.extensionRegistry = extensionRegistry;</span>
<span class="fc" id="L217">        }</span>

        @Override
        public Object encode(Object msg, ByteBufAllocator allocator)
                throws Exception {
<span class="nc bnc" id="L222" title="All 2 branches missed.">            if (!(msg instanceof BookieProtocol.Response)) {</span>
<span class="nc" id="L223">                return msg;</span>
            }
<span class="nc" id="L225">            BookieProtocol.Response r = (BookieProtocol.Response)msg;</span>
<span class="nc" id="L226">            ByteBuf buf = allocator.buffer(24);</span>
<span class="nc" id="L227">            buf.writeInt(PacketHeader.toInt(r.getProtocolVersion(), r.getOpCode(), (short) 0));</span>

<span class="nc" id="L229">            ServerStats.getInstance().incrementPacketsSent();</span>
            try {
<span class="nc bnc" id="L231" title="All 2 branches missed.">                if (msg instanceof BookieProtocol.ReadResponse) {</span>
<span class="nc" id="L232">                    buf.writeInt(r.getErrorCode());</span>
<span class="nc" id="L233">                    buf.writeLong(r.getLedgerId());</span>
<span class="nc" id="L234">                    buf.writeLong(r.getEntryId());</span>

<span class="nc" id="L236">                    BookieProtocol.ReadResponse rr = (BookieProtocol.ReadResponse) r;</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">                    if (rr.hasData()) {</span>
<span class="nc" id="L238">                        return DoubleByteBuf.get(buf, rr.getData());</span>
                    } else {
<span class="nc" id="L240">                        return buf;</span>
                    }
<span class="nc bnc" id="L242" title="All 2 branches missed.">                } else if (msg instanceof BookieProtocol.AddResponse) {</span>
<span class="nc" id="L243">                    buf.writeInt(r.getErrorCode());</span>
<span class="nc" id="L244">                    buf.writeLong(r.getLedgerId());</span>
<span class="nc" id="L245">                    buf.writeLong(r.getEntryId());</span>

<span class="nc" id="L247">                    return buf;</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">                } else if (msg instanceof BookieProtocol.AuthResponse) {</span>
<span class="nc" id="L249">                    BookkeeperProtocol.AuthMessage am = ((BookieProtocol.AuthResponse) r).getAuthMessage();</span>
<span class="nc" id="L250">                    return DoubleByteBuf.get(buf, Unpooled.wrappedBuffer(am.toByteArray()));</span>
                } else {
<span class="nc" id="L252">                    LOG.error(&quot;Cannot encode unknown response type {}&quot;, msg.getClass().getName());</span>
<span class="nc" id="L253">                    return msg;</span>
                }
            } finally {
<span class="nc" id="L256">                r.recycle();</span>
            }
        }
        @Override
        public Object decode(ByteBuf buffer)
                throws Exception {
            int rc;
            long ledgerId, entryId;

<span class="nc" id="L265">            int packetHeader = buffer.readInt();</span>
<span class="nc" id="L266">            byte version = PacketHeader.getVersion(packetHeader);</span>
<span class="nc" id="L267">            byte opCode = PacketHeader.getOpCode(packetHeader);</span>

<span class="nc bnc" id="L269" title="All 4 branches missed.">            switch (opCode) {</span>
            case BookieProtocol.ADDENTRY:
<span class="nc" id="L271">                rc = buffer.readInt();</span>
<span class="nc" id="L272">                ledgerId = buffer.readLong();</span>
<span class="nc" id="L273">                entryId = buffer.readLong();</span>
<span class="nc" id="L274">                return BookieProtocol.AddResponse.create(version, rc, ledgerId, entryId);</span>
            case BookieProtocol.READENTRY:
<span class="nc" id="L276">                rc = buffer.readInt();</span>
<span class="nc" id="L277">                ledgerId = buffer.readLong();</span>
<span class="nc" id="L278">                entryId = buffer.readLong();</span>

<span class="nc bnc" id="L280" title="All 2 branches missed.">                if (rc == BookieProtocol.EOK) {</span>
<span class="nc" id="L281">                    ByteBuf content = buffer.slice();</span>
<span class="nc" id="L282">                    return new BookieProtocol.ReadResponse(version, rc, ledgerId, entryId, content.retain());</span>
                } else {
<span class="nc" id="L284">                    return new BookieProtocol.ReadResponse(version, rc, ledgerId, entryId);</span>
                }
            case BookieProtocol.AUTH:
<span class="nc" id="L287">                ByteBufInputStream bufStream = new ByteBufInputStream(buffer);</span>
                BookkeeperProtocol.AuthMessage.Builder builder
<span class="nc" id="L289">                    = BookkeeperProtocol.AuthMessage.newBuilder();</span>
<span class="nc" id="L290">                builder.mergeFrom(bufStream, extensionRegistry);</span>
<span class="nc" id="L291">                BookkeeperProtocol.AuthMessage am = builder.build();</span>
<span class="nc" id="L292">                return new BookieProtocol.AuthResponse(version, am);</span>
            default:
<span class="nc" id="L294">                throw new IllegalStateException(&quot;Received unknown response : op code = &quot; + opCode);</span>
            }
        }
    }

    public static class RequestEnDecoderV3 implements EnDecoder {
        final ExtensionRegistry extensionRegistry;

<span class="fc" id="L302">        public RequestEnDecoderV3(ExtensionRegistry extensionRegistry) {</span>
<span class="fc" id="L303">            this.extensionRegistry = extensionRegistry;</span>
<span class="fc" id="L304">        }</span>

        @Override
        public Object decode(ByteBuf packet) throws Exception {
<span class="fc" id="L308">            return BookkeeperProtocol.Request.parseFrom(new ByteBufInputStream(packet), extensionRegistry);</span>
        }

        @Override
        public Object encode(Object msg, ByteBufAllocator allocator) throws Exception {
<span class="fc" id="L313">            BookkeeperProtocol.Request request = (BookkeeperProtocol.Request) msg;</span>
<span class="fc" id="L314">            return serializeProtobuf(request, allocator);</span>
        }

    }

    public static class ResponseEnDecoderV3 implements EnDecoder {
        final ExtensionRegistry extensionRegistry;

<span class="fc" id="L322">        public ResponseEnDecoderV3(ExtensionRegistry extensionRegistry) {</span>
<span class="fc" id="L323">            this.extensionRegistry = extensionRegistry;</span>
<span class="fc" id="L324">        }</span>

        @Override
        public Object decode(ByteBuf packet) throws Exception {
<span class="fc" id="L328">            return BookkeeperProtocol.Response.parseFrom(new ByteBufInputStream(packet),</span>
                                                         extensionRegistry);
        }

        @Override
        public Object encode(Object msg, ByteBufAllocator allocator) throws Exception {
<span class="fc" id="L334">            BookkeeperProtocol.Response response = (BookkeeperProtocol.Response) msg;</span>
<span class="fc" id="L335">            return serializeProtobuf(response, allocator);</span>
        }

    }

    private static ByteBuf serializeProtobuf(MessageLite msg, ByteBufAllocator allocator) {
<span class="fc" id="L341">        int size = msg.getSerializedSize();</span>
<span class="fc" id="L342">        ByteBuf buf = allocator.heapBuffer(size, size);</span>

        try {
<span class="fc" id="L345">            msg.writeTo(CodedOutputStream.newInstance(buf.array(), buf.arrayOffset() + buf.writerIndex(), size));</span>
<span class="nc" id="L346">        } catch (IOException e) {</span>
            // This is in-memory serialization, should not fail
<span class="nc" id="L348">            throw new RuntimeException(e);</span>
<span class="fc" id="L349">        }</span>

        // Advance writer idx
<span class="fc" id="L352">        buf.writerIndex(buf.capacity());</span>
<span class="fc" id="L353">        return buf;</span>
    }

    @Sharable
    public static class RequestEncoder extends MessageToMessageEncoder&lt;Object&gt; {

        final EnDecoder REQ_PREV3;
        final EnDecoder REQ_V3;

<span class="fc" id="L362">        public RequestEncoder(ExtensionRegistry extensionRegistry) {</span>
<span class="fc" id="L363">            REQ_PREV3 = new RequestEnDeCoderPreV3(extensionRegistry);</span>
<span class="fc" id="L364">            REQ_V3 = new RequestEnDecoderV3(extensionRegistry);</span>
<span class="fc" id="L365">        }</span>

        @Override
        protected void encode(ChannelHandlerContext ctx, Object msg, List&lt;Object&gt; out) throws Exception {
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">            if (msg instanceof BookkeeperProtocol.Request) {</span>
<span class="fc" id="L370">                out.add(REQ_V3.encode(msg, ctx.alloc()));</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">            } else if (msg instanceof BookieProtocol.Request) {</span>
<span class="nc" id="L372">                out.add(REQ_PREV3.encode(msg, ctx.alloc()));</span>
            } else {
<span class="nc" id="L374">                LOG.error(&quot;Invalid request to encode to {}: {}&quot;, ctx.channel(), msg.getClass().getName());</span>
<span class="nc" id="L375">                out.add(msg);</span>
            }
<span class="fc" id="L377">        }</span>
    }

    @Sharable
    public static class RequestDecoder extends MessageToMessageDecoder&lt;Object&gt; {
        final EnDecoder REQ_PREV3;
        final EnDecoder REQ_V3;
        boolean usingV3Protocol;

<span class="fc" id="L386">        RequestDecoder(ExtensionRegistry extensionRegistry) {</span>
<span class="fc" id="L387">            REQ_PREV3 = new RequestEnDeCoderPreV3(extensionRegistry);</span>
<span class="fc" id="L388">            REQ_V3 = new RequestEnDecoderV3(extensionRegistry);</span>
<span class="fc" id="L389">            usingV3Protocol = true;</span>
<span class="fc" id="L390">        }</span>

        @Override
        protected void decode(ChannelHandlerContext ctx, Object msg, List&lt;Object&gt; out) throws Exception {
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L395">                LOG.debug(&quot;Received request {} from channel {} to decode.&quot;, msg, ctx.channel());</span>
            }
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">            if (!(msg instanceof ByteBuf)) {</span>
<span class="nc" id="L398">                out.add(msg);</span>
<span class="nc" id="L399">                return;</span>
            }
<span class="fc" id="L401">            ByteBuf buffer = (ByteBuf) msg;</span>
<span class="fc" id="L402">            buffer.markReaderIndex();</span>

<span class="pc bpc" id="L404" title="1 of 2 branches missed.">            if (usingV3Protocol) {</span>
                try {
<span class="fc" id="L406">                    out.add(REQ_V3.decode(buffer));</span>
<span class="nc" id="L407">                } catch (InvalidProtocolBufferException e) {</span>
<span class="nc" id="L408">                    usingV3Protocol = false;</span>
<span class="nc" id="L409">                    buffer.resetReaderIndex();</span>
<span class="nc" id="L410">                    out.add(REQ_PREV3.decode(buffer));</span>
<span class="pc" id="L411">                }</span>
            } else {
<span class="nc" id="L413">                out.add(REQ_PREV3.decode(buffer));</span>
            }
<span class="fc" id="L415">        }</span>
    }

    @Sharable
    public static class ResponseEncoder extends MessageToMessageEncoder&lt;Object&gt; {
        final EnDecoder REP_PREV3;
        final EnDecoder REP_V3;

<span class="fc" id="L423">        ResponseEncoder(ExtensionRegistry extensionRegistry) {</span>
<span class="fc" id="L424">            REP_PREV3 = new ResponseEnDeCoderPreV3(extensionRegistry);</span>
<span class="fc" id="L425">            REP_V3 = new ResponseEnDecoderV3(extensionRegistry);</span>
<span class="fc" id="L426">        }</span>

        @Override
        protected void encode(ChannelHandlerContext ctx, Object msg, List&lt;Object&gt; out)
                throws Exception {
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L432">                LOG.debug(&quot;Encode response {} to channel {}.&quot;, msg, ctx.channel());</span>
            }
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">            if (msg instanceof BookkeeperProtocol.Response) {</span>
<span class="fc" id="L435">                out.add(REP_V3.encode(msg, ctx.alloc()));</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">            } else if (msg instanceof BookieProtocol.Response) {</span>
<span class="nc" id="L437">                out.add(REP_PREV3.encode(msg, ctx.alloc()));</span>
            } else {
<span class="nc" id="L439">                LOG.error(&quot;Invalid response to encode to {}: {}&quot;, ctx.channel(), msg.getClass().getName());</span>
<span class="nc" id="L440">                out.add(msg);</span>
            }
<span class="fc" id="L442">        }</span>
    }

    @Sharable
    public static class ResponseDecoder extends MessageToMessageDecoder&lt;Object&gt; {
        final EnDecoder REP_PREV3;
        final EnDecoder REP_V3;
        boolean usingV3Protocol;

<span class="fc" id="L451">        ResponseDecoder(ExtensionRegistry extensionRegistry) {</span>
<span class="fc" id="L452">            REP_PREV3 = new ResponseEnDeCoderPreV3(extensionRegistry);</span>
<span class="fc" id="L453">            REP_V3 = new ResponseEnDecoderV3(extensionRegistry);</span>
<span class="fc" id="L454">            usingV3Protocol = true;</span>
<span class="fc" id="L455">        }</span>

        @Override
        protected void decode(ChannelHandlerContext ctx, Object msg, List&lt;Object&gt; out) throws Exception {
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L460">                LOG.debug(&quot;Received response {} from channel {} to decode.&quot;, msg, ctx.channel());</span>
            }
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">            if (!(msg instanceof ByteBuf)) {</span>
<span class="nc" id="L463">                out.add(msg);</span>
            }
<span class="fc" id="L465">            ByteBuf buffer = (ByteBuf) msg;</span>
<span class="fc" id="L466">            buffer.markReaderIndex();</span>

<span class="pc bpc" id="L468" title="1 of 2 branches missed.">            if (usingV3Protocol) {</span>
                try {
<span class="fc" id="L470">                    out.add(REP_V3.decode(buffer));</span>
<span class="nc" id="L471">                } catch (InvalidProtocolBufferException e) {</span>
<span class="nc" id="L472">                    usingV3Protocol = false;</span>
<span class="nc" id="L473">                    buffer.resetReaderIndex();</span>
<span class="nc" id="L474">                    out.add(REP_PREV3.decode(buffer));</span>
<span class="pc" id="L475">                }</span>
            } else {
                // If in the same connection we already got preV3 messages, don't try again to decode V3 messages
<span class="nc" id="L478">                out.add(REP_PREV3.decode(buffer));</span>
            }
<span class="fc" id="L480">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>