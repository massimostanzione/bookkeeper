<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PerChannelBookieClient.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.proto</a> &gt; <span class="el_source">PerChannelBookieClient.java</span></div><h1>PerChannelBookieClient.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information

 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.bookkeeper.proto;

import static org.apache.bookkeeper.client.LedgerHandle.INVALID_ENTRY_ID;

import com.google.common.collect.Sets;
import com.google.common.base.Joiner;
import com.google.protobuf.ByteString;
import com.google.protobuf.ExtensionRegistry;
import io.netty.bootstrap.Bootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufAllocator;
import io.netty.buffer.PooledByteBufAllocator;
import io.netty.buffer.Unpooled;
import io.netty.buffer.UnpooledByteBufAllocator;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.DefaultEventLoopGroup;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.WriteBufferWaterMark;
import io.netty.channel.ChannelHandler.Sharable;
import io.netty.channel.epoll.EpollEventLoopGroup;
import io.netty.channel.epoll.EpollSocketChannel;
import io.netty.channel.local.LocalChannel;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.codec.CorruptedFrameException;
import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
import io.netty.handler.codec.LengthFieldPrepender;
import io.netty.handler.codec.TooLongFrameException;
import io.netty.handler.ssl.SslHandler;
import io.netty.util.HashedWheelTimer;
import io.netty.util.Recycler;
import io.netty.util.Recycler.Handle;
import io.netty.util.Timeout;
import io.netty.util.TimerTask;
import io.netty.util.concurrent.Future;
import io.netty.util.concurrent.GenericFutureListener;

import java.io.IOException;
import java.net.SocketAddress;
import java.nio.channels.ClosedChannelException;
import java.util.ArrayDeque;
import java.util.Collections;
import java.util.Collection;
import java.util.Objects;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import org.apache.bookkeeper.auth.BookKeeperPrincipal;
import org.apache.bookkeeper.auth.ClientAuthProvider;
import org.apache.bookkeeper.client.BKException;
import org.apache.bookkeeper.client.BookKeeperClientStats;
import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;
import org.apache.bookkeeper.conf.ClientConfiguration;
import org.apache.bookkeeper.net.BookieSocketAddress;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallbackCtx;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GetBookieInfoCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteLacCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadLacCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.StartTLSCallback;
import org.apache.bookkeeper.proto.BookkeeperProtocol.AddRequest;
import org.apache.bookkeeper.proto.BookkeeperProtocol.AddResponse;
import org.apache.bookkeeper.proto.BookkeeperProtocol.BKPacketHeader;
import org.apache.bookkeeper.proto.BookkeeperProtocol.GetBookieInfoRequest;
import org.apache.bookkeeper.proto.BookkeeperProtocol.GetBookieInfoResponse;
import org.apache.bookkeeper.proto.BookkeeperProtocol.OperationType;
import org.apache.bookkeeper.proto.BookkeeperProtocol.ProtocolVersion;
import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadLacRequest;
import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadLacResponse;
import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadRequest;
import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadResponse;
import org.apache.bookkeeper.proto.BookkeeperProtocol.Request;
import org.apache.bookkeeper.proto.BookkeeperProtocol.Response;
import org.apache.bookkeeper.proto.BookkeeperProtocol.StatusCode;
import org.apache.bookkeeper.proto.BookkeeperProtocol.WriteLacRequest;
import org.apache.bookkeeper.proto.BookkeeperProtocol.WriteLacResponse;
import org.apache.bookkeeper.stats.NullStatsLogger;
import org.apache.bookkeeper.stats.OpStatsLogger;
import org.apache.bookkeeper.stats.StatsLogger;
import org.apache.bookkeeper.tls.SecurityException;
import org.apache.bookkeeper.tls.SecurityHandlerFactory;
import org.apache.bookkeeper.tls.SecurityHandlerFactory.NodeType;
import org.apache.bookkeeper.util.MathUtils;
import org.apache.bookkeeper.util.OrderedSafeExecutor;
import org.apache.bookkeeper.util.SafeRunnable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.collect.Sets;
import com.google.protobuf.ExtensionRegistry;
import io.netty.buffer.ByteBufAllocator;
import io.netty.buffer.UnpooledByteBufAllocator;
import java.net.SocketAddress;

import java.net.SocketAddress;
import java.security.cert.Certificate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import javax.net.ssl.SSLPeerUnverifiedException;
import org.apache.bookkeeper.auth.BookKeeperPrincipal;

/**
 * This class manages all details of connection to a particular bookie. It also
 * has reconnect logic if a connection to a bookie fails.
 */
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">@Sharable</span>
public class PerChannelBookieClient extends ChannelInboundHandlerAdapter {

<span class="fc" id="L139">    static final Logger LOG = LoggerFactory.getLogger(PerChannelBookieClient.class);</span>

    // this set contains the bookie error return codes that we do not consider for a bookie to be &quot;faulty&quot;
<span class="fc" id="L142">    private static final Set&lt;Integer&gt; expectedBkOperationErrors = Collections.unmodifiableSet(Sets</span>
<span class="fc" id="L143">            .newHashSet(BKException.Code.BookieHandleNotAvailableException,</span>
<span class="fc" id="L144">                        BKException.Code.NoSuchEntryException,</span>
<span class="fc" id="L145">                        BKException.Code.NoSuchLedgerExistsException,</span>
<span class="fc" id="L146">                        BKException.Code.LedgerFencedException,</span>
<span class="fc" id="L147">                        BKException.Code.LedgerExistException,</span>
<span class="fc" id="L148">                        BKException.Code.DuplicateEntryIdException,</span>
<span class="fc" id="L149">                        BKException.Code.WriteOnReadOnlyBookieException));</span>

<span class="fc" id="L151">    public static final AtomicLong txnIdGenerator = new AtomicLong(0);</span>

    final BookieSocketAddress addr;
    final EventLoopGroup eventLoopGroup;
    final OrderedSafeExecutor executor;
    final HashedWheelTimer requestTimer;
    final int addEntryTimeout;
    final int readEntryTimeout;
    final int maxFrameSize;
    final int getBookieInfoTimeout;
    final int startTLSTimeout;

<span class="fc" id="L163">    private final ConcurrentHashMap&lt;CompletionKey, CompletionValue&gt; completionObjects = new ConcurrentHashMap&lt;CompletionKey, CompletionValue&gt;();</span>

    private final StatsLogger statsLogger;
    private final OpStatsLogger readEntryOpLogger;
    private final OpStatsLogger readTimeoutOpLogger;
    private final OpStatsLogger addEntryOpLogger;
    private final OpStatsLogger writeLacOpLogger;
    private final OpStatsLogger readLacOpLogger;
    private final OpStatsLogger addTimeoutOpLogger;
    private final OpStatsLogger writeLacTimeoutOpLogger;
    private final OpStatsLogger readLacTimeoutOpLogger;
    private final OpStatsLogger getBookieInfoOpLogger;
    private final OpStatsLogger getBookieInfoTimeoutOpLogger;
    private final OpStatsLogger startTLSOpLogger;
    private final OpStatsLogger startTLSTimeoutOpLogger;

    private final boolean useV2WireProtocol;

    /**
     * The following member variables do not need to be concurrent, or volatile
     * because they are always updated under a lock
     */
<span class="fc" id="L185">    private volatile Queue&lt;GenericCallback&lt;PerChannelBookieClient&gt;&gt; pendingOps =</span>
            new ArrayDeque&lt;GenericCallback&lt;PerChannelBookieClient&gt;&gt;();
<span class="fc" id="L187">    volatile Channel channel = null;</span>
    private final ClientConnectionPeer connectionPeer;
<span class="fc" id="L189">    private volatile BookKeeperPrincipal authorizedId = BookKeeperPrincipal.ANONYMOUS;</span>

<span class="fc" id="L191">    enum ConnectionState {</span>
<span class="fc" id="L192">        DISCONNECTED, CONNECTING, CONNECTED, CLOSED, START_TLS</span>
    }

    volatile ConnectionState state;
<span class="fc" id="L196">    final ReentrantReadWriteLock closeLock = new ReentrantReadWriteLock();</span>
    private final ClientConfiguration conf;

    private final PerChannelBookieClientPool pcbcPool;
    private final ClientAuthProvider.Factory authProviderFactory;
    private final ExtensionRegistry extRegistry;
    private final SecurityHandlerFactory shFactory;

    public PerChannelBookieClient(OrderedSafeExecutor executor, EventLoopGroup eventLoopGroup,
                                  BookieSocketAddress addr) throws SecurityException {
<span class="nc" id="L206">        this(new ClientConfiguration(), executor, eventLoopGroup, addr, null, NullStatsLogger.INSTANCE, null, null,</span>
                null);
<span class="nc" id="L208">    }</span>

    public PerChannelBookieClient(OrderedSafeExecutor executor, EventLoopGroup eventLoopGroup,
                                  BookieSocketAddress addr,
                                  ClientAuthProvider.Factory authProviderFactory,
                                  ExtensionRegistry extRegistry) throws SecurityException {
<span class="nc" id="L214">        this(new ClientConfiguration(), executor, eventLoopGroup, addr, null, NullStatsLogger.INSTANCE,</span>
                authProviderFactory, extRegistry, null);
<span class="nc" id="L216">    }</span>

    public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor executor,
                                  EventLoopGroup eventLoopGroup, BookieSocketAddress addr,
                                  HashedWheelTimer requestTimer, StatsLogger parentStatsLogger,
                                  ClientAuthProvider.Factory authProviderFactory,
                                  ExtensionRegistry extRegistry,
                                  PerChannelBookieClientPool pcbcPool) throws SecurityException {
<span class="nc" id="L224">       this(conf, executor, eventLoopGroup, addr, null, NullStatsLogger.INSTANCE,</span>
                authProviderFactory, extRegistry, pcbcPool, null);
<span class="nc" id="L226">    }</span>

    public PerChannelBookieClient(ClientConfiguration conf, OrderedSafeExecutor executor,
                                  EventLoopGroup eventLoopGroup, BookieSocketAddress addr,
                                  HashedWheelTimer requestTimer, StatsLogger parentStatsLogger,
                                  ClientAuthProvider.Factory authProviderFactory,
                                  ExtensionRegistry extRegistry,
                                  PerChannelBookieClientPool pcbcPool,
<span class="fc" id="L234">                                  SecurityHandlerFactory shFactory) throws SecurityException {</span>
<span class="fc" id="L235">        this.maxFrameSize = conf.getNettyMaxFrameSizeBytes();</span>
<span class="fc" id="L236">        this.conf = conf;</span>
<span class="fc" id="L237">        this.addr = addr;</span>
<span class="fc" id="L238">        this.executor = executor;</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">        if (LocalBookiesRegistry.isLocalBookie(addr)) {</span>
<span class="nc" id="L240">            this.eventLoopGroup = new DefaultEventLoopGroup();</span>
        } else {
<span class="fc" id="L242">            this.eventLoopGroup = eventLoopGroup;</span>
        }
<span class="fc" id="L244">        this.state = ConnectionState.DISCONNECTED;</span>
<span class="fc" id="L245">        this.requestTimer = requestTimer;</span>
<span class="fc" id="L246">        this.addEntryTimeout = conf.getAddEntryTimeout();</span>
<span class="fc" id="L247">        this.readEntryTimeout = conf.getReadEntryTimeout();</span>
<span class="fc" id="L248">        this.getBookieInfoTimeout = conf.getBookieInfoTimeout();</span>
<span class="fc" id="L249">        this.startTLSTimeout = conf.getStartTLSTimeout();</span>
<span class="fc" id="L250">        this.useV2WireProtocol = conf.getUseV2WireProtocol();</span>

<span class="fc" id="L252">        this.authProviderFactory = authProviderFactory;</span>
<span class="fc" id="L253">        this.extRegistry = extRegistry;</span>
<span class="fc" id="L254">        this.shFactory = shFactory;</span>
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">        if (shFactory != null) {</span>
<span class="nc" id="L256">            shFactory.init(NodeType.Client, conf);</span>
        }

<span class="fc" id="L259">        StringBuilder nameBuilder = new StringBuilder();</span>
<span class="fc" id="L260">        nameBuilder.append(addr.getHostName().replace('.', '_').replace('-', '_'))</span>
<span class="fc" id="L261">            .append(&quot;_&quot;).append(addr.getPort());</span>

<span class="fc" id="L263">        this.statsLogger = parentStatsLogger.scope(BookKeeperClientStats.CHANNEL_SCOPE)</span>
<span class="fc" id="L264">            .scope(nameBuilder.toString());</span>

<span class="fc" id="L266">        readEntryOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_READ_OP);</span>
<span class="fc" id="L267">        addEntryOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_ADD_OP);</span>
<span class="fc" id="L268">        writeLacOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_WRITE_LAC_OP);</span>
<span class="fc" id="L269">        readLacOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_READ_LAC_OP);</span>
<span class="fc" id="L270">        getBookieInfoOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.GET_BOOKIE_INFO_OP);</span>
<span class="fc" id="L271">        readTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_READ);</span>
<span class="fc" id="L272">        addTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_ADD);</span>
<span class="fc" id="L273">        writeLacTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_WRITE_LAC);</span>
<span class="fc" id="L274">        readLacTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_READ_LAC);</span>
<span class="fc" id="L275">        getBookieInfoTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.TIMEOUT_GET_BOOKIE_INFO);</span>
<span class="fc" id="L276">        startTLSOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_START_TLS_OP);</span>
<span class="fc" id="L277">        startTLSTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_START_TLS_OP);</span>

<span class="fc" id="L279">        this.pcbcPool = pcbcPool;</span>

<span class="fc" id="L281">        this.connectionPeer = new ClientConnectionPeer() {</span>

            @Override
            public SocketAddress getRemoteAddr() {
<span class="nc" id="L285">                Channel c = channel;</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">                if (c != null) {</span>
<span class="nc" id="L287">                    return c.remoteAddress();</span>
                } else {
<span class="nc" id="L289">                    return null;</span>
                }
            }

            @Override
            public Collection&lt;Object&gt; getProtocolPrincipals() {
<span class="nc" id="L295">                Channel c = channel;</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">                if (c == null) {</span>
<span class="nc" id="L297">                    return Collections.emptyList();</span>
                }
<span class="nc" id="L299">                SslHandler ssl = c.pipeline().get(SslHandler.class);</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">                if (ssl == null) {</span>
<span class="nc" id="L301">                    return Collections.emptyList();</span>
                }
                try {
<span class="nc" id="L304">                    Certificate[] certificates = ssl.engine().getSession().getPeerCertificates();</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">                    if (certificates == null) {</span>
<span class="nc" id="L306">                        return Collections.emptyList();</span>
                    }
<span class="nc" id="L308">                    List&lt;Object&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L309">                    result.addAll(Arrays.asList(certificates));</span>
<span class="nc" id="L310">                    return result;</span>
<span class="nc" id="L311">                } catch (SSLPeerUnverifiedException err) {</span>
<span class="nc" id="L312">                     return Collections.emptyList();</span>
                }
            }

            @Override
            public void disconnect() {
<span class="nc" id="L318">                Channel c = channel;</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">                if (c != null) {</span>
<span class="nc" id="L320">                    c.close();</span>
                }
<span class="nc" id="L322">                LOG.info(&quot;authplugin disconnected channel {}&quot;, channel);</span>
<span class="nc" id="L323">            }</span>

            @Override
            public void setAuthorizedId(BookKeeperPrincipal principal) {
<span class="fc" id="L327">                authorizedId = principal;</span>
<span class="fc" id="L328">                LOG.info(&quot;connection {} authenticated as {}&quot;, channel, principal);</span>
<span class="fc" id="L329">            }</span>

            @Override
            public BookKeeperPrincipal getAuthorizedId() {
<span class="nc" id="L333">                return authorizedId;</span>
            }

            @Override
            public boolean isSecure() {
<span class="nc" id="L338">               Channel c = channel;</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">               if (c == null) {</span>
<span class="nc" id="L340">                    return false;</span>
               } else {
<span class="nc bnc" id="L342" title="All 2 branches missed.">                    return c.pipeline().get(SslHandler.class) != null;</span>
               }
            }

        };
<span class="fc" id="L347">    }</span>

    private void completeOperation(GenericCallback&lt;PerChannelBookieClient&gt; op, int rc) {
        //Thread.dumpStack();
<span class="fc" id="L351">        closeLock.readLock().lock();</span>
        try {
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">            if (ConnectionState.CLOSED == state) {</span>
<span class="nc" id="L354">                op.operationComplete(BKException.Code.ClientClosedException, this);</span>
            } else {
<span class="fc" id="L356">                op.operationComplete(rc, this);</span>
            }
        } finally {
<span class="fc" id="L359">            closeLock.readLock().unlock();</span>
        }
<span class="fc" id="L361">    }</span>

    protected ChannelFuture connect() {
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L365">            LOG.debug(&quot;Connecting to bookie: {}&quot;, addr);</span>
        }

        // Set up the ClientBootStrap so we can create a new Channel connection to the bookie.
<span class="fc" id="L369">        Bootstrap bootstrap = new Bootstrap();</span>
<span class="fc" id="L370">        bootstrap.group(eventLoopGroup);</span>
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">        if (eventLoopGroup instanceof EpollEventLoopGroup) {</span>
<span class="fc" id="L372">            bootstrap.channel(EpollSocketChannel.class);</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">        } else if (eventLoopGroup instanceof DefaultEventLoopGroup) {</span>
<span class="nc" id="L374">            bootstrap.channel(LocalChannel.class);</span>
        } else {
<span class="nc" id="L376">            bootstrap.channel(NioSocketChannel.class);</span>
        }

        ByteBufAllocator allocator;
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">        if (this.conf.isNettyUsePooledBuffers()) {</span>
<span class="fc" id="L381">            allocator = PooledByteBufAllocator.DEFAULT;</span>
        } else {
<span class="nc" id="L383">            allocator = UnpooledByteBufAllocator.DEFAULT;</span>
        }

<span class="fc" id="L386">        bootstrap.option(ChannelOption.ALLOCATOR, allocator);</span>
<span class="fc" id="L387">        bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, conf.getClientConnectTimeoutMillis());</span>
<span class="fc" id="L388">        bootstrap.option(ChannelOption.WRITE_BUFFER_WATER_MARK, new WriteBufferWaterMark(</span>
<span class="fc" id="L389">                conf.getClientWriteBufferLowWaterMark(), conf.getClientWriteBufferHighWaterMark()));</span>

<span class="pc bpc" id="L391" title="1 of 2 branches missed.">        if (!(eventLoopGroup instanceof DefaultEventLoopGroup)) {</span>
<span class="fc" id="L392">            bootstrap.option(ChannelOption.TCP_NODELAY, conf.getClientTcpNoDelay());</span>
<span class="fc" id="L393">            bootstrap.option(ChannelOption.SO_KEEPALIVE, conf.getClientSockKeepalive());</span>

            // if buffer sizes are 0, let OS auto-tune it
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">            if (conf.getClientSendBufferSize() &gt; 0) {</span>
<span class="fc" id="L397">                bootstrap.option(ChannelOption.SO_SNDBUF, conf.getClientSendBufferSize());</span>
            }

<span class="pc bpc" id="L400" title="1 of 2 branches missed.">            if (conf.getClientReceiveBufferSize() &gt; 0) {</span>
<span class="fc" id="L401">                bootstrap.option(ChannelOption.SO_RCVBUF, conf.getClientReceiveBufferSize());</span>
            }
        }

        // In the netty pipeline, we need to split packets based on length, so we
        // use the {@link LengthFieldBasedFramDecoder}. Other than that all actions
        // are carried out in this class, e.g., making sense of received messages,
        // prepending the length to outgoing packets etc.
<span class="fc" id="L409">        bootstrap.handler(new ChannelInitializer&lt;Channel&gt;() {</span>
            @Override
            protected void initChannel(Channel ch) throws Exception {
<span class="fc" id="L412">                ChannelPipeline pipeline = ch.pipeline();</span>

<span class="fc" id="L414">                pipeline.addLast(&quot;lengthbasedframedecoder&quot;,</span>
                        new LengthFieldBasedFrameDecoder(maxFrameSize, 0, 4, 0, 4));
<span class="fc" id="L416">                pipeline.addLast(&quot;lengthprepender&quot;, new LengthFieldPrepender(4));</span>
<span class="fc" id="L417">                pipeline.addLast(&quot;bookieProtoEncoder&quot;, new BookieProtoEncoding.RequestEncoder(extRegistry));</span>
<span class="fc" id="L418">                pipeline.addLast(&quot;bookieProtoDecoder&quot;, new BookieProtoEncoding.ResponseDecoder(extRegistry));</span>
<span class="fc" id="L419">                pipeline.addLast(&quot;authHandler&quot;, new AuthHandler.ClientSideHandler(authProviderFactory, txnIdGenerator, connectionPeer));</span>
<span class="fc" id="L420">                pipeline.addLast(&quot;mainhandler&quot;, PerChannelBookieClient.this);</span>
<span class="fc" id="L421">            }</span>
        });

<span class="fc" id="L424">        SocketAddress bookieAddr = addr.getSocketAddress();</span>
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">        if (eventLoopGroup instanceof DefaultEventLoopGroup) {</span>
<span class="nc" id="L426">            bookieAddr = addr.getLocalAddress();</span>
        }

<span class="fc" id="L429">        ChannelFuture future = bootstrap.connect(bookieAddr);</span>
<span class="fc" id="L430">        future.addListener(new ConnectionFutureListener());</span>
<span class="fc" id="L431">        return future;</span>
    }

    void cleanDisconnectAndClose() {
<span class="nc" id="L435">        disconnect();</span>
<span class="nc" id="L436">        close();</span>
<span class="nc" id="L437">    }</span>

    void connectIfNeededAndDoOp(GenericCallback&lt;PerChannelBookieClient&gt; op) {
<span class="fc" id="L440">        boolean completeOpNow = false;</span>
<span class="fc" id="L441">        int opRc = BKException.Code.OK;</span>
        // common case without lock first
<span class="pc bpc" id="L443" title="1 of 4 branches missed.">        if (channel != null &amp;&amp; state == ConnectionState.CONNECTED) {</span>
<span class="fc" id="L444">            completeOpNow = true;</span>
        } else {

<span class="fc" id="L447">            synchronized (this) {</span>
                // check the channel status again under lock
<span class="pc bpc" id="L449" title="3 of 4 branches missed.">                if (channel != null &amp;&amp; state == ConnectionState.CONNECTED) {</span>
<span class="nc" id="L450">                    completeOpNow = true;</span>
<span class="nc" id="L451">                    opRc = BKException.Code.OK;</span>
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">                } else if (state == ConnectionState.CLOSED) {</span>
<span class="nc" id="L453">                    completeOpNow = true;</span>
<span class="nc" id="L454">                    opRc = BKException.Code.BookieHandleNotAvailableException;</span>
                } else {
                    // channel is either null (first connection attempt), or the
                    // channel is disconnected. Connection attempt is still in
                    // progress, queue up this op. Op will be executed when
                    // connection attempt either fails or succeeds
<span class="fc" id="L460">                    pendingOps.add(op);</span>

<span class="pc bpc" id="L462" title="1 of 4 branches missed.">                    if (state == ConnectionState.CONNECTING</span>
                        || state == ConnectionState.START_TLS) {
                        // the connection request has already been sent and it is waiting for the response.
<span class="fc" id="L465">                        return;</span>
                    }
                    // switch state to connecting and do connection attempt
<span class="fc" id="L468">                    state = ConnectionState.CONNECTING;</span>
                }
<span class="fc" id="L470">            }</span>
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">            if (!completeOpNow) {</span>
                // Start connection attempt to the input server host.
<span class="fc" id="L473">                connect();</span>
            }
        }

<span class="fc bfc" id="L477" title="All 2 branches covered.">        if (completeOpNow) {</span>
<span class="fc" id="L478">            completeOperation(op, opRc);</span>
        }

<span class="fc" id="L481">    }</span>

    void writeLac(final long ledgerId, final byte[] masterKey, final long lac, ByteBuf toSend, WriteLacCallback cb,
            Object ctx) {
<span class="nc" id="L485">        final long txnId = getTxnId();</span>
<span class="nc" id="L486">        final CompletionKey completionKey = new V3CompletionKey(txnId,</span>
                                                                OperationType.WRITE_LAC);
        // writeLac is mostly like addEntry hence uses addEntryTimeout
<span class="nc" id="L489">        completionObjects.put(completionKey,</span>
                              new WriteLacCompletion(completionKey, cb,
                                                     ctx, lac));

        // Build the request
<span class="nc" id="L494">        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()</span>
<span class="nc" id="L495">                .setVersion(ProtocolVersion.VERSION_THREE)</span>
<span class="nc" id="L496">                .setOperation(OperationType.WRITE_LAC)</span>
<span class="nc" id="L497">                .setTxnId(txnId);</span>
<span class="nc" id="L498">        WriteLacRequest.Builder writeLacBuilder = WriteLacRequest.newBuilder()</span>
<span class="nc" id="L499">                .setLedgerId(ledgerId)</span>
<span class="nc" id="L500">                .setLac(lac)</span>
<span class="nc" id="L501">                .setMasterKey(ByteString.copyFrom(masterKey))</span>
<span class="nc" id="L502">                .setBody(ByteString.copyFrom(toSend.nioBuffer()));</span>

<span class="nc" id="L504">        final Request writeLacRequest = Request.newBuilder()</span>
<span class="nc" id="L505">                .setHeader(headerBuilder)</span>
<span class="nc" id="L506">                .setWriteLacRequest(writeLacBuilder)</span>
<span class="nc" id="L507">                .build();</span>
<span class="nc" id="L508">        writeAndFlush(channel, completionKey, writeLacRequest);</span>
<span class="nc" id="L509">    }</span>

    /**
     * This method should be called only after connection has been checked for
     * {@link #connectIfNeededAndDoOp(GenericCallback)}
     *
     * @param ledgerId
     *          Ledger Id
     * @param masterKey
     *          Master Key
     * @param entryId
     *          Entry Id
     * @param toSend
     *          Buffer to send
     * @param cb
     *          Write callback
     * @param ctx
     *          Write callback context
     * @param options
     *          Add options
     */
    void addEntry(final long ledgerId, byte[] masterKey, final long entryId, ByteBuf toSend, WriteCallback cb,
                  Object ctx, final int options) {
<span class="fc" id="L532">        Object request = null;</span>
<span class="fc" id="L533">        CompletionKey completionKey = null;</span>
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">        if (useV2WireProtocol) {</span>
<span class="nc" id="L535">            completionKey = acquireV2Key(ledgerId, entryId, OperationType.ADD_ENTRY);</span>
<span class="nc" id="L536">            request = BookieProtocol.AddRequest.create(</span>
                    BookieProtocol.CURRENT_PROTOCOL_VERSION, ledgerId, entryId,
                    (short) options, masterKey, toSend);
        } else {
<span class="fc" id="L540">            final long txnId = getTxnId();</span>
<span class="fc" id="L541">            completionKey = new V3CompletionKey(txnId, OperationType.ADD_ENTRY);</span>

            // Build the request and calculate the total size to be included in the packet.
<span class="fc" id="L544">            BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()</span>
<span class="fc" id="L545">                    .setVersion(ProtocolVersion.VERSION_THREE)</span>
<span class="fc" id="L546">                    .setOperation(OperationType.ADD_ENTRY)</span>
<span class="fc" id="L547">                    .setTxnId(txnId);</span>

<span class="fc" id="L549">            byte[] toSendArray = new byte[toSend.readableBytes()];</span>
<span class="fc" id="L550">            toSend.getBytes(toSend.readerIndex(), toSendArray);</span>
<span class="fc" id="L551">            AddRequest.Builder addBuilder = AddRequest.newBuilder()</span>
<span class="fc" id="L552">                    .setLedgerId(ledgerId)</span>
<span class="fc" id="L553">                    .setEntryId(entryId)</span>
<span class="fc" id="L554">                    .setMasterKey(ByteString.copyFrom(masterKey))</span>
<span class="fc" id="L555">                    .setBody(ByteString.copyFrom(toSendArray));</span>

<span class="pc bpc" id="L557" title="1 of 2 branches missed.">            if (((short) options &amp; BookieProtocol.FLAG_RECOVERY_ADD) == BookieProtocol.FLAG_RECOVERY_ADD) {</span>
<span class="nc" id="L558">                addBuilder.setFlag(AddRequest.Flag.RECOVERY_ADD);</span>
            }

<span class="fc" id="L561">            request = Request.newBuilder()</span>
<span class="fc" id="L562">                    .setHeader(headerBuilder)</span>
<span class="fc" id="L563">                    .setAddRequest(addBuilder)</span>
<span class="fc" id="L564">                    .build();</span>
        }

<span class="fc" id="L567">        completionObjects.put(completionKey,</span>
<span class="fc" id="L568">                              acquireAddCompletion(completionKey,</span>
                                                   cb, ctx, ledgerId, entryId));
<span class="fc" id="L570">        final Channel c = channel;</span>
<span class="pc bpc" id="L571" title="1 of 2 branches missed.">        if (c == null) {</span>
            // usually checked in writeAndFlush, but we have extra check
            // because we need to release toSend.
<span class="nc" id="L574">            errorOut(completionKey);</span>
<span class="nc" id="L575">            toSend.release();</span>
<span class="nc" id="L576">            return;</span>
        } else {
<span class="fc" id="L578">            writeAndFlush(c, completionKey, request);</span>
        }
<span class="fc" id="L580">    }</span>

    public void readEntryAndFenceLedger(final long ledgerId, byte[] masterKey,
                                        final long entryId,
                                        ReadEntryCallback cb, Object ctx) {
<span class="nc" id="L585">        Object request = null;</span>
<span class="nc" id="L586">        CompletionKey completionKey = null;</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">        if (useV2WireProtocol) {</span>
<span class="nc" id="L588">            completionKey = acquireV2Key(ledgerId, entryId, OperationType.READ_ENTRY);</span>
<span class="nc" id="L589">            request = new BookieProtocol.ReadRequest(BookieProtocol.CURRENT_PROTOCOL_VERSION, ledgerId, entryId,</span>
                    BookieProtocol.FLAG_DO_FENCING, masterKey);
        } else {
<span class="nc" id="L592">            final long txnId = getTxnId();</span>
<span class="nc" id="L593">            completionKey = new V3CompletionKey(txnId, OperationType.READ_ENTRY);</span>

            // Build the request and calculate the total size to be included in the packet.
<span class="nc" id="L596">            BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()</span>
<span class="nc" id="L597">                    .setVersion(ProtocolVersion.VERSION_THREE)</span>
<span class="nc" id="L598">                    .setOperation(OperationType.READ_ENTRY)</span>
<span class="nc" id="L599">                    .setTxnId(txnId);</span>

<span class="nc" id="L601">            ReadRequest.Builder readBuilder = ReadRequest.newBuilder()</span>
<span class="nc" id="L602">                    .setLedgerId(ledgerId)</span>
<span class="nc" id="L603">                    .setEntryId(entryId)</span>
<span class="nc" id="L604">                    .setMasterKey(ByteString.copyFrom(masterKey))</span>
<span class="nc" id="L605">                    .setFlag(ReadRequest.Flag.FENCE_LEDGER);</span>

<span class="nc" id="L607">            request = Request.newBuilder()</span>
<span class="nc" id="L608">                    .setHeader(headerBuilder)</span>
<span class="nc" id="L609">                    .setReadRequest(readBuilder)</span>
<span class="nc" id="L610">                    .build();</span>
        }

<span class="nc" id="L613">        CompletionValue completion = new ReadCompletion(completionKey,</span>
                                                        cb, ctx,
                                                        ledgerId, entryId);
<span class="nc bnc" id="L616" title="All 2 branches missed.">        if (completionObjects.putIfAbsent(</span>
                    completionKey, completion) != null) {
            // We cannot have more than 1 pending read on the same ledger/entry in the v2 protocol
<span class="nc" id="L619">            completion.errorOut(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc" id="L620">            return;</span>
        }

<span class="nc" id="L623">        writeAndFlush(channel, completionKey, request);</span>
<span class="nc" id="L624">    }</span>

    public void readLac(final long ledgerId, ReadLacCallback cb, Object ctx) {
<span class="nc" id="L627">        Object request = null;</span>
<span class="nc" id="L628">        CompletionKey completionKey = null;</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">        if (useV2WireProtocol) {</span>
<span class="nc" id="L630">            request = new BookieProtocol.ReadRequest(BookieProtocol.CURRENT_PROTOCOL_VERSION,</span>
                    ledgerId, 0, (short) 0);
<span class="nc" id="L632">            completionKey = acquireV2Key(ledgerId, 0, OperationType.READ_LAC);</span>
        } else {
<span class="nc" id="L634">            final long txnId = getTxnId();</span>
<span class="nc" id="L635">            completionKey = new V3CompletionKey(txnId, OperationType.READ_LAC);</span>

            // Build the request and calculate the total size to be included in the packet.
<span class="nc" id="L638">            BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()</span>
<span class="nc" id="L639">                    .setVersion(ProtocolVersion.VERSION_THREE)</span>
<span class="nc" id="L640">                    .setOperation(OperationType.READ_LAC)</span>
<span class="nc" id="L641">                    .setTxnId(txnId);</span>
<span class="nc" id="L642">            ReadLacRequest.Builder readLacBuilder = ReadLacRequest.newBuilder()</span>
<span class="nc" id="L643">                    .setLedgerId(ledgerId);</span>
<span class="nc" id="L644">            request = Request.newBuilder()</span>
<span class="nc" id="L645">                    .setHeader(headerBuilder)</span>
<span class="nc" id="L646">                    .setReadLacRequest(readLacBuilder)</span>
<span class="nc" id="L647">                    .build();</span>
        }
<span class="nc" id="L649">        completionObjects.put(completionKey,</span>
                              new ReadLacCompletion(completionKey, cb,
                                                    ctx, ledgerId));
<span class="nc" id="L652">        writeAndFlush(channel, completionKey, request);</span>
<span class="nc" id="L653">    }</span>

    /**
     * Long Poll Reads
     */
    public void readEntryWaitForLACUpdate(final long ledgerId,
                                          final long entryId,
                                          final long previousLAC,
                                          final long timeOutInMillis,
                                          final boolean piggyBackEntry,
                                          ReadEntryCallback cb,
                                          Object ctx) {
<span class="nc" id="L665">        readEntryInternal(ledgerId, entryId, previousLAC, timeOutInMillis, piggyBackEntry, cb, ctx);</span>
<span class="nc" id="L666">    }</span>

    /**
     * Normal Reads.
     */
    public void readEntry(final long ledgerId,
                          final long entryId,
                          ReadEntryCallback cb,
                          Object ctx) {
<span class="fc" id="L675">        readEntryInternal(ledgerId, entryId, null, null, false, cb, ctx);</span>
<span class="fc" id="L676">    }</span>

    private void readEntryInternal(final long ledgerId,
                                   final long entryId,
                                   final Long previousLAC,
                                   final Long timeOutInMillis,
                                   final boolean piggyBackEntry,
                                   final ReadEntryCallback cb,
                                   final Object ctx) {
<span class="fc" id="L685">        Object request = null;</span>
<span class="fc" id="L686">        CompletionKey completionKey = null;</span>
<span class="pc bpc" id="L687" title="1 of 2 branches missed.">        if (useV2WireProtocol) {</span>
<span class="nc" id="L688">            request = new BookieProtocol.ReadRequest(BookieProtocol.CURRENT_PROTOCOL_VERSION,</span>
                    ledgerId, entryId, (short) 0);
<span class="nc" id="L690">            completionKey = acquireV2Key(ledgerId, entryId, OperationType.READ_ENTRY);</span>
        } else {
<span class="fc" id="L692">            final long txnId = getTxnId();</span>
<span class="fc" id="L693">            completionKey = new V3CompletionKey(txnId, OperationType.READ_ENTRY);</span>

            // Build the request and calculate the total size to be included in the packet.
<span class="fc" id="L696">            BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()</span>
<span class="fc" id="L697">                    .setVersion(ProtocolVersion.VERSION_THREE)</span>
<span class="fc" id="L698">                    .setOperation(OperationType.READ_ENTRY)</span>
<span class="fc" id="L699">                    .setTxnId(txnId);</span>

<span class="fc" id="L701">            ReadRequest.Builder readBuilder = ReadRequest.newBuilder()</span>
<span class="fc" id="L702">                    .setLedgerId(ledgerId)</span>
<span class="fc" id="L703">                    .setEntryId(entryId);</span>

<span class="pc bpc" id="L705" title="1 of 2 branches missed.">            if (null != previousLAC) {</span>
<span class="nc" id="L706">                readBuilder = readBuilder.setPreviousLAC(previousLAC);</span>
            }

<span class="pc bpc" id="L709" title="1 of 2 branches missed.">            if (null != timeOutInMillis) {</span>
                // Long poll requires previousLAC
<span class="nc bnc" id="L711" title="All 2 branches missed.">                if (null == previousLAC) {</span>
<span class="nc" id="L712">                    cb.readEntryComplete(BKException.Code.IncorrectParameterException,</span>
                        ledgerId, entryId, null, ctx);
<span class="nc" id="L714">                    return;</span>
                }
<span class="nc" id="L716">                readBuilder = readBuilder.setTimeOut(timeOutInMillis);</span>
            }

<span class="pc bpc" id="L719" title="1 of 2 branches missed.">            if (piggyBackEntry) {</span>
                // Long poll requires previousLAC
<span class="nc bnc" id="L721" title="All 2 branches missed.">                if (null == previousLAC) {</span>
<span class="nc" id="L722">                    cb.readEntryComplete(BKException.Code.IncorrectParameterException,</span>
                        ledgerId, entryId, null, ctx);
<span class="nc" id="L724">                    return;</span>
                }
<span class="nc" id="L726">                readBuilder = readBuilder.setFlag(ReadRequest.Flag.ENTRY_PIGGYBACK);</span>
            }

<span class="fc" id="L729">            request = Request.newBuilder()</span>
<span class="fc" id="L730">                    .setHeader(headerBuilder)</span>
<span class="fc" id="L731">                    .setReadRequest(readBuilder)</span>
<span class="fc" id="L732">                    .build();</span>
        }

<span class="fc" id="L735">        CompletionValue completion = new ReadCompletion(completionKey, cb,</span>
                                                        ctx, ledgerId, entryId);
<span class="fc" id="L737">        CompletionValue existingValue = completionObjects.putIfAbsent(</span>
                completionKey, completion);
<span class="pc bpc" id="L739" title="1 of 2 branches missed.">        if (existingValue != null) {</span>
            // There's a pending read request on same ledger/entry. This is not supported in V2 protocol
<span class="nc" id="L741">            LOG.warn(&quot;Failing concurrent request to read at ledger: {} entry: {}&quot;, ledgerId, entryId);</span>
<span class="nc" id="L742">            completion.errorOut(BKException.Code.UnexpectedConditionException);</span>
<span class="nc" id="L743">            return;</span>
        }

<span class="fc" id="L746">        writeAndFlush(channel, completionKey, request);</span>
<span class="fc" id="L747">    }</span>

    public void getBookieInfo(final long requested, GetBookieInfoCallback cb, Object ctx) {
<span class="nc" id="L750">        final long txnId = getTxnId();</span>
<span class="nc" id="L751">        final CompletionKey completionKey = new V3CompletionKey(txnId, OperationType.GET_BOOKIE_INFO);</span>
<span class="nc" id="L752">        completionObjects.put(completionKey,</span>
                              new GetBookieInfoCompletion(
                                      completionKey, cb, ctx));

        // Build the request and calculate the total size to be included in the packet.
<span class="nc" id="L757">        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()</span>
<span class="nc" id="L758">                .setVersion(ProtocolVersion.VERSION_THREE)</span>
<span class="nc" id="L759">                .setOperation(OperationType.GET_BOOKIE_INFO)</span>
<span class="nc" id="L760">                .setTxnId(txnId);</span>

<span class="nc" id="L762">        GetBookieInfoRequest.Builder getBookieInfoBuilder = GetBookieInfoRequest.newBuilder()</span>
<span class="nc" id="L763">                .setRequested(requested);</span>

<span class="nc" id="L765">        final Request getBookieInfoRequest = Request.newBuilder()</span>
<span class="nc" id="L766">                .setHeader(headerBuilder)</span>
<span class="nc" id="L767">                .setGetBookieInfoRequest(getBookieInfoBuilder)</span>
<span class="nc" id="L768">                .build();</span>

<span class="nc" id="L770">        writeAndFlush(channel, completionKey, getBookieInfoRequest);</span>
<span class="nc" id="L771">    }</span>

    /**
     * Disconnects the bookie client. It can be reused.
     */
    public void disconnect() {
<span class="nc" id="L777">        disconnect(true);</span>
<span class="nc" id="L778">    }</span>

    public void disconnect(boolean wait) {
<span class="nc" id="L781">        LOG.info(&quot;Disconnecting the per channel bookie client for {}&quot;, addr);</span>
<span class="nc" id="L782">        closeInternal(false, wait);</span>
<span class="nc" id="L783">    }</span>

    /**
     * Closes the bookie client permanently. It cannot be reused.
     */
    public void close() {
<span class="nc" id="L789">        close(true);</span>
<span class="nc" id="L790">    }</span>

    public void close(boolean wait) {
<span class="fc" id="L793">        LOG.info(&quot;Closing the per channel bookie client for {}&quot;, addr);</span>
<span class="fc" id="L794">        closeLock.writeLock().lock();</span>
        try {
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">            if (ConnectionState.CLOSED == state) {</span>
<span class="nc" id="L797">                return;</span>
            }
<span class="fc" id="L799">            state = ConnectionState.CLOSED;</span>
<span class="fc" id="L800">            errorOutOutstandingEntries(BKException.Code.ClientClosedException);</span>
        } finally {
<span class="fc" id="L802">            closeLock.writeLock().unlock();</span>
        }
<span class="fc" id="L804">        closeInternal(true, wait);</span>
<span class="fc" id="L805">    }</span>

    private void closeInternal(boolean permanent, boolean wait) {
<span class="fc" id="L808">        Channel toClose = null;</span>
<span class="fc" id="L809">        synchronized (this) {</span>
<span class="pc bpc" id="L810" title="1 of 2 branches missed.">            if (permanent) {</span>
<span class="fc" id="L811">                state = ConnectionState.CLOSED;</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">            } else if (state != ConnectionState.CLOSED) {</span>
<span class="nc" id="L813">                state = ConnectionState.DISCONNECTED;</span>
            }
<span class="fc" id="L815">            toClose = channel;</span>
<span class="fc" id="L816">            channel = null;</span>
<span class="fc" id="L817">        }</span>
<span class="pc bpc" id="L818" title="1 of 2 branches missed.">        if (toClose != null) {</span>
<span class="fc" id="L819">            ChannelFuture cf = closeChannel(toClose);</span>
<span class="pc bpc" id="L820" title="1 of 2 branches missed.">            if (wait) {</span>
<span class="fc" id="L821">                cf.awaitUninterruptibly();</span>
            }
        }
<span class="fc" id="L824">    }</span>

    private ChannelFuture closeChannel(Channel c) {
<span class="pc bpc" id="L827" title="1 of 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L828">            LOG.debug(&quot;Closing channel {}&quot;, c);</span>
        }
<span class="fc" id="L830">        return c.close();</span>
    }

    private void writeAndFlush(final Channel channel,
                               final CompletionKey key,
                               final Object request) {
<span class="pc bpc" id="L836" title="1 of 2 branches missed.">        if (channel == null) {</span>
<span class="nc" id="L837">            errorOut(key);</span>
<span class="nc" id="L838">            return;</span>
        }

        try{
<span class="fc" id="L842">            channel.writeAndFlush(request, channel.voidPromise());</span>
<span class="nc" id="L843">        } catch(Throwable e) {</span>
<span class="nc" id="L844">            LOG.warn(&quot;Operation {} failed&quot;, requestToString(request), e);</span>
<span class="nc" id="L845">            errorOut(key);</span>
<span class="fc" id="L846">        }</span>
<span class="fc" id="L847">    }</span>

    private static String requestToString(Object request) {
<span class="nc bnc" id="L850" title="All 2 branches missed.">        if (request instanceof BookkeeperProtocol.Request) {</span>
<span class="nc" id="L851">            BookkeeperProtocol.BKPacketHeader header</span>
<span class="nc" id="L852">                = ((BookkeeperProtocol.Request)request).getHeader();</span>
<span class="nc" id="L853">            return String.format(&quot;Req(txnId=%d,op=%s,version=%s)&quot;,</span>
<span class="nc" id="L854">                                 header.getTxnId(), header.getOperation(),</span>
<span class="nc" id="L855">                                 header.getVersion());</span>
        } else {
<span class="nc" id="L857">            return request.toString();</span>
        }
    }

    void errorOut(final CompletionKey key) {
<span class="nc bnc" id="L862" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L863">            LOG.debug(&quot;Removing completion key: {}&quot;, key);</span>
        }
<span class="nc" id="L865">        CompletionValue completion = completionObjects.remove(key);</span>
<span class="nc bnc" id="L866" title="All 2 branches missed.">        if (completion != null) {</span>
<span class="nc" id="L867">            completion.errorOut();</span>
        }
<span class="nc" id="L869">    }</span>

    void errorOut(final CompletionKey key, final int rc) {
<span class="nc bnc" id="L872" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L873">            LOG.debug(&quot;Removing completion key: {}&quot;, key);</span>
        }
<span class="nc" id="L875">        CompletionValue completion = completionObjects.remove(key);</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">        if (completion != null) {</span>
<span class="nc" id="L877">            completion.errorOut(rc);</span>
        }
<span class="nc" id="L879">    }</span>

    /**
     * Errors out pending entries. We call this method from one thread to avoid
     * concurrent executions to QuorumOpMonitor (implements callbacks). It seems
     * simpler to call it from BookieHandle instead of calling directly from
     * here.
     */

    void errorOutOutstandingEntries(int rc) {

        // DO NOT rewrite these using Map.Entry iterations. We want to iterate
        // on keys and see if we are successfully able to remove the key from
        // the map. Because the add and the read methods also do the same thing
        // in case they get a write failure on the socket. The one who
        // successfully removes the key from the map is the one responsible for
        // calling the application callback.
<span class="pc bpc" id="L896" title="1 of 2 branches missed.">        for (CompletionKey key : completionObjects.keySet()) {</span>
<span class="nc" id="L897">            errorOut(key, rc);</span>
<span class="nc" id="L898">        }</span>
<span class="fc" id="L899">    }</span>

    void recordError() {
<span class="nc bnc" id="L902" title="All 2 branches missed.">        if (pcbcPool != null) {</span>
<span class="nc" id="L903">            pcbcPool.recordError();</span>
        }
<span class="nc" id="L905">    }</span>

    /**
     * If our channel has disconnected, we just error out the pending entries
     */
    @Override
    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
<span class="fc" id="L912">        LOG.info(&quot;Disconnected from bookie channel {}&quot;, ctx.channel());</span>
<span class="pc bpc" id="L913" title="1 of 2 branches missed.">        if (ctx.channel() != null) {</span>
<span class="fc" id="L914">            closeChannel(ctx.channel());</span>
        }

<span class="fc" id="L917">        errorOutOutstandingEntries(BKException.Code.BookieHandleNotAvailableException);</span>

<span class="fc" id="L919">        synchronized (this) {</span>
<span class="pc bpc" id="L920" title="3 of 4 branches missed.">            if (this.channel == ctx.channel()</span>
                &amp;&amp; state != ConnectionState.CLOSED) {
<span class="nc" id="L922">                state = ConnectionState.DISCONNECTED;</span>
            }
<span class="fc" id="L924">        }</span>

        // we don't want to reconnect right away. If someone sends a request to
        // this address, we will reconnect.
<span class="fc" id="L928">    }</span>

    /**
     * Called by netty when an exception happens in one of the netty threads
     * (mostly due to what we do in the netty threads)
     */
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
<span class="nc bnc" id="L936" title="All 4 branches missed.">        if (cause instanceof CorruptedFrameException || cause instanceof TooLongFrameException) {</span>
<span class="nc" id="L937">            LOG.error(&quot;Corrupted frame received from bookie: {}&quot;, ctx.channel().remoteAddress());</span>
<span class="nc" id="L938">            ctx.close();</span>
<span class="nc" id="L939">            return;</span>
        }

<span class="nc bnc" id="L942" title="All 2 branches missed.">        if (cause instanceof AuthHandler.AuthenticationException) {</span>
<span class="nc" id="L943">            LOG.error(&quot;Error authenticating connection&quot;, cause);</span>
<span class="nc" id="L944">            errorOutOutstandingEntries(BKException.Code.UnauthorizedAccessException);</span>
<span class="nc" id="L945">            Channel c = ctx.channel();</span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">            if (c != null) {</span>
<span class="nc" id="L947">                closeChannel(c);</span>
            }
<span class="nc" id="L949">            return;</span>
        }

<span class="nc bnc" id="L952" title="All 2 branches missed.">        if (cause instanceof IOException) {</span>
            // these are thrown when a bookie fails, logging them just pollutes
            // the logs (the failure is logged from the listeners on the write
            // operation), so I'll just ignore it here.
<span class="nc" id="L956">            ctx.close();</span>
<span class="nc" id="L957">            return;</span>
        }

<span class="nc" id="L960">        synchronized (this) {</span>
<span class="nc bnc" id="L961" title="All 2 branches missed.">            if (state == ConnectionState.CLOSED) {</span>
<span class="nc bnc" id="L962" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L963">                    LOG.debug(&quot;Unexpected exception caught by bookie client channel handler, &quot;</span>
                            + &quot;but the client is closed, so it isn't important&quot;, cause);
                }
            } else {
<span class="nc" id="L967">                LOG.error(&quot;Unexpected exception caught by bookie client channel handler&quot;, cause);</span>
            }
<span class="nc" id="L969">        }</span>

        // Since we are a library, cant terminate App here, can we?
<span class="nc" id="L972">        ctx.close();</span>
<span class="nc" id="L973">    }</span>

    /**
     * Called by netty when a message is received on a channel
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {

<span class="pc bpc" id="L981" title="1 of 2 branches missed.">        if (msg instanceof BookieProtocol.Response) {</span>
<span class="nc" id="L982">            BookieProtocol.Response response = (BookieProtocol.Response) msg;</span>
<span class="nc" id="L983">            readV2Response(response);</span>
<span class="pc bpc" id="L984" title="1 of 2 branches missed.">        } else if (msg instanceof Response) {</span>
<span class="fc" id="L985">            Response response = (Response) msg;</span>
<span class="fc" id="L986">            readV3Response(response);</span>
<span class="fc" id="L987">        } else {</span>
<span class="nc" id="L988">            ctx.fireChannelRead(msg);</span>
        }
<span class="fc" id="L990">    }</span>

    private void readV2Response(final BookieProtocol.Response response) {
<span class="nc" id="L993">        final long ledgerId = response.ledgerId;</span>
<span class="nc" id="L994">        final long entryId = response.entryId;</span>

<span class="nc" id="L996">        final OperationType operationType = getOperationType(response.getOpCode());</span>
<span class="nc" id="L997">        final StatusCode status = getStatusCodeFromErrorCode(response.errorCode);</span>

<span class="nc" id="L999">        final CompletionKey key = acquireV2Key(ledgerId, entryId, operationType);</span>
<span class="nc" id="L1000">        final CompletionValue completionValue = completionObjects.remove(key);</span>
<span class="nc" id="L1001">        key.release();</span>

<span class="nc bnc" id="L1003" title="All 2 branches missed.">        if (null == completionValue) {</span>
            // Unexpected response, so log it. The txnId should have been present.
<span class="nc bnc" id="L1005" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1006">                LOG.debug(&quot;Unexpected response received from bookie : &quot; + addr + &quot; for type : &quot; + operationType</span>
                        + &quot; and ledger:entry : &quot; + ledgerId + &quot;:&quot; + entryId);
            }
        } else {
<span class="nc" id="L1010">            long orderingKey = completionValue.ledgerId;</span>

<span class="nc" id="L1012">            executor.submitOrdered(orderingKey, new SafeRunnable() {</span>
                    @Override
                    public void safeRun() {
<span class="nc" id="L1015">                        completionValue.handleV2Response(ledgerId, entryId,</span>
                                                         status, response);
<span class="nc" id="L1017">                        response.recycle();</span>
<span class="nc" id="L1018">                    }</span>
                });
        }
<span class="nc" id="L1021">    }</span>

    private StatusCode getStatusCodeFromErrorCode(int errorCode) {
<span class="nc bnc" id="L1024" title="All 11 branches missed.">        switch (errorCode) {</span>
            case BookieProtocol.EOK:
<span class="nc" id="L1026">                return StatusCode.EOK;</span>
            case BookieProtocol.ENOLEDGER:
<span class="nc" id="L1028">                return StatusCode.ENOLEDGER;</span>
            case BookieProtocol.ENOENTRY:
<span class="nc" id="L1030">                return StatusCode.ENOENTRY;</span>
            case BookieProtocol.EBADREQ:
<span class="nc" id="L1032">                return StatusCode.EBADREQ;</span>
            case BookieProtocol.EIO:
<span class="nc" id="L1034">                return StatusCode.EIO;</span>
            case BookieProtocol.EUA:
<span class="nc" id="L1036">                return StatusCode.EUA;</span>
            case BookieProtocol.EBADVERSION:
<span class="nc" id="L1038">                return StatusCode.EBADVERSION;</span>
            case BookieProtocol.EFENCED:
<span class="nc" id="L1040">                return StatusCode.EFENCED;</span>
            case BookieProtocol.EREADONLY:
<span class="nc" id="L1042">                return StatusCode.EREADONLY;</span>
            case BookieProtocol.ETOOMANYREQUESTS:
<span class="nc" id="L1044">                return StatusCode.ETOOMANYREQUESTS;</span>
            default:
<span class="nc" id="L1046">                throw new IllegalArgumentException(&quot;Invalid error code: &quot; + errorCode);</span>
        }
    }

    private OperationType getOperationType(byte opCode) {
<span class="nc bnc" id="L1051" title="All 7 branches missed.">        switch (opCode) {</span>
            case BookieProtocol.ADDENTRY:
<span class="nc" id="L1053">                return  OperationType.ADD_ENTRY;</span>
            case BookieProtocol.READENTRY:
<span class="nc" id="L1055">                return OperationType.READ_ENTRY;</span>
            case BookieProtocol.AUTH:
<span class="nc" id="L1057">                return OperationType.AUTH;</span>
            case BookieProtocol.READ_LAC:
<span class="nc" id="L1059">                return OperationType.READ_LAC;</span>
            case BookieProtocol.WRITE_LAC:
<span class="nc" id="L1061">                return OperationType.WRITE_LAC;</span>
            case BookieProtocol.GET_BOOKIE_INFO:
<span class="nc" id="L1063">                return OperationType.GET_BOOKIE_INFO;</span>
            default:
<span class="nc" id="L1065">                throw new IllegalArgumentException(&quot;Invalid operation type&quot;);</span>
        }
    }

    private void readV3Response(final Response response) {
<span class="fc" id="L1070">        final BKPacketHeader header = response.getHeader();</span>

<span class="fc" id="L1072">        final CompletionValue completionValue = completionObjects.remove(newCompletionKey(header.getTxnId(),</span>
<span class="fc" id="L1073">                header.getOperation()));</span>

<span class="pc bpc" id="L1075" title="1 of 2 branches missed.">        if (null == completionValue) {</span>
            // Unexpected response, so log it. The txnId should have been present.
<span class="nc bnc" id="L1077" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1078">                LOG.debug(&quot;Unexpected response received from bookie : &quot; + addr + &quot; for type : &quot;</span>
<span class="nc" id="L1079">                        + header.getOperation() + &quot; and txnId : &quot; + header.getTxnId());</span>
            }
        } else {
<span class="fc" id="L1082">            long orderingKey = completionValue.ledgerId;</span>
<span class="fc" id="L1083">            executor.submitOrdered(orderingKey, new SafeRunnable() {</span>
                @Override
                public void safeRun() {
<span class="fc" id="L1086">                    completionValue.handleV3Response(response);</span>
<span class="fc" id="L1087">                }</span>

                @Override
                public String toString() {
<span class="nc" id="L1091">                    return String.format(&quot;HandleResponse(Txn=%d, Type=%s, Entry=(%d, %d))&quot;,</span>
<span class="nc" id="L1092">                                         header.getTxnId(), header.getOperation(),</span>
<span class="nc" id="L1093">                                         completionValue.ledgerId, completionValue.entryId);</span>
                }
            });
        }
<span class="fc" id="L1097">    }</span>

    void initTLSHandshake() {
        // create TLS handler
<span class="nc" id="L1101">        PerChannelBookieClient parentObj = PerChannelBookieClient.this;</span>
<span class="nc" id="L1102">        SslHandler handler = parentObj.shFactory.newTLSHandler();</span>
<span class="nc" id="L1103">        channel.pipeline().addFirst(parentObj.shFactory.getHandlerName(), handler);</span>
<span class="nc" id="L1104">        handler.handshakeFuture().addListener(new GenericFutureListener&lt;Future&lt;Channel&gt;&gt;() {</span>
                @Override
                public void operationComplete(Future&lt;Channel&gt; future) throws Exception {
                    int rc;
                    Queue&lt;GenericCallback&lt;PerChannelBookieClient&gt;&gt; oldPendingOps;

<span class="nc" id="L1110">                    synchronized (PerChannelBookieClient.this) {</span>
<span class="nc bnc" id="L1111" title="All 4 branches missed.">                        if (future.isSuccess() &amp;&amp; state == ConnectionState.CONNECTING) {</span>
<span class="nc" id="L1112">                            LOG.error(&quot;Connection state changed before TLS handshake completed {}/{}&quot;, addr, state);</span>
<span class="nc" id="L1113">                            rc = BKException.Code.BookieHandleNotAvailableException;</span>
<span class="nc" id="L1114">                            closeChannel(future.get());</span>
<span class="nc" id="L1115">                            channel = null;</span>
<span class="nc bnc" id="L1116" title="All 2 branches missed.">                            if (state != ConnectionState.CLOSED) {</span>
<span class="nc" id="L1117">                                state = ConnectionState.DISCONNECTED;</span>
                            }
<span class="nc bnc" id="L1119" title="All 4 branches missed.">                        } else if (future.isSuccess() &amp;&amp; state == ConnectionState.START_TLS) {</span>
<span class="nc" id="L1120">                            rc = BKException.Code.OK;</span>
<span class="nc" id="L1121">                            LOG.info(&quot;Successfully connected to bookie using TLS: &quot; + addr);</span>

<span class="nc" id="L1123">                            state = ConnectionState.CONNECTED;</span>
<span class="nc" id="L1124">                            AuthHandler.ClientSideHandler authHandler = future.get().pipeline()</span>
<span class="nc" id="L1125">                                    .get(AuthHandler.ClientSideHandler.class);</span>
<span class="nc" id="L1126">                            authHandler.authProvider.onProtocolUpgrade();</span>
<span class="nc bnc" id="L1127" title="All 6 branches missed.">                        } else if (future.isSuccess()</span>
                                &amp;&amp; (state == ConnectionState.CLOSED || state == ConnectionState.DISCONNECTED)) {
<span class="nc" id="L1129">                            LOG.warn(&quot;Closed before TLS handshake completed, clean up: {}, current state {}&quot;,</span>
<span class="nc" id="L1130">                                    future.get(), state);</span>
<span class="nc" id="L1131">                            closeChannel(future.get());</span>
<span class="nc" id="L1132">                            rc = BKException.Code.BookieHandleNotAvailableException;</span>
<span class="nc" id="L1133">                            channel = null;</span>
<span class="nc bnc" id="L1134" title="All 4 branches missed.">                        } else if (future.isSuccess() &amp;&amp; state == ConnectionState.CONNECTED) {</span>
<span class="nc" id="L1135">                            LOG.debug(&quot;Already connected with another channel({}), so close the new channel({})&quot;,</span>
<span class="nc" id="L1136">                                    channel, future.get());</span>
<span class="nc" id="L1137">                            closeChannel(future.get());</span>
<span class="nc" id="L1138">                            return; // pendingOps should have been completed when other channel connected</span>
                        } else {
<span class="nc" id="L1140">                            LOG.error(&quot;TLS handshake failed with bookie: {}/{}, current state {} : &quot;,</span>
<span class="nc" id="L1141">                                    new Object[] { future.get(), addr, state, future.cause() });</span>
<span class="nc" id="L1142">                            rc = BKException.Code.SecurityException;</span>
<span class="nc" id="L1143">                            closeChannel(future.get());</span>
<span class="nc" id="L1144">                            channel = null;</span>
<span class="nc bnc" id="L1145" title="All 2 branches missed.">                            if (state != ConnectionState.CLOSED) {</span>
<span class="nc" id="L1146">                                state = ConnectionState.DISCONNECTED;</span>
                            }
                        }

                        // trick to not do operations under the lock, take the list
                        // of pending ops and assign it to a new variable, while
                        // emptying the pending ops by just assigning it to a new
                        // list
<span class="nc" id="L1154">                        oldPendingOps = pendingOps;</span>
<span class="nc" id="L1155">                        pendingOps = new ArrayDeque&lt;&gt;();</span>
<span class="nc" id="L1156">                    }</span>

<span class="nc bnc" id="L1158" title="All 2 branches missed.">                    for (GenericCallback&lt;PerChannelBookieClient&gt; pendingOp : oldPendingOps) {</span>
<span class="nc" id="L1159">                        pendingOp.operationComplete(rc, PerChannelBookieClient.this);</span>
<span class="nc" id="L1160">                    }</span>
<span class="nc" id="L1161">                }</span>
            });
<span class="nc" id="L1163">    }</span>

    /**
     * Boiler-plate wrapper classes follow
     *
     */

    // visible for testing
    abstract class CompletionValue {
        private final OpStatsLogger opLogger;
        private final OpStatsLogger timeoutOpLogger;
        private final String operationName;
        protected Object ctx;
        protected long ledgerId;
        protected long entryId;
        protected long startTime;
        protected Timeout timeout;

        public CompletionValue(String operationName,
                               Object ctx,
                               long ledgerId, long entryId,
                               OpStatsLogger opLogger,
                               OpStatsLogger timeoutOpLogger,
<span class="fc" id="L1186">                               Timeout timeout) {</span>
<span class="fc" id="L1187">            this.operationName = operationName;</span>
<span class="fc" id="L1188">            this.ctx = ctx;</span>
<span class="fc" id="L1189">            this.ledgerId = ledgerId;</span>
<span class="fc" id="L1190">            this.entryId = entryId;</span>
<span class="fc" id="L1191">            this.startTime = MathUtils.nowInNano();</span>
<span class="fc" id="L1192">            this.opLogger = opLogger;</span>
<span class="fc" id="L1193">            this.timeoutOpLogger = timeoutOpLogger;</span>
<span class="fc" id="L1194">            this.timeout = timeout;</span>
<span class="fc" id="L1195">        }</span>

        private long latency() {
<span class="fc" id="L1198">            return MathUtils.elapsedNanos(startTime);</span>
        }

        void cancelTimeoutAndLogOp(int rc) {
<span class="fc" id="L1202">            Timeout t = timeout;</span>
<span class="pc bpc" id="L1203" title="1 of 2 branches missed.">            if (null != t) {</span>
<span class="fc" id="L1204">                t.cancel();</span>
            }

<span class="pc bpc" id="L1207" title="1 of 2 branches missed.">            if (rc != BKException.Code.OK) {</span>
<span class="nc" id="L1208">                opLogger.registerFailedEvent(latency(), TimeUnit.NANOSECONDS);</span>
            } else {
<span class="fc" id="L1210">                opLogger.registerSuccessfulEvent(latency(), TimeUnit.NANOSECONDS);</span>
            }

<span class="pc bpc" id="L1213" title="1 of 2 branches missed.">            if (rc != BKException.Code.OK</span>
<span class="nc bnc" id="L1214" title="All 2 branches missed.">                &amp;&amp; !expectedBkOperationErrors.contains(rc)) {</span>
<span class="nc" id="L1215">                recordError();</span>
            }
<span class="fc" id="L1217">        }</span>

        void timeout() {
<span class="nc" id="L1220">            errorOut(BKException.Code.TimeoutException);</span>
<span class="nc" id="L1221">            timeoutOpLogger.registerSuccessfulEvent(latency(),</span>
                                                    TimeUnit.NANOSECONDS);
<span class="nc" id="L1223">        }</span>

        protected int logAndConvertStatus(StatusCode status, int defaultStatus,
                                          Object... extraInfo) {
<span class="pc bpc" id="L1227" title="1 of 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1228">                LOG.debug(&quot;Got {} response from bookie:{} rc:{}, {}&quot;,</span>
                          operationName, addr, status,
<span class="nc" id="L1230">                          Joiner.on(&quot;:&quot;).join(extraInfo));</span>
            }

            // convert to BKException code
<span class="fc" id="L1234">            Integer rcToRet = statusCodeToExceptionCode(status);</span>
<span class="pc bpc" id="L1235" title="1 of 2 branches missed.">            if (null == rcToRet) {</span>
<span class="nc" id="L1236">                LOG.error(&quot;{} for failed on bookie {} code {}&quot;,</span>
                          operationName, addr, status);
<span class="nc" id="L1238">                return defaultStatus;</span>
            } else {
<span class="fc" id="L1240">                return rcToRet;</span>
            }
        }


        public abstract void errorOut();
        public abstract void errorOut(final int rc);

        protected void errorOutAndRunCallback(final Runnable callback) {
<span class="nc" id="L1249">            executor.submitOrdered(ledgerId,</span>
<span class="nc" id="L1250">                    new SafeRunnable() {</span>
                        @Override
                        public void safeRun() {
<span class="nc" id="L1253">                            String bAddress = &quot;null&quot;;</span>
<span class="nc" id="L1254">                            Channel c = channel;</span>
<span class="nc bnc" id="L1255" title="All 4 branches missed.">                            if (c != null &amp;&amp; c.remoteAddress() != null) {</span>
<span class="nc" id="L1256">                                bAddress = c.remoteAddress().toString();</span>
                            }
<span class="nc bnc" id="L1258" title="All 2 branches missed.">                            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1259">                                LOG.debug(&quot;Could not write {} request to bookie {} for ledger {}, entry {}&quot;,</span>
<span class="nc" id="L1260">                                          operationName, bAddress,</span>
<span class="nc" id="L1261">                                          ledgerId, entryId);</span>
                            }
<span class="nc" id="L1263">                            callback.run();</span>
<span class="nc" id="L1264">                        }</span>
                    });
<span class="nc" id="L1266">        }</span>

        public void handleV2Response(
                long ledgerId, long entryId, StatusCode status,
                BookieProtocol.Response response) {
<span class="nc" id="L1271">            LOG.warn(&quot;Unhandled V2 response {}&quot;, response);</span>
<span class="nc" id="L1272">        }</span>

        public abstract void handleV3Response(
                BookkeeperProtocol.Response response);
    }

    // visible for testing
    class WriteLacCompletion extends CompletionValue {
        final WriteLacCallback cb;

        public WriteLacCompletion(final CompletionKey key,
                                  final WriteLacCallback originalCallback,
                                  final Object originalCtx,
<span class="nc" id="L1285">                                  final long ledgerId) {</span>
<span class="nc" id="L1286">            super(&quot;WriteLAC&quot;,</span>
                  originalCtx, ledgerId, BookieProtocol.LAST_ADD_CONFIRMED,
<span class="nc" id="L1288">                  writeLacOpLogger, writeLacTimeoutOpLogger,</span>
<span class="nc" id="L1289">                  scheduleTimeout(key, addEntryTimeout));</span>
<span class="nc" id="L1290">            this.cb = new WriteLacCallback() {</span>
                    @Override
                    public void writeLacComplete(int rc, long ledgerId,
                                                 BookieSocketAddress addr,
                                                 Object ctx) {
<span class="nc" id="L1295">                        cancelTimeoutAndLogOp(rc);</span>
<span class="nc" id="L1296">                        originalCallback.writeLacComplete(rc, ledgerId,</span>
                                                          addr, originalCtx);
<span class="nc" id="L1298">                        key.release();</span>
<span class="nc" id="L1299">                    }</span>
                };
<span class="nc" id="L1301">        }</span>

        @Override
        public void errorOut() {
<span class="nc" id="L1305">            errorOut(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc" id="L1306">        }</span>

        @Override
        public void errorOut(final int rc) {
<span class="nc" id="L1310">            errorOutAndRunCallback(</span>
<span class="nc" id="L1311">                    () -&gt; cb.writeLacComplete(rc, ledgerId, addr, ctx));</span>
<span class="nc" id="L1312">        }</span>

        @Override
        public void handleV3Response(BookkeeperProtocol.Response response) {
<span class="nc" id="L1316">            WriteLacResponse writeLacResponse = response.getWriteLacResponse();</span>
<span class="nc bnc" id="L1317" title="All 2 branches missed.">            StatusCode status = response.getStatus() == StatusCode.EOK ?</span>
<span class="nc" id="L1318">                writeLacResponse.getStatus() : response.getStatus();</span>
<span class="nc" id="L1319">            long ledgerId = writeLacResponse.getLedgerId();</span>

<span class="nc" id="L1321">            int rc = logAndConvertStatus(status,</span>
                                         BKException.Code.WriteException,
<span class="nc" id="L1323">                                         &quot;ledger&quot;, ledgerId);</span>
<span class="nc" id="L1324">            cb.writeLacComplete(rc, ledgerId, addr, ctx);</span>
<span class="nc" id="L1325">        }</span>
    }

    // visible for testing
    class ReadLacCompletion extends CompletionValue {
        final ReadLacCallback cb;

        public ReadLacCompletion(final CompletionKey key,
                                 ReadLacCallback originalCallback,
<span class="nc" id="L1334">                                 final Object ctx, final long ledgerId) {</span>
<span class="nc" id="L1335">            super(&quot;ReadLAC&quot;, ctx, ledgerId, BookieProtocol.LAST_ADD_CONFIRMED,</span>
<span class="nc" id="L1336">                  readLacOpLogger, readLacTimeoutOpLogger,</span>
<span class="nc" id="L1337">                  scheduleTimeout(key, readEntryTimeout));</span>
<span class="nc" id="L1338">            this.cb = new ReadLacCallback() {</span>
                    @Override
                    public void readLacComplete(int rc, long ledgerId,
                                                ByteBuf lacBuffer,
                                                ByteBuf lastEntryBuffer,
                                                Object ctx) {
<span class="nc" id="L1344">                        cancelTimeoutAndLogOp(rc);</span>
<span class="nc" id="L1345">                        originalCallback.readLacComplete(</span>
                                rc, ledgerId, lacBuffer, lastEntryBuffer, ctx);
<span class="nc" id="L1347">                        key.release();</span>
<span class="nc" id="L1348">                    }</span>
                };
<span class="nc" id="L1350">        }</span>

        @Override
        public void errorOut() {
<span class="nc" id="L1354">            errorOut(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc" id="L1355">        }</span>

        @Override
        public void errorOut(final int rc) {
<span class="nc" id="L1359">            errorOutAndRunCallback(</span>
<span class="nc" id="L1360">                    () -&gt; cb.readLacComplete(rc, ledgerId, null, null, ctx));</span>
<span class="nc" id="L1361">        }</span>

        @Override
        public void handleV3Response(BookkeeperProtocol.Response response) {
<span class="nc" id="L1365">            ReadLacResponse readLacResponse = response.getReadLacResponse();</span>
<span class="nc" id="L1366">            ByteBuf lacBuffer = Unpooled.EMPTY_BUFFER;</span>
<span class="nc" id="L1367">            ByteBuf lastEntryBuffer = Unpooled.EMPTY_BUFFER;</span>
<span class="nc bnc" id="L1368" title="All 2 branches missed.">            StatusCode status = response.getStatus() == StatusCode.EOK ? readLacResponse.getStatus() : response.getStatus();</span>

<span class="nc bnc" id="L1370" title="All 2 branches missed.">            if (readLacResponse.hasLacBody()) {</span>
<span class="nc" id="L1371">                lacBuffer = Unpooled.wrappedBuffer(readLacResponse.getLacBody().asReadOnlyByteBuffer());</span>
            }

<span class="nc bnc" id="L1374" title="All 2 branches missed.">            if (readLacResponse.hasLastEntryBody()) {</span>
<span class="nc" id="L1375">                lastEntryBuffer = Unpooled.wrappedBuffer(readLacResponse.getLastEntryBody().asReadOnlyByteBuffer());</span>
            }

<span class="nc" id="L1378">            int rc = logAndConvertStatus(status,</span>
                                         BKException.Code.ReadException,
<span class="nc" id="L1380">                                         &quot;ledger&quot;, ledgerId);</span>
<span class="nc" id="L1381">            cb.readLacComplete(rc, ledgerId, lacBuffer.slice(),</span>
<span class="nc" id="L1382">                               lastEntryBuffer.slice(), ctx);</span>
<span class="nc" id="L1383">        }</span>
    }

    // visible for testing
    class ReadCompletion extends CompletionValue {
        final ReadEntryCallback cb;

        public ReadCompletion(final CompletionKey key,
                              final ReadEntryCallback originalCallback,
                              final Object originalCtx,
<span class="fc" id="L1393">                              long ledgerId, final long entryId) {</span>
<span class="fc" id="L1394">            super(&quot;Read&quot;, originalCtx, ledgerId, entryId,</span>
<span class="fc" id="L1395">                  readEntryOpLogger, readTimeoutOpLogger,</span>
<span class="fc" id="L1396">                  scheduleTimeout(key, readEntryTimeout));</span>

<span class="fc" id="L1398">            this.cb = new ReadEntryCallback() {</span>
                    @Override
                    public void readEntryComplete(int rc, long ledgerId,
                                                  long entryId, ByteBuf buffer,
                                                  Object ctx) {
<span class="fc" id="L1403">                        cancelTimeoutAndLogOp(rc);</span>
<span class="fc" id="L1404">                        originalCallback.readEntryComplete(rc,</span>
                                                           ledgerId, entryId,
                                                           buffer, originalCtx);
<span class="fc" id="L1407">                        key.release();</span>
<span class="fc" id="L1408">                    }</span>
                };
<span class="fc" id="L1410">        }</span>

        @Override
        public void errorOut() {
<span class="nc" id="L1414">            errorOut(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc" id="L1415">        }</span>

        @Override
        public void errorOut(final int rc) {
<span class="nc" id="L1419">            errorOutAndRunCallback(</span>
<span class="nc" id="L1420">                    () -&gt; cb.readEntryComplete(rc, ledgerId,</span>
                                               entryId, null, ctx));
<span class="nc" id="L1422">        }</span>

        @Override
        public void handleV2Response(long ledgerId, long entryId,
                                     StatusCode status,
                                     BookieProtocol.Response response) {
<span class="nc bnc" id="L1428" title="All 2 branches missed.">            if (!(response instanceof BookieProtocol.ReadResponse)) {</span>
<span class="nc" id="L1429">                return;</span>
            }
<span class="nc" id="L1431">            BookieProtocol.ReadResponse readResponse = (BookieProtocol.ReadResponse) response;</span>
<span class="nc" id="L1432">            ByteBuf data = null;</span>
<span class="nc bnc" id="L1433" title="All 2 branches missed.">            if (readResponse.hasData()) {</span>
<span class="nc" id="L1434">                data = readResponse.getData();</span>
            }
<span class="nc" id="L1436">            handleReadResponse(ledgerId, entryId, status, data,</span>
                               INVALID_ENTRY_ID, -1L);
<span class="nc" id="L1438">        }</span>

        @Override
        public void handleV3Response(BookkeeperProtocol.Response response) {
<span class="fc" id="L1442">            ReadResponse readResponse = response.getReadResponse();</span>
<span class="pc bpc" id="L1443" title="1 of 2 branches missed.">            StatusCode status = response.getStatus() == StatusCode.EOK</span>
<span class="pc" id="L1444">                ? readResponse.getStatus() : response.getStatus();</span>
<span class="fc" id="L1445">            ByteBuf buffer = Unpooled.EMPTY_BUFFER;</span>
<span class="pc bpc" id="L1446" title="1 of 2 branches missed.">            if (readResponse.hasBody()) {</span>
<span class="fc" id="L1447">                buffer = Unpooled.wrappedBuffer(readResponse.getBody().asReadOnlyByteBuffer());</span>
            }
<span class="fc" id="L1449">            long maxLAC = INVALID_ENTRY_ID;</span>
<span class="pc bpc" id="L1450" title="1 of 2 branches missed.">            if (readResponse.hasMaxLAC()) {</span>
<span class="fc" id="L1451">                maxLAC = readResponse.getMaxLAC();</span>
            }
<span class="fc" id="L1453">            long lacUpdateTimestamp = -1L;</span>
<span class="pc bpc" id="L1454" title="1 of 2 branches missed.">            if (readResponse.hasLacUpdateTimestamp()) {</span>
<span class="nc" id="L1455">                lacUpdateTimestamp = readResponse.getLacUpdateTimestamp();</span>
            }
<span class="fc" id="L1457">            handleReadResponse(readResponse.getLedgerId(),</span>
<span class="fc" id="L1458">                               readResponse.getEntryId(),</span>
                               status, buffer, maxLAC, lacUpdateTimestamp);
<span class="fc" id="L1460">        }</span>

        private void handleReadResponse(long ledgerId,
                                        long entryId,
                                        StatusCode status,
                                        ByteBuf buffer,
                                        long maxLAC, // max known lac piggy-back from bookies
                                        long lacUpdateTimestamp) { // the timestamp when the lac is updated.
<span class="pc bpc" id="L1468" title="1 of 2 branches missed.">            int readableBytes = buffer == null ? 0 : buffer.readableBytes();</span>
<span class="fc" id="L1469">            int rc = logAndConvertStatus(status,</span>
                                         BKException.Code.ReadException,
<span class="fc" id="L1471">                                         &quot;ledger&quot;, ledgerId,</span>
<span class="fc" id="L1472">                                         &quot;entry&quot;, entryId,</span>
<span class="fc" id="L1473">                                         &quot;entryLength&quot;, readableBytes);</span>

<span class="pc bpc" id="L1475" title="1 of 2 branches missed.">            if(buffer != null) {</span>
<span class="fc" id="L1476">                buffer = buffer.slice();</span>
            }
<span class="pc bpc" id="L1478" title="1 of 4 branches missed.">            if (maxLAC &gt; INVALID_ENTRY_ID</span>
                &amp;&amp; (ctx instanceof ReadEntryCallbackCtx)) {
<span class="fc" id="L1480">                ((ReadEntryCallbackCtx)ctx).setLastAddConfirmed(maxLAC);</span>
            }
<span class="pc bpc" id="L1482" title="3 of 4 branches missed.">            if (lacUpdateTimestamp &gt; -1L</span>
                &amp;&amp; (ctx instanceof ReadLastConfirmedAndEntryContext)) {
<span class="nc" id="L1484">                ((ReadLastConfirmedAndEntryContext)ctx).setLacUpdateTimestamp(lacUpdateTimestamp);</span>
            }
<span class="fc" id="L1486">            cb.readEntryComplete(rc, ledgerId, entryId, buffer, ctx);</span>
<span class="fc" id="L1487">        }</span>
    }

    class StartTLSCompletion extends CompletionValue {
        final StartTLSCallback cb;

<span class="nc" id="L1493">        public StartTLSCompletion(final CompletionKey key) {</span>
<span class="nc" id="L1494">            super(&quot;StartTLS&quot;, null, -1, -1,</span>
<span class="nc" id="L1495">                  startTLSOpLogger, startTLSTimeoutOpLogger,</span>
<span class="nc" id="L1496">                  scheduleTimeout(key, startTLSTimeout));</span>
<span class="nc" id="L1497">            this.cb = new StartTLSCallback() {</span>
                @Override
                public void startTLSComplete(int rc, Object ctx) {
<span class="nc" id="L1500">                    cancelTimeoutAndLogOp(rc);</span>
<span class="nc" id="L1501">                    key.release();</span>
<span class="nc" id="L1502">                }</span>
            };
<span class="nc" id="L1504">        }</span>

        @Override
        public void errorOut() {
<span class="nc" id="L1508">            errorOut(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc" id="L1509">        }</span>

        @Override
        public void errorOut(final int rc) {
<span class="nc" id="L1513">            failTLS(rc);</span>
<span class="nc" id="L1514">        }</span>

        @Override
        public void handleV3Response(BookkeeperProtocol.Response response) {
<span class="nc" id="L1518">            StatusCode status = response.getStatus();</span>

<span class="nc" id="L1520">            int rc = logAndConvertStatus(status,</span>
                                         BKException.Code.SecurityException);

            // Cancel START_TLS request timeout
<span class="nc" id="L1524">            cb.startTLSComplete(rc, null);</span>

<span class="nc bnc" id="L1526" title="All 2 branches missed.">            if (state != ConnectionState.START_TLS) {</span>
<span class="nc" id="L1527">                LOG.error(&quot;Connection state changed before TLS response received&quot;);</span>
<span class="nc" id="L1528">                failTLS(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc bnc" id="L1529" title="All 2 branches missed.">            } else if (status != StatusCode.EOK) {</span>
<span class="nc" id="L1530">                LOG.error(&quot;Client received error {} during TLS negotiation&quot;, status);</span>
<span class="nc" id="L1531">                failTLS(BKException.Code.SecurityException);</span>
            } else {
<span class="nc" id="L1533">                initTLSHandshake();</span>
            }
<span class="nc" id="L1535">        }</span>

    }

    // visible for testing
    class GetBookieInfoCompletion extends CompletionValue {
        final GetBookieInfoCallback cb;

        public GetBookieInfoCompletion(final CompletionKey key,
                                       final GetBookieInfoCallback origCallback,
<span class="nc" id="L1545">                                       final Object origCtx) {</span>
<span class="nc" id="L1546">            super(&quot;GetBookieInfo&quot;, origCtx, 0L, 0L,</span>
<span class="nc" id="L1547">                  getBookieInfoOpLogger, getBookieInfoTimeoutOpLogger,</span>
<span class="nc" id="L1548">                  scheduleTimeout(key, getBookieInfoTimeout));</span>
<span class="nc" id="L1549">            this.cb = new GetBookieInfoCallback() {</span>
                @Override
                public void getBookieInfoComplete(int rc, BookieInfo bInfo,
                                                  Object ctx) {
<span class="nc" id="L1553">                    cancelTimeoutAndLogOp(rc);</span>
<span class="nc" id="L1554">                    origCallback.getBookieInfoComplete(rc, bInfo, origCtx);</span>
<span class="nc" id="L1555">                    key.release();</span>
<span class="nc" id="L1556">                }</span>
            };
<span class="nc" id="L1558">        }</span>

        @Override
        public void errorOut() {
<span class="nc" id="L1562">            errorOut(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc" id="L1563">        }</span>

        @Override
        public void errorOut(final int rc) {
<span class="nc" id="L1567">            errorOutAndRunCallback(</span>
<span class="nc" id="L1568">                    () -&gt; cb.getBookieInfoComplete(rc, new BookieInfo(), ctx));</span>
<span class="nc" id="L1569">        }</span>

        @Override
        public void handleV3Response(BookkeeperProtocol.Response response) {
<span class="nc" id="L1573">            GetBookieInfoResponse getBookieInfoResponse</span>
<span class="nc" id="L1574">                = response.getGetBookieInfoResponse();</span>
<span class="nc bnc" id="L1575" title="All 2 branches missed.">            StatusCode status = response.getStatus() == StatusCode.EOK</span>
<span class="nc" id="L1576">                ? getBookieInfoResponse.getStatus() : response.getStatus();</span>

<span class="nc" id="L1578">            long freeDiskSpace = getBookieInfoResponse.getFreeDiskSpace();</span>
<span class="nc" id="L1579">            long totalDiskSpace = getBookieInfoResponse.getTotalDiskCapacity();</span>

<span class="nc" id="L1581">            int rc = logAndConvertStatus(status,</span>
                                         BKException.Code.ReadException,
<span class="nc" id="L1583">                                         &quot;freeDisk&quot;, freeDiskSpace,</span>
<span class="nc" id="L1584">                                         &quot;totalDisk&quot;, totalDiskSpace);</span>
<span class="nc" id="L1585">            cb.getBookieInfoComplete(rc,</span>
                                     new BookieInfo(totalDiskSpace,
                                                    freeDiskSpace), ctx);
<span class="nc" id="L1588">        }</span>
    }

<span class="fc" id="L1591">    private final Recycler&lt;AddCompletion&gt; ADD_COMPLETION_RECYCLER = new Recycler&lt;AddCompletion&gt;() {</span>
            protected AddCompletion newObject(Recycler.Handle&lt;AddCompletion&gt; handle) {
<span class="fc" id="L1593">                return new AddCompletion(handle);</span>
            }
        };

    AddCompletion acquireAddCompletion(final CompletionKey key,
                                       final WriteCallback originalCallback,
                                       final Object originalCtx,
                                       final long ledgerId, final long entryId) {
<span class="fc" id="L1601">        AddCompletion completion = ADD_COMPLETION_RECYCLER.get();</span>
<span class="fc" id="L1602">        completion.reset(key, originalCallback, originalCtx, ledgerId, entryId);</span>
<span class="fc" id="L1603">        return completion;</span>
    }

    // visible for testing
    class AddCompletion extends CompletionValue implements WriteCallback {
        final Recycler.Handle&lt;AddCompletion&gt; handle;

<span class="fc" id="L1610">        CompletionKey key = null;</span>
<span class="fc" id="L1611">        WriteCallback originalCallback = null;</span>

<span class="fc" id="L1613">        AddCompletion(Recycler.Handle&lt;AddCompletion&gt; handle) {</span>
<span class="fc" id="L1614">            super(&quot;Add&quot;, null, -1, -1,</span>
<span class="fc" id="L1615">                  addEntryOpLogger, addTimeoutOpLogger, null);</span>
<span class="fc" id="L1616">            this.handle = handle;</span>
<span class="fc" id="L1617">        }</span>

        void reset(final CompletionKey key,
                   final WriteCallback originalCallback,
                   final Object originalCtx,
                   final long ledgerId, final long entryId) {
<span class="fc" id="L1623">            this.key = key;</span>
<span class="fc" id="L1624">            this.originalCallback = originalCallback;</span>
<span class="fc" id="L1625">            this.ctx = originalCtx;</span>
<span class="fc" id="L1626">            this.ledgerId = ledgerId;</span>
<span class="fc" id="L1627">            this.entryId = entryId;</span>
<span class="fc" id="L1628">            this.startTime = MathUtils.nowInNano();</span>
<span class="fc" id="L1629">            this.timeout = scheduleTimeout(key, addEntryTimeout);</span>
<span class="fc" id="L1630">        }</span>

        @Override
        public void writeComplete(int rc, long ledgerId, long entryId,
                                  BookieSocketAddress addr,
                                  Object ctx) {
<span class="fc" id="L1636">            cancelTimeoutAndLogOp(rc);</span>
<span class="fc" id="L1637">            originalCallback.writeComplete(rc, ledgerId, entryId, addr, ctx);</span>
<span class="fc" id="L1638">            key.release();</span>
<span class="fc" id="L1639">            handle.recycle(this);</span>
<span class="fc" id="L1640">        }</span>

        @Override
        public void errorOut() {
<span class="nc" id="L1644">            errorOut(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc" id="L1645">        }</span>

        @Override
        public void errorOut(final int rc) {
<span class="nc" id="L1649">            errorOutAndRunCallback(</span>
<span class="nc" id="L1650">                    () -&gt; writeComplete(rc, ledgerId, entryId, addr, ctx));</span>
<span class="nc" id="L1651">        }</span>

        @Override
        public void handleV2Response(
                long ledgerId, long entryId, StatusCode status,
                BookieProtocol.Response response) {
<span class="nc" id="L1657">            handleResponse(ledgerId, entryId, status);</span>
<span class="nc" id="L1658">        }</span>

        @Override
        public void handleV3Response(
                BookkeeperProtocol.Response response) {
<span class="fc" id="L1663">            AddResponse addResponse = response.getAddResponse();</span>
<span class="pc bpc" id="L1664" title="1 of 2 branches missed.">            StatusCode status = response.getStatus() == StatusCode.EOK</span>
<span class="pc" id="L1665">                ? addResponse.getStatus() : response.getStatus();</span>
<span class="fc" id="L1666">            handleResponse(addResponse.getLedgerId(), addResponse.getEntryId(),</span>
                           status);
<span class="fc" id="L1668">        }</span>

        private void handleResponse(long ledgerId, long entryId,
                                    StatusCode status) {
<span class="fc" id="L1672">            int rc = logAndConvertStatus(status,</span>
                                         BKException.Code.WriteException,
<span class="fc" id="L1674">                                         &quot;ledger&quot;, ledgerId,</span>
<span class="fc" id="L1675">                                         &quot;entry&quot;, entryId);</span>
<span class="fc" id="L1676">            writeComplete(rc, ledgerId, entryId, addr, ctx);</span>
<span class="fc" id="L1677">        }</span>
    }

    // visable for testing
    CompletionKey newCompletionKey(long txnId, OperationType operationType) {
<span class="fc" id="L1682">        return new V3CompletionKey(txnId, operationType);</span>
    }

    Timeout scheduleTimeout(CompletionKey key, long timeout) {
<span class="pc bpc" id="L1686" title="1 of 2 branches missed.">        if (null != requestTimer) {</span>
<span class="fc" id="L1687">            return requestTimer.newTimeout(key, timeout, TimeUnit.SECONDS);</span>
        } else {
<span class="nc" id="L1689">            return null;</span>
        }
    }

    class V3CompletionKey extends CompletionKey {

<span class="fc" id="L1695">        public V3CompletionKey(long txnId, OperationType operationType) {</span>
<span class="fc" id="L1696">            super(txnId, operationType);</span>
<span class="fc" id="L1697">        }</span>

        @Override
        public boolean equals(Object obj) {
<span class="pc bpc" id="L1701" title="1 of 2 branches missed.">            if (!(obj instanceof V3CompletionKey)) {</span>
<span class="nc" id="L1702">                return false;</span>
            }
<span class="fc" id="L1704">            V3CompletionKey that = (V3CompletionKey) obj;</span>
<span class="pc bpc" id="L1705" title="2 of 4 branches missed.">            return this.txnId == that.txnId &amp;&amp; this.operationType == that.operationType;</span>
        }

        @Override
        public int hashCode() {
<span class="fc" id="L1710">            return ((int) txnId);</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L1715">            return String.format(&quot;TxnId(%d), OperationType(%s)&quot;, txnId, operationType);</span>
        }

    }

    abstract class CompletionKey implements TimerTask {
        final long txnId;
        OperationType operationType;

        CompletionKey(long txnId,
<span class="fc" id="L1725">                      OperationType operationType) {</span>
<span class="fc" id="L1726">            this.txnId = txnId;</span>
<span class="fc" id="L1727">            this.operationType = operationType;</span>
<span class="fc" id="L1728">        }</span>

        @Override
        public void run(Timeout timeout) throws Exception {
<span class="nc bnc" id="L1732" title="All 2 branches missed.">            if (timeout.isCancelled()) {</span>
<span class="nc" id="L1733">                return;</span>
            }
<span class="nc" id="L1735">            CompletionValue completion = completionObjects.remove(this);</span>
<span class="nc bnc" id="L1736" title="All 2 branches missed.">            if (completion != null) {</span>
<span class="nc" id="L1737">                completion.timeout();</span>
            }
<span class="nc" id="L1739">        }</span>

<span class="fc" id="L1741">        public void release() {}</span>
    }

    /**
     * Note : Helper functions follow
     */

    /**
     * @param status
     * @return null if the statuscode is unknown.
     */
    private Integer statusCodeToExceptionCode(StatusCode status) {
<span class="fc" id="L1753">        Integer rcToRet = null;</span>
<span class="pc bpc" id="L1754" title="8 of 9 branches missed.">        switch (status) {</span>
            case EOK:
<span class="fc" id="L1756">                rcToRet = BKException.Code.OK;</span>
<span class="fc" id="L1757">                break;</span>
            case ENOENTRY:
<span class="nc" id="L1759">                rcToRet = BKException.Code.NoSuchEntryException;</span>
<span class="nc" id="L1760">                break;</span>
            case ENOLEDGER:
<span class="nc" id="L1762">                rcToRet = BKException.Code.NoSuchLedgerExistsException;</span>
<span class="nc" id="L1763">                break;</span>
            case EBADVERSION:
<span class="nc" id="L1765">                rcToRet = BKException.Code.ProtocolVersionException;</span>
<span class="nc" id="L1766">                break;</span>
            case EUA:
<span class="nc" id="L1768">                rcToRet = BKException.Code.UnauthorizedAccessException;</span>
<span class="nc" id="L1769">                break;</span>
            case EFENCED:
<span class="nc" id="L1771">                rcToRet = BKException.Code.LedgerFencedException;</span>
<span class="nc" id="L1772">                break;</span>
            case EREADONLY:
<span class="nc" id="L1774">                rcToRet = BKException.Code.WriteOnReadOnlyBookieException;</span>
<span class="nc" id="L1775">                break;</span>
            case ETOOMANYREQUESTS:
<span class="nc" id="L1777">                rcToRet = BKException.Code.TooManyRequestsException;</span>
<span class="nc" id="L1778">                break;</span>
            default:
                break;
        }
<span class="fc" id="L1782">        return rcToRet;</span>
    }

    private long getTxnId() {
<span class="fc" id="L1786">        return txnIdGenerator.incrementAndGet();</span>
    }

<span class="fc" id="L1789">    private final Recycler&lt;V2CompletionKey&gt; V2_KEY_RECYCLER = new Recycler&lt;V2CompletionKey&gt;() {</span>
            protected V2CompletionKey newObject(
                    Recycler.Handle&lt;V2CompletionKey&gt; handle) {
<span class="nc" id="L1792">                return new V2CompletionKey(handle);</span>
            }
        };

    V2CompletionKey acquireV2Key(long ledgerId, long entryId,
                             OperationType operationType) {
<span class="nc" id="L1798">        V2CompletionKey key = V2_KEY_RECYCLER.get();</span>
<span class="nc" id="L1799">        key.reset(ledgerId, entryId, operationType);</span>
<span class="nc" id="L1800">        return key;</span>
    }

    private class V2CompletionKey extends CompletionKey {
        private final Handle&lt;V2CompletionKey&gt; recyclerHandle;
        long ledgerId;
        long entryId;

<span class="nc" id="L1808">        private V2CompletionKey(Handle&lt;V2CompletionKey&gt; handle) {</span>
<span class="nc" id="L1809">            super(-1, null);</span>
<span class="nc" id="L1810">            this.recyclerHandle = handle;</span>
<span class="nc" id="L1811">        }</span>

        void reset(long ledgerId, long entryId, OperationType operationType) {
<span class="nc" id="L1814">            this.ledgerId = ledgerId;</span>
<span class="nc" id="L1815">            this.entryId = entryId;</span>
<span class="nc" id="L1816">            this.operationType = operationType;</span>
<span class="nc" id="L1817">        }</span>

        @Override
        public boolean equals(Object object) {
<span class="nc bnc" id="L1821" title="All 2 branches missed.">            if (!(object instanceof V2CompletionKey)) {</span>
<span class="nc" id="L1822">                return  false;</span>
            }
<span class="nc" id="L1824">            V2CompletionKey that = (V2CompletionKey) object;</span>
<span class="nc bnc" id="L1825" title="All 6 branches missed.">            return this.entryId == that.entryId</span>
                &amp;&amp; this.ledgerId == that.ledgerId
                &amp;&amp; this.operationType == that.operationType;
        }

        @Override
        public int hashCode() {
<span class="nc" id="L1832">            return Long.hashCode(ledgerId) * 31 + Long.hashCode(entryId);</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L1837">            return String.format(&quot;%d:%d %s&quot;, ledgerId, entryId, operationType);</span>
        }

        @Override
        public void release() {
<span class="nc" id="L1842">            recyclerHandle.recycle(this);</span>
<span class="nc" id="L1843">        }</span>
    }

<span class="fc" id="L1846">    public class ConnectionFutureListener implements ChannelFutureListener {</span>
        @Override
        public void operationComplete(ChannelFuture future) throws Exception {
<span class="fc" id="L1849">            LOG.debug(&quot;Channel connected ({}) {}&quot;, future.isSuccess(), future.channel());</span>
            int rc;
            Queue&lt;GenericCallback&lt;PerChannelBookieClient&gt;&gt; oldPendingOps;

<span class="fc" id="L1853">            synchronized (PerChannelBookieClient.this) {</span>
<span class="pc bpc" id="L1854" title="3 of 6 branches missed.">                if (future.isSuccess() &amp;&amp; state == ConnectionState.CONNECTING &amp;&amp; future.channel().isActive()) {</span>
<span class="fc" id="L1855">                    LOG.info(&quot;Successfully connected to bookie: {}&quot;, future.channel());</span>
<span class="fc" id="L1856">                    rc = BKException.Code.OK;</span>
<span class="fc" id="L1857">                    channel = future.channel();</span>
<span class="pc bpc" id="L1858" title="1 of 2 branches missed.">                    if (shFactory != null) {</span>
<span class="nc" id="L1859">                        initiateTLS();</span>
<span class="nc" id="L1860">                        return;</span>
                    } else {
<span class="fc" id="L1862">                        LOG.info(&quot;Successfully connected to bookie: &quot; + addr);</span>
<span class="fc" id="L1863">                        state = ConnectionState.CONNECTED;</span>
                    }
<span class="nc bnc" id="L1865" title="All 4 branches missed.">                } else if (future.isSuccess() &amp;&amp; state == ConnectionState.START_TLS) {</span>
<span class="nc" id="L1866">                    rc = BKException.Code.OK;</span>
<span class="nc" id="L1867">                    LOG.info(&quot;Successfully connected to bookie using TLS: &quot; + addr);</span>

<span class="nc" id="L1869">                    state = ConnectionState.CONNECTED;</span>
<span class="nc" id="L1870">                    AuthHandler.ClientSideHandler authHandler = future.channel().pipeline()</span>
<span class="nc" id="L1871">                            .get(AuthHandler.ClientSideHandler.class);</span>
<span class="nc" id="L1872">                    authHandler.authProvider.onProtocolUpgrade();</span>
<span class="nc bnc" id="L1873" title="All 6 branches missed.">                } else if (future.isSuccess() &amp;&amp; (state == ConnectionState.CLOSED</span>
                    || state == ConnectionState.DISCONNECTED)) {
<span class="nc" id="L1875">                    LOG.warn(&quot;Closed before connection completed, clean up: {}, current state {}&quot;,</span>
<span class="nc" id="L1876">                            future.channel(), state);</span>
<span class="nc" id="L1877">                    closeChannel(future.channel());</span>
<span class="nc" id="L1878">                    rc = BKException.Code.BookieHandleNotAvailableException;</span>
<span class="nc" id="L1879">                    channel = null;</span>
<span class="nc bnc" id="L1880" title="All 4 branches missed.">                } else if (future.isSuccess() &amp;&amp; state == ConnectionState.CONNECTED) {</span>
<span class="nc" id="L1881">                    LOG.debug(&quot;Already connected with another channel({}), so close the new channel({})&quot;,</span>
<span class="nc" id="L1882">                            channel, future.channel());</span>
<span class="nc" id="L1883">                    closeChannel(future.channel());</span>
<span class="nc" id="L1884">                    return; // pendingOps should have been completed when other channel connected</span>
                } else {
<span class="nc" id="L1886">                    LOG.error(&quot;Could not connect to bookie: {}/{}, current state {} : &quot;,</span>
<span class="nc" id="L1887">                            new Object[] { future.channel(), addr, state, future.cause() });</span>
<span class="nc" id="L1888">                    rc = BKException.Code.BookieHandleNotAvailableException;</span>
<span class="nc" id="L1889">                    closeChannel(future.channel());</span>
<span class="nc" id="L1890">                    channel = null;</span>
<span class="nc bnc" id="L1891" title="All 2 branches missed.">                    if (state != ConnectionState.CLOSED) {</span>
<span class="nc" id="L1892">                        state = ConnectionState.DISCONNECTED;</span>
                    }
                }

                // trick to not do operations under the lock, take the list
                // of pending ops and assign it to a new variable, while
                // emptying the pending ops by just assigning it to a new
                // list
<span class="fc" id="L1900">                oldPendingOps = pendingOps;</span>
<span class="fc" id="L1901">                pendingOps = new ArrayDeque&lt;&gt;();</span>
<span class="fc" id="L1902">            }</span>

<span class="fc bfc" id="L1904" title="All 2 branches covered.">            for (GenericCallback&lt;PerChannelBookieClient&gt; pendingOp : oldPendingOps) {</span>
<span class="fc" id="L1905">                pendingOp.operationComplete(rc, PerChannelBookieClient.this);</span>
<span class="fc" id="L1906">            }</span>
<span class="fc" id="L1907">        }</span>
    }

    private void initiateTLS() {
<span class="nc" id="L1911">        LOG.info(&quot;Initializing TLS to {}&quot;,channel);</span>
<span class="nc bnc" id="L1912" title="All 4 branches missed.">        assert state == ConnectionState.CONNECTING;</span>
<span class="nc" id="L1913">        final long txnId = getTxnId();</span>
<span class="nc" id="L1914">        final CompletionKey completionKey = new V3CompletionKey(txnId, OperationType.START_TLS);</span>
<span class="nc" id="L1915">        completionObjects.put(completionKey,</span>
                              new StartTLSCompletion(completionKey));
<span class="nc" id="L1917">        BookkeeperProtocol.Request.Builder h = BookkeeperProtocol.Request.newBuilder();</span>
<span class="nc" id="L1918">        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()</span>
<span class="nc" id="L1919">                .setVersion(ProtocolVersion.VERSION_THREE)</span>
<span class="nc" id="L1920">                .setOperation(OperationType.START_TLS)</span>
<span class="nc" id="L1921">                .setTxnId(txnId);</span>
<span class="nc" id="L1922">        h.setHeader(headerBuilder.build());</span>
<span class="nc" id="L1923">        h.setStartTLSRequest(BookkeeperProtocol.StartTLSRequest.newBuilder().build());</span>
<span class="nc" id="L1924">        state = ConnectionState.START_TLS;</span>
<span class="nc" id="L1925">        writeAndFlush(channel, completionKey, h.build());</span>
<span class="nc" id="L1926">    }</span>

    private void failTLS(int rc) {
<span class="nc" id="L1929">        LOG.error(&quot;TLS failure on: {}, rc: {}&quot;, channel, rc);</span>
        Queue&lt;GenericCallback&lt;PerChannelBookieClient&gt;&gt; oldPendingOps;
<span class="nc" id="L1931">        synchronized(this) {</span>
<span class="nc" id="L1932">            disconnect();</span>
<span class="nc" id="L1933">            oldPendingOps = pendingOps;</span>
<span class="nc" id="L1934">            pendingOps = new ArrayDeque&lt;&gt;();</span>
<span class="nc" id="L1935">        }</span>
<span class="nc bnc" id="L1936" title="All 2 branches missed.">        for (GenericCallback&lt;PerChannelBookieClient&gt; pendingOp : oldPendingOps) {</span>
<span class="nc" id="L1937">            pendingOp.operationComplete(rc, null);</span>
<span class="nc" id="L1938">        }</span>
<span class="nc" id="L1939">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>